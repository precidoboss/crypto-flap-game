<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Crypto Flap</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js CDN for audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <!-- Supabase Client CDN -->
    <script type="module">
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';
        // IMPORTANT: This is your provided Supabase Project URL and anon public key.
        // Ensure this exactly matches your Supabase Project Settings > API.
        window.supabase = createClient(
            'https://ahnpnodecccftvscffbx.supabase.co', // Your Supabase Project URL
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFobnBub2RlY2NjZnR2c2NmZmJ4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk4OTc4NTgsImV4cCI6MjA2NTQ3Mzg1OH0.hsGLtErR5gfySWetNGrdo-EjoOl2kuCnOAU4q0Zu_SY', // Your Supabase anon public key
            {
                auth: {
                    persistSession: true // This ensures the session persists across browser closures
                }
            }
        );
        console.log("Supabase client initialized with session persistence.");
    </script>
    <style>
        /* Import Luckiest Guy font */
        @import url('https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap');
        /* Apply Inter font family to the entire body */
        body {
            font-family: 'Inter', Arial, sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            width: 100vw;
            background-image: url('https://i.imgur.com/ESwrOre.png'); 
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
        }
        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-image: none;
            background-color: transparent;
            overflow: hidden;
            border-radius: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: none;
            box-sizing: border-box;
        }
        canvas#particleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 25;
            pointer-events: none;
            display: none;
        }
        .player {
            position: absolute;
            background-image: url('https://i.imgur.com/N3fsA36.png'); 
            background-size: auto 100%;
            background-repeat: no-repeat;
            background-position: 0 0;
            z-index: 10;
            will-change: transform, top, left, background-position;
        }
        .player.shielded {
            box-shadow: 0 0 15px 8px rgba(0, 255, 255, 0.7);
            outline: 3px solid cyan;
            outline-offset: -3px;
        }
        .candle-obstacle {
            position: absolute;
            background-size: 100% 100%; /* Changed to stretch the image to fill the div */
            background-repeat: no-repeat;
            background-position: center;
            z-index: 5;
        }
        .candle-obstacle.red-candle { 
            background-image: url('https://i.imgur.com/yCs6SVg.png');
        }
        .candle-obstacle.green-candle { 
            background-image: url('https://i.imgur.com/uUbXFff.png');
        }
        .collectible-item {
            position: absolute;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 7;
        }
        .collectible-item.potion {
            background-image: url('https://i.imgur.com/cL2ndoI.png');
        }
        .collectible-item.flappy-coin {
            background-image: url('https://i.imgur.com/JZRXMxr.png');
        }
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background-color: rgba(0, 0, 0, 0.4);
            border-bottom-left-radius: 1rem;
            border-bottom-right-radius: 1rem;
            z-index: 20;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        .score {
            font-family: 'Inter', monospace, sans-serif;
            font-size: 2.2rem;
            font-weight: 800;
            color: white;
            text-shadow: 
                0 0 5px #fff,    
                0 0 10px #FFD700, 
                0 0 20px #FFD700, 
                0 0 30px #FFD700, 
                0 0 40px rgba(0, 0, 0, 0.7); 
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .score .player-icon {
            background-image: url('https://i.imgur.com/N3fsA36.png'); 
            background-size: auto 100%;
            background-position: 0 0;
            background-repeat: no-repeat;
            border-radius: 50%;
            overflow: hidden;
        }
        .market-cap {
            font-family: 'Inter', monospace, sans-serif;
            font-size: 2.2rem;
            font-weight: 800;
            color: #FFD700;
            text-shadow: 
                0 0 5px #fff,    
                0 0 10px #FFD700, 
                0 0 20px #FFD700, 
                0 0 30px #FFD700, 
                0 0 40px rgba(0, 0, 0, 0.7); 
        }
        .user-info {
            position: absolute;
            top: 1rem; /* Kept for consistent spacing */
            right: 1rem; /* Kept for consistent spacing */
            font-size: 1.2rem;
            font-weight: 700;
            color: #FFFFFF;
            text-shadow: 
                0 0 3px #fff, 
                0 0 7px rgba(0, 0, 0, 0.8); 
            z-index: 21;
            background-color: rgba(0,0,0,0.4);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            display: none; /* Initially hidden, JS controls visibility */
            align-items: center;
            gap: 0.5rem;
        }
        .user-info.in-game {
            display: none !important;
        }
        .user-info.in-game-over { 
            display: none !important;
        }
        .user-info button {
            background: none;
            border: 1px solid #FFD700;
            color: #FFD700;
            border-radius: 0.3rem;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: 600; 
        }
        .user-info button:hover {
            background-color: #FFD700;
            color: #1a202c;
        }
        .powerup-status {
            font-weight: 800;
            color: #FFD700;
            text-shadow: 
                0 0 5px #fff,    
                0 0 10px #00FFFF, 
                0 0 20px #00FFFF, 
                0 0 30px rgba(0, 0, 0, 0.7); 
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 0.5rem;
            display: none; 
            position: absolute;
            z-index: 20;
        }
        .message-box, .device-selection-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); 
            background-color: rgba(0, 0, 0, 0.95);
            color: white;
            border-radius: 1.5rem; 
            text-align: center;
            z-index: 30;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7); 
            display: none; /* Hidden by default, JS controls visibility */
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
            border: 3px solid #FFD700;
            box-sizing: border-box; 
        }
        .message-box h2, .device-selection-modal h2 {
            font-weight: 900;
            color: #FFD700;
            text-shadow: 
                0 0 7px #fff,     
                0 0 15px #FFD700, 
                0 0 30px #FFD700, 
                0 0 45px #FFD700, 
                0 0 60px rgba(0, 0, 0, 0.8); 
            font-family: 'Inter', monospace, sans-serif; 
        }
        .message-box p, .device-selection-modal p {
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7); 
            font-family: 'Inter', monospace, sans-serif; 
        }
        .message-box input {
            padding: 0.75rem 1rem;
            margin-bottom: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #ddd;
            width: 80%;
            max-width: 300px;
            text-align: center;
            background-color: #333;
            color: white;
            font-size: 1rem;
            font-weight: 500;
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        .message-box input::placeholder {
            color: #bbb;
        }
        .flappy-button {
            background: linear-gradient(to right, #ffe600, #ff9900);
            color: #000;
            font-family: 'Luckiest Guy', cursive;
            border: 4px solid #fff;
            border-radius: 18px;
            box-shadow: 0 6px 14px rgba(0,0,0,0.4), 0 0 10px #ff0 inset;
            text-shadow: 2px 2px #fff;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            position: relative;
            overflow: hidden;
            margin: 6px;
            -webkit-appearance: none; 
            -moz-appearance: none;    
            appearance: none;         
        }
        .flappy-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #ff0, 0 0 40px #ff9900;
        }
        .flappy-button:active {
            transform: scale(0.98);
        }
        .leaderboard-modal, .profile-modal { 
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 40;
            display: flex;
            justify-content: center;
            align-items: center;
            display: none; 
        }
        .leaderboard-content, .profile-content { 
            background-color: rgba(26, 32, 44, 0.98); 
            color: white;
            padding: 2rem;
            border-radius: 1.5rem;
            text-align: center;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
            border: 3px solid #FFD700;
            box-sizing: border-box;
        }
        .leaderboard-content h3, .profile-content h3 { 
            font-size: 2.8rem;
            margin-bottom: 1.5rem;
            font-weight: 800;
            color: #FFD700;
            text-shadow: 
                0 0 5px #fff,    
                0 0 10px #FFD700, 
                0 0 20px #FFD700, 
                0 0 30px rgba(0, 0, 0, 0.7); 
        }
        /* Leaderboard table specific styles */
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.9rem; /* Smaller font for more columns */
        }
        .leaderboard-table th, .leaderboard-table td {
            padding: 0.6rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: left;
        }
        .leaderboard-table th {
            background-color: rgba(255, 215, 0, 0.2); /* Goldish header */
            color: #FFD700;
            font-weight: bold;
            text-transform: uppercase;
        }
        .leaderboard-table tbody tr:nth-child(odd) {
            background-color: rgba(45, 55, 72, 0.7);
        }
        .leaderboard-table tbody tr:nth-child(even) {
            background-color: rgba(45, 55, 72, 0.9);
        }
        .leaderboard-table tbody tr.current-user {
            background-color: #3B82F6; /* Blue for current user */
            color: white;
            font-weight: bold;
            border: 2px solid #FFD700;
        }
        .leaderboard-table tbody tr.top-3 {
            background-color: rgba(255, 215, 0, 0.3); /* Lighter gold for top 3 */
            border: 2px solid #FFD700;
        }
        /* Make columns responsive */
        .leaderboard-table td:nth-child(1), .leaderboard-table th:nth-child(1) { width: 10%; } /* Rank */
        .leaderboard-table td:nth-child(2), .leaderboard-table th:nth-child(2) { width: 35%; } /* Player */
        .leaderboard-table td:nth-child(3), .leaderboard-table th:nth-child(3) { width: 15%; } /* Flappy Score */
        .leaderboard-table td:nth-child(4), .leaderboard-table th:nth-child(4) { width: 20%; } /* Market Cap */
        .leaderboard-table td:nth-child(5), .leaderboard-table th:nth-child(5) { width: 20%; } /* Combined Score */

        @media (max-width: 768px) {
            .leaderboard-table th, .leaderboard-table td {
                padding: 0.4rem;
                font-size: 0.75rem; /* Even smaller font on mobile */
            }
        }

        .profile-content p {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            color: #CBD5E0; 
        }
        .profile-content input {
            margin-top: 1rem;
        }
        .close-button {
            background-color: #E53E3E; 
            color: white;
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-weight: 700; 
            text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
            margin-top: 1.5rem;
        }
        .close-button:hover {
            background-color: #C53030;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: white;
            font-size: 2rem;
            font-family: 'Luckiest Guy', cursive;
            display: none; /* Hidden by default */
        }
        .loading-overlay img {
            width: 80px;
            height: 80px;
            animation: spin 1s linear infinite;
            margin-right: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .glowing-score {
            color: #00FFFF; /* Cyan */
            text-shadow: 
                0 0 5px #fff,    
                0 0 10px #00FFFF, 
                0 0 20px #00FFFF, 
                0 0 30px rgba(0, 255, 255, 0.7); 
            font-weight: bold;
        }
        /* New styles for speed-up text animation */
        .speed-up-text {
            position: absolute;
            top: 20%; /* Adjusted position */
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Luckiest Guy', cursive;
            font-size: 3.5rem; /* Adjust as needed */
            font-weight: 900;
            color: #FFD700; /* Gold color for impact */
            text-shadow: 
                0 0 10px #fff,
                0 0 20px #FFD700,
                0 0 40px #FFD700,
                0 0 80px #FFD700;
            opacity: 0; /* Start hidden */
            transition: opacity 0.5s ease-in-out; /* Smooth fade */
            z-index: 50; /* Above other elements */
            pointer-events: none; /* Do not block clicks */
        }
        .speed-up-text.show {
            opacity: 1; /* Fade in */
        }
    </style>
</head>
<body>
    <div id="gameContainer" class="game-container">
        <canvas id="particleCanvas"></canvas>

        <div id="userInfo" class="user-info">
            Welcome, <span id="userNameDisplay">Guest</span>!
            <button id="profileButton" class="flappy-button small-button">üë§ Profile</button>
            <button id="deviceButton" class="flappy-button small-button">üì± Device</button> <!-- New Device Button -->
            <button id="logoutButton" class="flappy-button small-button">üö™ Logout</button>
        </div>

        <div class="top-bar">
            <div id="score" class="score">
                <span id="playerIcon" class="player-icon"></span>
                $FLAPPY: <span id="flappyScoreCounter">0</span>
            </div>
            <div id="marketCap" class="market-cap">MC: $100,000</div>
        </div>

        <div id="powerupStatus" class="powerup-status"></div>
        <div id="player" class="player"></div>

        <div id="speedUpText" class="speed-up-text">FLAPPY SPEED UP!</div>

        <div id="deviceSelectionModal" class="device-selection-modal">
            <h2>Choose Your Device</h2>
            <p>Select the best experience for your device:</p>
            <div class="flex flex-col items-center mt-4">
                <button id="playOnLaptopButton" class="flappy-button">üíª PLAY ON LAPTOP</button>
                <button id="playOnLargeMobileButton" class="flappy-button">üì± PLAY ON LARGE MOBILE</button> <!-- New Large Mobile Option -->
                <button id="playOnSmallMobileButton" class="flappy-button">üì± PLAY ON SMALL MOBILE</button> <!-- New Small Mobile Option -->
            </div>
        </div>

        <div id="messageBox" class="message-box">
            <h2 id="messageTitle"></h2>
            <p id="messageText"></p>
            <input type="email" id="emailInput" placeholder="Enter your email">
            <input type="text" id="xAccountNameInput" placeholder="Enter your X (Twitter) handle (e.g., @MyFlappyX)">
            <div id="authButtons" class="flex flex-col items-center">
                <button id="signInEmailLinkButton" class="flappy-button">üìß SIGN IN WITH EMAIL LINK</button>
                <button id="registerButton" class="flappy-button hidden">REGISTER (AUTO-LOGIN)</button>
            </div>
            <button id="startButton" class="flappy-button">üïπÔ∏è START GAME (GUEST)</button>
            <button id="leaderboardButton" class="flappy-button">üèÜ LEADERBOARD</button>
            <button id="backToWelcomeButton" class="flappy-button hidden">üîô BACK TO WELCOME</button>
        </div>

        <div id="leaderboardModal" class="leaderboard-modal">
            <div class="leaderboard-content">
                <h3>üèÜ Global Leaderboard</h3>
                <div style="overflow-x: auto;"> <table id="leaderboardTable" class="leaderboard-table">
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Player</th>
                                <th>$FLAPPY</th>
                                <th>Market Cap</th>
                                <th>Combined Score</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td colspan="5">Loading Leaderboard...</td></tr>
                        </tbody>
                    </table>
                </div>
                <button id="leaderboardCloseButton" class="close-button">üîô BACK</button>
            </div>
        </div>

        <div id="profileModal" class="profile-modal">
            <div class="profile-content">
                <h3>üë§ Your Profile</h3>
                <p id="profileEmailDisplay">Email: Not logged in</p>
                <p id="profileXAccountDisplay">X Handle: Not set</p>
                <p id="profileRankDisplay">Rank: Not available</p> <input type="text" id="profileXAccountNameInput" placeholder="Enter your X (Twitter) handle">
                <button id="profileSetXAccountNameButton" class="flappy-button">Update X Handle</button>
                <div class="flex flex-col items-center mt-4">
                    <button id="profileSignInEmailLinkButton" class="flappy-button">üìß Sign In</button>
                    <button id="profileLogoutButton" class="flappy-button">üö™ Logout</button>
                </div>
                <button id="profileCloseButton" class="close-button">üîô BACK</button>
            </div>
        </div>
    </div>
    
    <div id="loadingOverlay" class="loading-overlay">
        <img src="https://i.imgur.com/N3fsA36.png" alt="Loading Coin">
        Loading...
    </div>

    <script>
        // Game constants - now separated into configurations
        const BASE_GAME_WIDTH = 626; 
        const BASE_GAME_HEIGHT = 1131;

        let GAME_WIDTH = window.innerWidth;
        let GAME_HEIGHT = window.innerHeight;

        // --- Device-Specific Configurations ---
        const laptopConfig = {
            PLAYER_SIZE_BASE: 120, // Increased for desktop
            PLAYER_GRAVITY_BASE: 0.18,
            PLAYER_FLAP_STRENGTH_BASE: -4.5,
            MIN_CANDLE_SECTION_HEIGHT_PX_BASE: 50,
            MIN_GAP_HEIGHT_BASE: 120, // Decreased for tighter gaps
            MIN_GAP_HEIGHT_MULTIPLIER: 1.8, // Decreased for tighter gaps relative to player
            AVAILABLE_SPACE_GAP_RANDOM_FACTOR: 0.15, // Reduced for more consistent and tighter gaps
            CANDLE_WIDTH_BASE: 150,
            INITIAL_OBSTACLE_SPEED_BASE: 2.5, // Reverted to original speed for laptop
            OBSTACLE_INTERVAL_MIN: 1500, 
            OBSTACLE_INTERVAL_MAX: 2250, 
            MAX_VERTICAL_GAP_SHIFT: 0.25, // Max vertical shift between consecutive gaps (fraction of screen height)
            SPEED_INCREASE_MILESTONE_MC_INCREMENT: 20000, // How often speed increases based on MC
            PLAYER_HITBOX_SHRINK_X: 0.45, // Default shrinkage for laptop
            PLAYER_HITBOX_SHRINK_Y: 0.45  // Default shrinkage for laptop
        };

        // Configuration for larger mobile phones (e.g., iPhone 12 Pro Max)
        const largeMobileConfig = {
            PLAYER_SIZE_BASE: 110, 
            PLAYER_GRAVITY_BASE: 0.25, 
            PLAYER_FLAP_STRENGTH_BASE: -5.5, 
            MIN_CANDLE_SECTION_HEIGHT_PX_BASE: 80, 
            MIN_GAP_HEIGHT_BASE: 200, 
            MIN_GAP_HEIGHT_MULTIPLIER: 1.8, 
            AVAILABLE_SPACE_GAP_RANDOM_FACTOR: 0.20, 
            CANDLE_WIDTH_BASE: 200, 
            INITIAL_OBSTACLE_SPEED_BASE: 3.2, // User's requested speed
            OBSTACLE_INTERVAL_MIN: 2600, 
            OBSTACLE_INTERVAL_MAX: 3600, 
            MAX_VERTICAL_GAP_SHIFT: 0.15, 
            SPEED_INCREASE_MILESTONE_MC_INCREMENT: 20000,
            PLAYER_HITBOX_SHRINK_X: 0.45, 
            PLAYER_HITBOX_SHRINK_Y: 0.45
        };

        // Configuration for smaller mobile phones (e.g., iPhone 7)
        const smallMobileConfig = {
            PLAYER_SIZE_BASE: 80, // Further reduced player size for better performance and agile feel
            PLAYER_GRAVITY_BASE: 0.25, 
            PLAYER_FLAP_STRENGTH_BASE: -5.5, 
            MIN_CANDLE_SECTION_HEIGHT_PX_BASE: 75, // Slightly adjusted for more vertical play
            MIN_GAP_HEIGHT_BASE: 150, // Further reduced gap height for more challenge (was 160)
            MIN_GAP_HEIGHT_MULTIPLIER: 1.8, 
            AVAILABLE_SPACE_GAP_RANDOM_FACTOR: 0.20, 
            CANDLE_WIDTH_BASE: 220, // Increased candle width (was 200)
            INITIAL_OBSTACLE_SPEED_BASE: 4.8, // Increased initial speed for a faster start
            OBSTACLE_INTERVAL_MIN: 2800, // Reduced interval for closer obstacles (was 3500)
            OBSTACLE_INTERVAL_MAX: 4000, // Reduced interval for closer obstacles (was 5000)
            MAX_VERTICAL_GAP_SHIFT: 0.35, // Increased for more dynamic vertical movement
            SPEED_INCREASE_MILESTONE_MC_INCREMENT: 12000, // Kept for frequent speed up
            PLAYER_HITBOX_SHRINK_X: 0.25, // Reduced shrinkage for larger effective hitbox
            PLAYER_HITBOX_SHRINK_Y: 0.25  // Reduced shrinkage for larger effective hitbox
        };

        let currentConfig = laptopConfig; // Default, will be set by device detection or local storage

        // Variables that will take values from currentConfig
        let PLAYER_GRAVITY; 
        let PLAYER_FLAP_STRENGTH; 
        let PLAYER_SIZE; // Player size will be calculated from PLAYER_SIZE_BASE
        let MIN_CANDLE_SECTION_HEIGHT_PX;
        let MIN_GAP_HEIGHT;
        let CANDLE_WIDTH;
        let INITIAL_OBSTACLE_SPEED;
        let OBSTACLE_INTERVAL_MIN;
        let OBSTACLE_INTERVAL_MAX;
        let MAX_VERTICAL_GAP_SHIFT;
        let PLAYER_HITBOX_SHRINK_X;
        let PLAYER_HITBOX_SHRINK_Y;


        // Derived variables (calculated in calculateGameDimensions)
        let currentScaledCandleWidth;
        let currentScaledMinGapHeight;
        let currentScaledMinCandleSectionHeight;

        const MAX_ROTATION_DEGREES = 35;
        const DESIRED_GAP_HEIGHT_RATIO = 0.25; 
        
        const FLAP_SOUND_COOLDOWN = 150; 

        const POTION_SPAWN_CHANCE_RATE = 0.10; 

        const SHIELD_DURATION = 5000;
        const INITIAL_MARKET_CAP = 100000;
        const MARKET_CAP_PER_BASE_CANDLE_WIDTH = 1000; 

        const PLAYER_SPRITE_SHEET_URL = "https://i.imgur.com/N3fsA36.png"; 
        const PLAYER_SPRITE_FRAME_COUNT = 4; 
        let PLAYER_SPRITE_WIDTH; 
        let PLAYER_SPRITE_HEIGHT; 

        const BACKGROUND_IMAGE_URL = "https://i.imgur.com/ESwrOre.png"; 
        const RED_CANDLE_IMAGE_URL = "https://i.imgur.com/yCs6SVg.png";
        const GREEN_CANDLE_IMAGE_URL = "https://i.imgur.com/uUbXFff.png"; 
        const POTION_IMAGE_URL = "https://i.imgur.com/cL2ndoI.png";
        const FLAPPY_COIN_IMAGE_URL = "https://i.imgur.com/JZRXMxr.png";

        const SPRITE_ANIMATION_SPEED = 250; // Increased for less frequent updates, better performance 

        // DOM element references
        const gameContainer = document.getElementById('gameContainer');
        const player = document.getElementById('player');
        const flappyScoreCounter = document.getElementById('flappyScoreCounter'); 
        const playerIcon = document.getElementById('playerIcon');
        const marketCapDisplay = document.getElementById('marketCap');
        const powerupStatusDisplay = document.getElementById('powerupStatus');
        const speedUpText = document.getElementById('speedUpText'); // New element reference

        const deviceSelectionModal = document.getElementById('deviceSelectionModal'); 
        const playOnLaptopButton = document.getElementById('playOnLaptopButton');     
        const playOnLargeMobileButton = document.getElementById('playOnLargeMobileButton'); // New
        const playOnSmallMobileButton = document.getElementById('playOnSmallMobileButton'); // New   

        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const emailInput = document.getElementById('emailInput'); 
        const xAccountNameInput = document.getElementById('xAccountNameInput'); 
        const authButtonsDiv = document.getElementById('authButtons'); 

        // Main screen buttons
        const signInEmailLinkButton = document.getElementById('signInEmailLinkButton'); 
        const registerButton = document.getElementById('registerButton');
        const startButton = document.getElementById('startButton'); 
        const leaderboardButton = document.getElementById('leaderboardButton');
        const backToWelcomeButton = document.getElementById('backToWelcomeButton'); 

        // User info area buttons
        const userInfoDisplay = document.getElementById('userInfo');
        const userNameDisplay = document.getElementById('userNameDisplay');
        const profileButton = document.getElementById('profileButton'); 
        const deviceButton = document.getElementById('deviceButton'); // New
        const logoutButton = document.getElementById('logoutButton');

        // Modals and their elements
        const leaderboardModal = document.getElementById('leaderboardModal');
        const leaderboardTableBody = document.querySelector('#leaderboardTable tbody'); 
        const leaderboardCloseButton = document.getElementById('leaderboardCloseButton');

        const profileModal = document.getElementById('profileModal'); 
        const profileEmailDisplay = document.getElementById('profileEmailDisplay'); 
        const profileXAccountDisplay = document.getElementById('profileXAccountDisplay'); 
        const profileRankDisplay = document.getElementById('profileRankDisplay'); 
        const profileXAccountNameInput = document.getElementById('profileXAccountNameInput'); 
        const profileSetXAccountNameButton = document.getElementById('profileXAccountNameButton'); 
        const profileLogoutButton = document.getElementById('profileLogoutButton'); 
        const profileCloseButton = document.getElementById('profileCloseButton'); 

        const loadingOverlay = document.getElementById('loadingOverlay');

        // Canvas related elements
        const particleCanvas = document.getElementById('particleCanvas');
        const particleCtx = particleCanvas.getContext('2d');
        let particles = [];
        let particleAnimationFrameId = null;

        // Game state variables
        window.playerY = GAME_HEIGHT / 2;
        window.playerVelocity = 0;
        window.obstacles = []; 
        window.items = []; 
        window.score = 0;
        window.marketCap = INITIAL_MARKET_CAP;
        window.gameStarted = false;
        window.gameOver = false;
        window.lastObstacleTime = 0;
        window.animationFrameId;

        window.shieldActive = false;
        window.shieldTimer = null;
        window.currentObstacleSpeed = 0; 
        window.lastMarketCapSpeedMilestone = INITIAL_MARKET_CAP; // New variable for speed increase
        window.lastGapY = GAME_HEIGHT / 2; // Initialize for vertical consistency

        window.currentSpriteFrameIndex = 0;
        window.spriteAnimationInterval = null;

        // Tone.js specific variables
        let flapSynth = null; 

        window.isStartingGame = false; 
        window.lastFlapSoundTime = 0;  

        // Supabase related variables
        let currentUser = null;
        let currentProfile = null;
        let isLoggedIn = false;

        /**
         * Calculates the actual rendered dimensions of the game area and adjusts all dynamic elements.
         * This ensures everything scales proportionally to the current screen size.
         */
        function calculateGameDimensions() {
            GAME_WIDTH = window.innerWidth;
            GAME_HEIGHT = window.innerHeight;

            // IMPORTANT: Add a guard to prevent calculations with zero dimensions
            if (GAME_WIDTH === 0 || GAME_HEIGHT === 0) {
                console.warn("calculateGameDimensions called with zero window dimensions. Skipping calculations for now.");
                return; // Exit if dimensions are invalid
            }

            // Apply current configuration parameters
            PLAYER_GRAVITY = currentConfig.PLAYER_GRAVITY_BASE * (GAME_HEIGHT / BASE_GAME_HEIGHT);
            PLAYER_FLAP_STRENGTH = currentConfig.PLAYER_FLAP_STRENGTH_BASE * (GAME_HEIGHT / BASE_GAME_HEIGHT);
            // currentObstacleSpeed is now handled dynamically in gameLoop, but needs initial value
            if (window.currentObstacleSpeed === 0 || !window.gameStarted) { // Only set initial speed if not already in game
                window.currentObstacleSpeed = currentConfig.INITIAL_OBSTACLE_SPEED_BASE * (GAME_WIDTH / BASE_GAME_WIDTH); 
            }
            OBSTACLE_INTERVAL_MIN = currentConfig.OBSTACLE_INTERVAL_MIN;
            OBSTACLE_INTERVAL_MAX = currentConfig.OBSTACLE_INTERVAL_MAX;
            MAX_VERTICAL_GAP_SHIFT = currentConfig.MAX_VERTICAL_GAP_SHIFT; // Get from config
            PLAYER_HITBOX_SHRINK_X = currentConfig.PLAYER_HITBOX_SHRINK_X; // New: Get from config
            PLAYER_HITBOX_SHRINK_Y = currentConfig.PLAYER_HITBOX_SHRINK_Y; // New: Get from config


            // Player dimensions scale with GAME_HEIGHT, with a higher minimum
            PLAYER_SPRITE_HEIGHT = Math.max(70, GAME_HEIGHT * (currentConfig.PLAYER_SIZE_BASE / BASE_GAME_HEIGHT)); 
            PLAYER_SPRITE_WIDTH = PLAYER_SPRITE_HEIGHT; // Keep player square
            player.style.width = `${PLAYER_SPRITE_WIDTH}px`;
            player.style.height = `${PLAYER_SPRITE_HEIGHT}px`;

            // Adjust player initial position based on new GAME_HEIGHT
            // Only set player initial position if game is not started or game over
            // If game is running, player's position is managed by gameLoop
            if (!window.gameStarted || window.gameOver) {
                window.playerY = (GAME_HEIGHT / 2) - (player.offsetHeight / 2); // Use player.offsetHeight after setting width/height
                player.style.top = `${window.playerY}px`; 
                player.style.left = `${(GAME_WIDTH / 2) - (player.offsetWidth / 2)}px`;
                player.style.transform = `rotateZ(0deg)`; 
            }
            

            // Calculate current scaled candle width, min gap, and min candle section height
            currentScaledCandleWidth = Math.max(70, GAME_WIDTH * (currentConfig.CANDLE_WIDTH_BASE / BASE_GAME_WIDTH)); 
            const scaleFactorForHeight = GAME_HEIGHT / BASE_GAME_HEIGHT;
            currentScaledMinGapHeight = currentConfig.MIN_GAP_HEIGHT_BASE * scaleFactorForHeight;
            currentScaledMinCandleSectionHeight = Math.max(70, currentConfig.MIN_CANDLE_SECTION_HEIGHT_PX_BASE * scaleFactorForHeight); 

            // Adjust UI element sizes and positions based on a common scale factor
            const scaleFactor = Math.min(GAME_WIDTH / BASE_GAME_WIDTH, GAME_HEIGHT / BASE_GAME_HEIGHT);
            
            // Top Bar
            const topBarPadding = 1 * scaleFactor; 
            document.querySelector('.top-bar').style.padding = `${topBarPadding}rem`;
            document.querySelector('.score').style.fontSize = `${2.2 * scaleFactor}rem`;
            document.querySelector('.score .player-icon').style.width = `${40 * scaleFactor}px`;
            document.querySelector('.score .player-icon').style.height = `${40 * scaleFactor}px`;
            document.querySelector('.market-cap').style.fontSize = `${2.2 * scaleFactor}rem`;

            // User Info (Profile/Device/Logout)
            document.querySelector('.user-info').style.top = `${1 * scaleFactor}rem`;
            document.querySelector('.user-info').style.right = `${1 * scaleFactor}rem`;
            document.querySelector('.user-info').style.fontSize = `${1.2 * scaleFactor}rem`;
            document.querySelector('.user-info').style.padding = `${0.5 * scaleFactor}rem ${1 * scaleFactor}rem`;
            document.querySelector('.user-info').style.borderRadius = `${0.5 * scaleFactor}rem`;
            
            // Re-apply button styles as they are globally affected
            document.querySelectorAll('.user-info button').forEach(btn => {
                btn.style.padding = `${0.2 * scaleFactor}rem ${0.6 * scaleFactor}rem`;
                btn.style.fontSize = `${0.9 * scaleFactor}rem`;
                btn.style.borderRadius = `${0.3 * scaleFactor}rem`;
            });


            // Powerup Status
            powerupStatusDisplay.style.top = `${(70 * scaleFactor)}px`; 
            powerupStatusDisplay.style.right = `${1 * scaleFactor}rem`;
            powerupStatusDisplay.style.fontSize = `${1.8 * scaleFactor}rem`;
            powerupStatusDisplay.style.padding = `${0.5 * scaleFactor}rem ${1 * scaleFactor}rem`;
            powerupStatusDisplay.style.borderRadius = `${0.5 * scaleFactor}rem`;

            // Speed Up Text - Adjusted top position
            speedUpText.style.fontSize = `${3.5 * scaleFactor}rem`;
            speedUpText.style.top = `${GAME_HEIGHT * 0.20}px`; // 20% from the top


            // Message Box & Device Selection Modal
            document.querySelectorAll('.message-box, .device-selection-modal').forEach(modal => {
                modal.style.padding = `${1 * scaleFactor}rem ${1.5 * scaleFactor}rem`;
                modal.style.borderRadius = `${1.5 * scaleFactor}rem`;
                modal.style.borderWidth = `${3 * scaleFactor}px`;
            });
            document.querySelectorAll('.message-box h2, .device-selection-modal h2').forEach(h2 => {
                h2.style.fontSize = `${2 * scaleFactor}rem`;
                h2.style.marginBottom = `${0.6 * scaleFactor}rem`;
            });
            document.querySelectorAll('.message-box p, .device-selection-modal p').forEach(p => {
                p.style.fontSize = `${1 * scaleFactor}rem`;
                p.style.marginBottom = `${0.8 * scaleFactor}rem`;
            });
            
            // Buttons
            const buttonFontSize = 20 * scaleFactor;
            const buttonPaddingY = 14 * scaleFactor;
            const buttonPaddingX = 30 * scaleFactor;
            const buttonBorder = 4 * scaleFactor;
            const buttonRadius = 18 * scaleFactor;
            const buttonMargin = 6 * scaleFactor;

            document.querySelectorAll('.flappy-button').forEach(btn => {
                btn.style.fontSize = `${buttonFontSize}px`;
                btn.style.padding = `${buttonPaddingY}px ${buttonPaddingX}px`;
                btn.style.borderWidth = `${buttonBorder}px`;
                btn.style.borderRadius = `${buttonRadius}px`;
                btn.style.margin = `${buttonMargin}px`;
            });
            // Specific close button adjustments
            document.querySelectorAll('.close-button').forEach(btn => {
                btn.style.padding = `${0.8 * scaleFactor}rem ${1.5 * scaleFactor}rem`;
                btn.style.fontSize = `${1.2 * scaleFactor}rem`;
                btn.style.borderRadius = `${0.75 * scaleFactor}rem`;
                btn.style.marginTop = `${1.5 * scaleFactor}rem`;
            });
            
            // Input fields
            document.querySelectorAll('.message-box input, .profile-content input').forEach(input => {
                input.style.padding = `${0.75 * scaleFactor}rem ${1 * scaleFactor}rem`;
                input.style.marginBottom = `${1 * scaleFactor}rem`;
                input.style.borderRadius = `${0.5 * scaleFactor}rem`;
                input.style.fontSize = `${1 * scaleFactor}rem`;
                input.style.marginTop = `${1 * scaleFactor}rem`;
            });

            // Modals
            document.querySelectorAll('.leaderboard-content, .profile-content').forEach(modal => {
                modal.style.padding = `${2 * scaleFactor}rem`;
                modal.style.borderRadius = `${1.5 * scaleFactor}rem`;
                modal.style.borderWidth = `${3 * scaleFactor}px`;
            });
            document.querySelectorAll('.leaderboard-content h3, .profile-content h3').forEach(h3 => {
                h3.style.fontSize = `${2.8 * scaleFactor}rem`;
                h3.style.marginBottom = `${1.5 * scaleFactor}rem`;
            });
             // Adjust table headers/cells based on scale
            document.querySelectorAll('.leaderboard-table th, .leaderboard-table td').forEach(cell => {
                cell.style.padding = `${0.6 * scaleFactor}rem`;
                cell.style.fontSize = `${0.9 * scaleFactor}rem`;
            });


            document.querySelectorAll('.profile-content p').forEach(p => {
                p.style.fontSize = `${1.2 * scaleFactor}rem`;
                p.style.marginBottom = `${1 * scaleFactor}rem`;
            });

            // Canvas for particles
            particleCanvas.width = GAME_WIDTH;
            particleCanvas.height = GAME_HEIGHT;
            createParticles(); 

            // --- DEBUG LOGGING ---
            console.log("--- calculateGameDimensions Debug ---");
            console.log(`GAME_WIDTH: ${GAME_WIDTH}, GAME_HEIGHT: ${GAME_HEIGHT}`);
            console.log(`PLAYER_SPRITE_WIDTH: ${PLAYER_SPRITE_WIDTH}, PLAYER_SPRITE_HEIGHT: ${PLAYER_SPRITE_HEIGHT}`);
            console.log(`currentScaledCandleWidth: ${currentScaledCandleWidth}`);
            console.log(`currentScaledMinGapHeight: ${currentScaledMinGapHeight}`);
            console.log(`currentScaledMinCandleSectionHeight: ${currentScaledMinCandleSectionHeight}`);
            console.log(`OBSTACLE_INTERVAL_MIN: ${OBSTACLE_INTERVAL_MIN}, OBSTACLE_INTERVAL_MAX: ${OBSTACLE_INTERVAL_MAX}`);
            console.log(`MAX_VERTICAL_GAP_SHIFT: ${MAX_VERTICAL_GAP_SHIFT}`);
            console.log(`PLAYER_HITBOX_SHRINK_X: ${PLAYER_HITBOX_SHRINK_X}, PLAYER_HITBOX_SHRINK_Y: ${PLAYER_HITBOX_SHRINK_Y}`);
            console.log("-------------------------------------");
        }

        /**
         * Shows the loading overlay.
         * @param {string} message - The message to display on the loading screen.
         */
        function showLoading(message = "Loading...") {
            loadingOverlay.querySelector('img').style.display = 'block'; // Show spinner
            loadingOverlay.innerHTML = `<img src="https://i.imgur.com/N3fsA36.png" alt="Loading Coin"> ${message}`;
            loadingOverlay.style.display = 'flex';
        }

        /**
         * Hides the loading overlay.
         */
        function hideLoading() {
            loadingOverlay.style.display = 'none';
        }

        /**
         * Formats a number as currency with commas.
         * @param {number} num - The number to format.
         * @returns {string} The formatted currency string.
         */
        function formatCurrency(num) {
            return num.toLocaleString('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 });
        }
        
        /**
         * Initializes Tone.js audio context and synths.
         * This must be called after a user gesture to avoid browser autoplay policies.
         * Synths are disposed and recreated to ensure a clean state between games.
         */
        async function initAudio() {
            console.log("initAudio called. Tone.context.state:", Tone.context.state);
            if (flapSynth) { 
                flapSynth.dispose();
                flapSynth = null;
            }

            if (Tone.context.state === 'suspended') {
                try {
                    await Tone.start();
                    console.log('Audio context resumed after user gesture.');
                } catch (e) {
                    console.error('Failed to resume audio context:', e);
                }
            } else {
                console.log('Audio context state:', Tone.context.state);
            }

            flapSynth = new Tone.MembraneSynth({ 
                pitchDecay: 0.05, octaves: 8,
                envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.4, attackCurve: "exponential" },
                volume: -10
            }).toDestination();
            console.log('Flap synth created.');
        }

        /**
         * Updates the player's size based on sprite dimensions.
         */
        const updatePlayerSize = () => {
            player.style.left = `${(GAME_WIDTH - player.offsetWidth) / 2}px`; 
        };

        /**
         * Updates the player's vertical position based on gravity and velocity,
         * handles boundary checks, and applies rotation based on vertical movement.
         */
        function updatePlayer() {
            if (!window.gameStarted || window.gameOver) return;

            window.playerVelocity += PLAYER_GRAVITY; 
            window.playerY += window.playerVelocity; 

            const rotationFactor = 0.5;
            const normalizedVelocity = Math.max(-1, Math.min(1, window.playerVelocity * rotationFactor)); 
            const rotationAngle = normalizedVelocity * MAX_ROTATION_DEGREES;

            if (window.playerY < 0) { 
                window.playerY = 0; 
                window.playerVelocity = 0; 
            }
            if (window.playerY > GAME_HEIGHT - player.offsetHeight) { 
                window.playerY = GAME_HEIGHT - player.offsetHeight; 
                window.playerVelocity = 0; 
                endGame(); 
                return; 
            }
            player.style.top = `${window.playerY}px`; 
            player.style.left = `${(GAME_WIDTH / 2) - (player.offsetWidth / 2)}px`;
            player.style.transform = `rotateZ(${rotationAngle}deg)`; 
            // DEBUG: Log player position and velocity
            // console.log(`[UpdatePlayer] Y: ${window.playerY.toFixed(2)}, Velocity: ${window.playerVelocity.toFixed(2)}, Gravity: ${PLAYER_GRAVITY.toFixed(2)}`);
        }

        /**
         * Creates a new collectible item (potion or flappy coin).
         * @param {number} xPos - The x-position for the item.
         * @param {number} gapY - The y-position of the gap for placement.
         * @param {number} gapHeight - The height of the gap.
         */
        function createCollectible(xPos, gapY, gapHeight) {
            const itemElement = document.createElement('div');
            const roll = Math.random();
            let itemType;
            if (roll < POTION_SPAWN_CHANCE_RATE) { 
                itemType = 'potion';
            } else { 
                itemType = 'flappy-coin';
            }
            itemElement.classList.add('collectible-item', itemType);
            
            const itemWidth = PLAYER_SPRITE_WIDTH * 0.9; 
            const itemHeight = PLAYER_SPRITE_HEIGHT * 0.9; 

            const itemY = gapY + (gapHeight / 2) - (itemHeight / 2);
            
            itemElement.style.width = `${itemWidth}px`;
            itemElement.style.height = `${itemHeight}px`;
            itemElement.style.left = `${xPos - (itemWidth / 2)}px`; 
            itemElement.style.top = `${itemY}px`;

            gameContainer.appendChild(itemElement);
            window.items.push({ 
                element: itemElement,
                x: xPos - (itemWidth / 2),
                y: itemY,
                width: itemWidth,
                height: itemHeight,
                type: itemType
            });
            // DEBUG: Log item creation
            // console.log(`[CreateCollectible] Created ${itemType} at x:${itemElement.style.left}, y:${itemElement.style.top}`);
        }
        
        /**
         * Creates a new candle obstacle (pair of green and red) with a random gap.
         * Green candles from top, Red candles from bottom.
         */
        function createCandleObstacle() {
            // Determine the actual minimum gap, ensuring it's at least currentScaledMinGapHeight
            const currentMinGap = Math.max(currentScaledMinGapHeight, player.offsetHeight * currentConfig.MIN_GAP_HEIGHT_MULTIPLIER); 
            
            // Randomly determine the gap height, now based on a smaller random factor of available space
            // This makes the gaps more consistently tighter or wider depending on config
            const gapHeight = currentMinGap + Math.random() * (GAME_HEIGHT * currentConfig.AVAILABLE_SPACE_GAP_RANDOM_FACTOR); 

            // Define comfortable vertical bounds for the gap's top position
            // Increased minGapYPosition to keep candles from being too high
            const minGapYPosition = player.offsetHeight * 2.5; 
            const maxGapYPosition = GAME_HEIGHT - player.offsetHeight * 1.5 - gapHeight; 

            let actualGapY;
            // Initialize targetY with a default sensible value within the allowed range
            // This ensures targetY is always defined before being used in debug logs or calculations.
            let targetY = (minGapYPosition + maxGapYPosition) / 2; 

            if (minGapYPosition >= maxGapYPosition) { 
                actualGapY = (GAME_HEIGHT - gapHeight) / 2; 
                targetY = actualGapY; // Set targetY to the final value for logging consistency
            } else {
                // Generate a random shift around 0 (positive or negative)
                const randomShift = (Math.random() - 0.5) * MAX_VERTICAL_GAP_SHIFT * GAME_HEIGHT;
                // Calculate the target Y for the new gap, centered around the last gap's Y
                targetY = window.lastGapY + randomShift; // Re-assign if in the 'else' branch
                // Ensure targetY stays within the overall allowed vertical bounds
                actualGapY = Math.max(minGapYPosition, Math.min(maxGapYPosition, targetY));
            }
            
            // Update lastGapY for the next obstacle calculation
            window.lastGapY = actualGapY;

            const topCandleHeight = actualGapY; 
            const bottomCandleHeight = GAME_HEIGHT - actualGapY - gapHeight;

            // Ensure minimum candle section height
            const finalTopCandleHeight = Math.max(currentScaledMinCandleSectionHeight, topCandleHeight);
            const finalBottomCandleHeight = Math.max(currentScaledMinCandleSectionHeight, bottomCandleHeight);

            // Re-adjust gap height if minimum candle heights force it
            const newGapHeight = GAME_HEIGHT - finalTopCandleHeight - finalBottomCandleHeight;
            const newGapY = finalTopCandleHeight;

            // --- Create the Green (Top) Candle ---
            const greenCandle = document.createElement('div');
            greenCandle.classList.add('candle-obstacle', 'green-candle'); 
            greenCandle.style.height = `${finalTopCandleHeight}px`; 
            greenCandle.style.width = `${currentScaledCandleWidth}px`; 
            greenCandle.style.left = `${GAME_WIDTH}px`; 
            greenCandle.style.top = `0px`; 

            // --- Create the Red (Bottom) Candle ---
            const redCandle = document.createElement('div');
            redCandle.classList.add('candle-obstacle', 'red-candle'); 
            redCandle.style.height = `${finalBottomCandleHeight}px`; 
            redCandle.style.width = `${currentScaledCandleWidth}px`; 
            redCandle.style.left = `${GAME_WIDTH}px`; 
            redCandle.style.top = `${newGapY + newGapHeight}px`; 

            gameContainer.appendChild(greenCandle); // Append green first (top)
            gameContainer.appendChild(redCandle); // Append red second (bottom)

            window.obstacles.push({ 
                redElement: redCandle,
                greenElement: greenCandle,
                x: GAME_WIDTH, 
                gapY: newGapY,
                gapHeight: newGapHeight,
                width: currentScaledCandleWidth, 
                topHeight: finalTopCandleHeight, // Store calculated height
                bottomHeight: finalBottomCandleHeight // Store calculated height
            });

            // Always create a collectible here
            createCollectible(redCandle.offsetLeft + currentScaledCandleWidth / 2, newGapY, newGapHeight);

            // --- DEBUG LOGGING ---
            console.log("--- createCandleObstacle Debug ---");
            console.log(`Calculated gapHeight: ${gapHeight.toFixed(2)}`);
            // Now targetY is always defined for logging
            console.log(`Calculated actualGapY (before clamping): ${targetY.toFixed(2)}`); 
            console.log(`Final actualGapY (clamped): ${actualGapY.toFixed(2)}`);
            console.log(`Final newGapHeight: ${newGapHeight.toFixed(2)}`);
            console.log(`Final topCandleHeight: ${finalTopCandleHeight.toFixed(2)}`);
            console.log(`Final bottomCandleHeight: ${finalBottomCandleHeight.toFixed(2)}`);
            console.log(`window.lastGapY (updated): ${window.lastGapY.toFixed(2)}`);
            console.log("----------------------------------");
        }

        /**
         * Updates the position of all active obstacles and items, handles removal,
         * and updates score/market cap.
         */
        function updateObstaclesAndItems() {
            if (!window.gameStarted || window.gameOver) return; 

            for (let i = 0; i < window.obstacles.length; i++) { 
                const obstacle = window.obstacles[i]; 
                obstacle.x -= window.currentObstacleSpeed; 
                obstacle.greenElement.style.left = `${obstacle.x}px`; 
                obstacle.redElement.style.left = `${obstacle.x}px`; 
                // DEBUG: Log obstacle position
                // console.log(`[UpdateObstacles] Obstacle ${i} x: ${obstacle.x.toFixed(2)}`);


                if (obstacle.x + obstacle.width < 0) {
                    // DEBUG: Log obstacle removal
                    // console.log(`Removing obstacle ${i} (off-screen)`);
                    if (gameContainer.contains(obstacle.greenElement)) gameContainer.removeChild(obstacle.greenElement);
                    if (gameContainer.contains(obstacle.redElement)) gameContainer.removeChild(obstacle.redElement);
                    window.obstacles.splice(i, 1); 
                    i--;
                }
            }

            for (let i = 0; i < window.items.length; i++) { 
                const item = window.items[i]; 
                item.x -= window.currentObstacleSpeed; 
                item.element.style.left = `${item.x}px`;
                // DEBUG: Log item position
                // console.log(`[UpdateItems] Item ${i} x: ${item.x.toFixed(2)}`);

                if (item.x + item.width < 0) {
                    // DEBUG: Log item removal
                    // console.log(`Removing item ${i} (off-screen)`);
                    if (gameContainer.contains(item.element)) gameContainer.removeChild(item.element);
                    window.items.splice(i, 1); 
                    i--;
                }
            }

            const currentTime = Date.now();
            const randomInterval = Math.random() * (OBSTACLE_INTERVAL_MAX - OBSTACLE_INTERVAL_MIN) + OBSTACLE_INTERVAL_MIN;
            // DEBUG: Log interval
            // console.log(`[Obstacle Creation] Time elapsed: ${currentTime - window.lastObstacleTime}ms, Random interval target: ${randomInterval.toFixed(0)}ms`);
            if (currentTime - window.lastObstacleTime > randomInterval) { 
                createCandleObstacle();
                window.lastObstacleTime = currentTime; 
                // console.log("New obstacle created!");
            }
        }

        /**
         * Checks for collisions between the player and candles or items.
         */
        function checkCollisions() {
            if (!window.gameStarted || window.gameOver) return; 

            // Get player's current position and dimensions.
            // We use getBoundingClientRect() once here for the player's current rendered position.
            const playerRect = player.getBoundingClientRect();
            
            // Define player's effective collision box, slightly smaller than visual for forgiveness
            const playerHitboxShrinkAmountX = PLAYER_HITBOX_SHRINK_X * playerRect.width; 
            const playerHitboxShrinkAmountY = PLAYER_HITBOX_SHRINK_Y * playerRect.height;

            const playerCollision = {
                x: playerRect.left + playerHitboxShrinkAmountX,
                y: playerRect.top + playerHitboxShrinkAmountY,
                width: playerRect.width - (2 * playerHitboxShrinkAmountX),
                height: playerRect.height - (2 * playerHitboxShrinkAmountY)
            };

            for (let i = 0; i < window.obstacles.length; i++) { 
                const obstacle = window.obstacles[i]; 
                
                // Calculate collision rectangles for top and bottom candles using stored numerical properties
                const topCandleCollision = {
                    x: obstacle.x,
                    y: 0,
                    width: obstacle.width,
                    height: obstacle.topHeight 
                };

                const bottomCandleCollision = {
                    x: obstacle.x,
                    y: obstacle.gapY + obstacle.gapHeight, 
                    width: obstacle.width,
                    height: obstacle.bottomHeight 
                };

                // Collision with top candle
                if (
                    playerCollision.x < topCandleCollision.x + topCandleCollision.width &&
                    playerCollision.x + playerCollision.width > topCandleCollision.x &&
                    playerCollision.y < topCandleCollision.y + topCandleCollision.height &&
                    playerCollision.y + playerCollision.height > topCandleCollision.y
                ) {
                    console.log("Collision detected with GREEN (TOP) candle!");
                    if (!window.shieldActive) { 
                        endGame(); 
                        return; 
                    }
                }
                // Collision with bottom candle
                if (
                    playerCollision.x < bottomCandleCollision.x + bottomCandleCollision.width &&
                    playerCollision.x + playerCollision.width > bottomCandleCollision.x &&
                    playerCollision.y < bottomCandleCollision.y + bottomCandleCollision.height &&
                    playerCollision.y + playerCollision.height > bottomCandleCollision.y
                ) {
                    console.log("Collision detected with RED (BOTTOM) candle!");
                    if (!window.shieldActive) { 
                        endGame(); 
                        return; 
                    }
                }
            }

            for (let i = 0; i < window.items.length; i++) { 
                const item = window.items[i]; 
                
                // Calculate collision rectangle for item using stored numerical properties
                const itemCollision = {
                    x: item.x,
                    y: item.y,
                    width: item.width,
                    height: item.height
                };

                if (
                    playerCollision.x < itemCollision.x + itemCollision.width &&
                    playerCollision.x + playerCollision.width > itemCollision.x &&
                    playerCollision.y < itemCollision.y + itemCollision.height &&
                    playerCollision.y + playerCollision.height > itemCollision.y
                ) {
                    console.log("Collected item:", item.type);
                    if (item.type === 'potion') {
                        activateShield();
                    } else if (item.type === 'flappy-coin') {
                        window.score++; 
                        updateScoreDisplay(); 
                    }
                    if (gameContainer.contains(item.element)) { 
                        gameContainer.removeChild(item.element);
                    }
                    window.items.splice(i, 1); 
                    i--;
                }
            }
        }

        /**
         * Activates the shield power-up.
         */
        function activateShield() {
            if (window.shieldTimer) clearTimeout(window.shieldTimer); 
            window.shieldActive = true; 
            player.classList.add('shielded');
            powerupStatusDisplay.textContent = "SHIELD ACTIVE!";
            powerupStatusDisplay.style.display = 'block';
            window.shieldTimer = setTimeout(() => { deactivateShield(); }, SHIELD_DURATION); 
        }

        /**
         * Deactivates the shield power-up.
         */
        function deactivateShield() {
            window.shieldActive = false; 
            player.classList.remove('shielded');
            powerupStatusDisplay.style.display = 'none'; 
            if (window.shieldTimer) clearTimeout(window.shieldTimer); 
            window.shieldTimer = null; 
        }

        /**
         * Starts the sprite animation for the player.
         */
        function startSpriteAnimation() {
            if (window.spriteAnimationInterval) clearInterval(window.spriteAnimationInterval); 
            window.spriteAnimationInterval = setInterval(() => { 
                window.currentSpriteFrameIndex = (window.currentSpriteFrameIndex + 1) % PLAYER_SPRITE_FRAME_COUNT; 
                player.style.backgroundPosition = `-${window.currentSpriteFrameIndex * PLAYER_SPRITE_WIDTH}px 0`; 
            }, SPRITE_ANIMATION_SPEED);
        }

        /**
         * Stops the sprite animation and resets to the first frame.
         */
        function stopSpriteAnimation() {
            if (window.spriteAnimationInterval) clearInterval(window.spriteAnimationInterval); 
            window.spriteAnimationInterval = null; 
            player.style.backgroundPosition = `0 0`; 
            player.style.transform = `rotateZ(0deg)`;
        }

        /**
         * Calculates the final score based on Flappy score and Market Cap.
         * @param {number} flappyScore
         * @param {number} marketCap
         * @returns {number} Combined final score.
         */
        function calculateCombinedFinalScore(flappyScore, marketCap) {
            return flappyScore + (marketCap / 1000);
        }
        
        // === Particle System for Welcome/Game Over Screens ===
        function createParticles() {
            particles = []; 
            // Reduce particle count for small mobile if performance is still an issue
            const numParticles = currentConfig === smallMobileConfig ? 40 : 100; // Further reduced for small mobile
            for (let i = 0; i < numParticles; i++) {
                particles.push({
                    x: Math.random() * particleCanvas.width,
                    y: Math.random() * particleCanvas.height,
                    radius: Math.random() * 2 + 1, 
                    color: `hsl(${Math.random() * 360}, 100%, 70%)`, 
                    speedX: (Math.random() - 0.5) * 0.8, 
                    speedY: (Math.random() - 0.5) * 0.8
                });
            }
        }

        function updateParticles() {
            for (let p of particles) {
                p.x += p.speedX;
                p.y += p.speedY;
                if (p.x < 0) p.x = particleCanvas.width;
                if (p.x > particleCanvas.width) p.x = 0;
                if (p.y < 0) p.y = particleCanvas.height;
                if (p.y > particleCanvas.height) p.y = 0;
            }
        }

        function drawParticles() {
            particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height); 
            for (let p of particles) {
                particleCtx.beginPath();
                particleCtx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                particleCtx.fillStyle = p.color;
                particleCtx.fill();
            }
        }

        function particleAnimationLoop() {
            if (deviceSelectionModal.style.display !== 'none' || messageBox.style.display !== 'none' || leaderboardModal.style.display !== 'none' || profileModal.style.display !== 'none') { 
                updateParticles();
                drawParticles();
                particleAnimationFrameId = requestAnimationFrame(particleAnimationLoop);
            } else {
                cancelAnimationFrame(particleAnimationFrameId);
                particleAnimationFrameId = null;
                particleCanvas.style.display = 'none'; 
            }
        }
        // === End Particle System ===

        /**
         * Displays a temporary "FLAPPY SPEED UP!" message.
         */
        function showSpeedUpMessage() {
            speedUpText.classList.add('show');
            setTimeout(() => {
                speedUpText.classList.remove('show');
            }, 1000); // Display for 1 second
        }

        /**
         * Updates the score display on the top bar.
         */
        function updateScoreDisplay() {
            flappyScoreCounter.textContent = window.score;
            playerIcon.style.backgroundImage = `url('${PLAYER_SPRITE_SHEET_URL}')`;
            playerIcon.style.backgroundPosition = `0 0`; 
        }

        /**
         * The main game loop.
         */
        function gameLoop() {
            try {
                if (window.gameOver) { 
                    cancelAnimationFrame(window.animationFrameId); 
                    return;
                }

                window.marketCap += (MARKET_CAP_PER_BASE_CANDLE_WIDTH / currentConfig.CANDLE_WIDTH_BASE) * window.currentObstacleSpeed; 
                marketCapDisplay.textContent = `MC: ${formatCurrency(window.marketCap)}`; 

                // Check if market cap has increased enough to boost speed
                if (window.marketCap >= window.lastMarketCapSpeedMilestone + currentConfig.SPEED_INCREASE_MILESTONE_MC_INCREMENT) { 
                    window.currentObstacleSpeed += 0.3; 
                    window.lastMarketCapSpeedMilestone += currentConfig.SPEED_INCREASE_MILESTONE_MC_INCREMENT; 
                    console.log(`Speed increased to ${window.currentObstacleSpeed.toFixed(2)}. Next speed milestone at MC: ${formatCurrency(window.lastMarketCapSpeedMilestone + currentConfig.SPEED_INCREASE_MILESTONE_MC_INCREMENT)}`);
                    showSpeedUpMessage(); // Show the speed up animation
                }

                updatePlayer();
                updateObstaclesAndItems();
                checkCollisions();

                window.animationFrameId = requestAnimationFrame(gameLoop); 
            } catch (error) {
                console.error("Error in gameLoop:", error);
                // Optionally end game or show an error message to the user
                if (!window.gameOver) {
                    alert("A game error occurred. Please check the console for details. Ending game.");
                    endGame();
                }
            }
        }

        /**
         * Initiates the 'flap' action. Includes audio cooldown.
         */
        function flap() {
            if (flapSynth && Tone.context.state === 'running' && (Date.now() - window.lastFlapSoundTime >= FLAP_SOUND_COOLDOWN)) { 
                flapSynth.triggerAttackRelease("C4", "8n"); 
                window.lastFlapSoundTime = Date.now(); 
            }
            
            // Only flap if the game has started
            if (window.gameStarted && !window.gameOver) { 
                window.playerVelocity = PLAYER_FLAP_STRENGTH; 
            }
            if (Tone.context.state === 'suspended') {
                 Tone.start().then(() => {
                 }).catch(e => console.error("Failed to resume Tone.context on flap:", e));
            }
        }

        /**
         * Resets game state and starts the game.
         */
        function startGame() {
            if (window.isStartingGame && window.gameStarted) { 
                return; 
            }

            window.isStartingGame = true; 
            window.gameStarted = true; 
            window.gameOver = false; 
            window.score = 0; 
            updateScoreDisplay(); 
            window.marketCap = INITIAL_MARKET_CAP; 
            window.lastMarketCapSpeedMilestone = INITIAL_MARKET_CAP; // Reset milestone on new game
            marketCapDisplay.textContent = `MC: ${formatCurrency(window.marketCap)}`; 
            
            calculateGameDimensions(); // Recalculate dimensions based on currentConfig

            // Reset lastGapY when starting a new game for consistent initial obstacle placement
            window.lastGapY = GAME_HEIGHT / 2; // Center of screen for first gap

            window.playerY = (GAME_HEIGHT / 2) - (player.offsetHeight / 2);
            player.style.top = `${window.playerY}px`; 
            player.style.left = `${(GAME_WIDTH / 2) - (player.offsetWidth / 2)}px`;

            window.playerVelocity = 0; 

            deactivateShield();
            powerupStatusDisplay.style.display = 'none';

            window.obstacles.forEach(o => { 
                if (gameContainer.contains(o.greenElement)) gameContainer.removeChild(o.greenElement); 
                if (gameContainer.contains(o.redElement)) gameContainer.removeChild(o.redElement); 
            });
            window.obstacles = []; 
            window.items.forEach(item => { 
                if (gameContainer.contains(item.element)) gameContainer.removeChild(item.element);
            });
            window.items = []; 

            messageBox.style.display = 'none'; 
            deviceSelectionModal.style.display = 'none'; // Hide device selection
            leaderboardModal.style.display = 'none'; 
            profileModal.style.display = 'none'; 
            particleCanvas.style.display = 'none'; 
            if (particleAnimationFrameId) cancelAnimationFrame(particleAnimationFrameId); 

            // Hide PROFILE and LOGOUT buttons during game
            userInfoDisplay.classList.add('in-game');
            userInfoDisplay.classList.add('in-game-over'); 

            window.lastObstacleTime = Date.now(); 
            
            initAudio().then(() => { 
                gameLoop(); 
                startSpriteAnimation();
                window.isStartingGame = false; 
            }).catch(e => {
                console.error("Failed to ensure audio started on game start:", e);
                window.isStartingGame = false; 
            });
        }

        /**
         * Ends the game and displays game over message.
         */
        async function endGame() {
            if (window.gameOver) { 
                return; 
            }

            window.gameOver = true; 
            window.gameStarted = false; 
            cancelAnimationFrame(window.animationFrameId); 
            stopSpriteAnimation();
            deactivateShield();

            if (flapSynth) { 
                flapSynth.dispose(); 
                flapSynth = null; 
            }

            const finalCombinedScore = calculateCombinedFinalScore(window.score, window.marketCap); 
            
            messageTitle.textContent = "üíÄ ùóöùóîùó†ùóò ÔøΩùó©ùóòùó•!"; 
            messageText.innerHTML = `
                ü™ô Your $FLAPPY: ${window.score}<br>
                üìä Final Market Cap: ${formatCurrency(window.marketCap)}<br><br>
                üí• Combined Score: <b>${finalCombinedScore.toFixed(0)}</b><br>
            `;
            
            // Save high score to Supabase if logged in
            if (isLoggedIn && currentUser && currentUser.id) {
                showLoading("Saving high score...");
                const roundedMarketCap = Math.round(window.marketCap); 
                const formattedCombinedScore = finalCombinedScore.toFixed(0);

                // 1. Fetch existing high score for the user
                const { data: existingHighScore, error: fetchError } = await supabase
                    .from('high_scores') // Query the new high_scores table
                    .select('combined_score')
                    .eq('user_id', currentUser.id)
                    .single();

                if (fetchError && fetchError.code !== 'PGRST116') { // PGRST116 means no row found
                    console.error("Error fetching existing high score:", fetchError);
                    messageText.innerHTML += `<br><span style="color:red;">Error checking high score: ${fetchError.message}</span>`;
                } else {
                    // 2. Compare and decide whether to upsert
                    let shouldSaveNewScore = false;
                    if (!existingHighScore) {
                        shouldSaveNewScore = true; // No existing high score, so save this one
                        console.log("No existing high score found, will save new one.");
                    } else if (parseInt(formattedCombinedScore) > existingHighScore.combined_score) {
                        shouldSaveNewScore = true; // New score is higher, so save it
                        console.log(`New score ${formattedCombinedScore} is higher than existing ${existingHighScore.combined_score}, will update.`);
                    } else {
                        console.log(`New score ${formattedCombinedScore} is not higher than existing ${existingHighScore.combined_score}, will not save.`);
                    }

                    if (shouldSaveNewScore) {
                        const { error: upsertError } = await supabase
                            .from('high_scores') // Upsert into high_scores table
                            .upsert([
                                { 
                                    user_id: currentUser.id, 
                                    score: window.score, 
                                    market_cap: roundedMarketCap, 
                                    combined_score: formattedCombinedScore 
                                }
                            ], { onConflict: 'user_id' }); // Use user_id for conflict resolution

                        if (upsertError) {
                            console.error("Error saving high score:", upsertError);
                            messageText.innerHTML += `<br><span style="color:red;">Error saving high score: ${upsertError.message}</span>`;
                        } else {
                            messageText.innerHTML += `<br><span style="color:lime;">High Score saved!</span>`;
                            await displayLeaderboard(); // Refresh leaderboard after a successful save
                        }
                    } else {
                         messageText.innerHTML += `<br><span style="color:orange;">Your score (${formattedCombinedScore}) was not a new high score.</span>`;
                         await displayLeaderboard(); // Still refresh just in case
                    }
                }
                hideLoading();
            } else {
                messageText.innerHTML += `<br>Sign in to save your score and appear on the leaderboard!`;
            }

            signInEmailLinkButton.textContent = "üìß SIGN IN"; 
            startButton.textContent = "üïπÔ∏è PLAY AGAIN"; 
            leaderboardButton.textContent = "üèÜ LEADERBOARD"; 
            backToWelcomeButton.textContent = "üîô BACK TO WELCOME"; 

            showWelcomeScreen(true); // Call updated function
        }

        /**
         * Fetches user profile from Supabase.
         * @param {string} userId - The ID of the user.
         * @returns {Promise<object|null>} The user's profile data or null if not found/error.
         */
        async function fetchUserProfile(userId) {
            showLoading("Fetching profile...");
            const { data, error } = await supabase
                .from('profiles')
                .select('*')
                .eq('id', userId)
                .single();
            hideLoading();
            if (error && error.code !== 'PGRST116') { // PGRST116 means no row found, which is fine
                console.error("Error fetching profile:", error);
                return null;
            }
            return data;
        }

        /**
         * Upserts user profile in Supabase.
         * @param {object} profileData - Data to insert/update.
         */
        async function upsertUserProfile(profileData) {
            showLoading("Updating profile...");
            const { error } = await supabase
                .from('profiles')
                .upsert(profileData, { onConflict: 'id' });
            hideLoading();
            if (error) {
                console.error("Error upserting profile:", error);
                alert("Error updating profile: " + error.message);
                return false;
            }
            return true;
        }

        /**
         * Updates the user's X (Twitter) account name.
         * @param {string} xAccountName - The new X account name.
         */
        async function updateXAccountName(xAccountName) {
            if (!currentUser) {
                alert("You must be logged in to update your X account name.");
                return;
            }

            showLoading("Updating X handle...");
            // Supabase auth.updateUser can directly update 'user_metadata'
            const { data: updatedUser, error: updateError } = await supabase.auth.updateUser({
                data: { x_account_name: xAccountName }
            });
            hideLoading();

            if (updateError) {
                console.error("Error updating user metadata:", updateError);
                alert("Error updating X handle: " + updateError.message);
                return;
            }

            // Also update the public profiles table for leaderboard display
            const success = await upsertUserProfile({ 
                id: currentUser.id, 
                email: currentUser.email, // Keep email updated in profiles table
                x_account_name: xAccountName 
            });

            if (success) {
                currentProfile = { ...currentProfile, x_account_name: xAccountName };
                profileXAccountDisplay.textContent = `X Handle: ${xAccountName}`;
                updateAuthUI(); // Refresh UI after update
                alert("X (Twitter) handle updated successfully!");
            }
        }

        /**
         * Formats the player's name for display on the leaderboard.
         * Prioritizes X handle, otherwise masks email.
         * @param {object} profile - The user's profile object.
         * @returns {string} Formatted player name.
         */
        function formatPlayerName(profile) {
            if (profile && profile.x_account_name) {
                return profile.x_account_name;
            }
            if (profile && profile.email) {
                const parts = profile.email.split('@');
                if (parts.length === 2) {
                    const localPart = parts[0];
                    const domainPart = parts[1];
                    const maskedLocal = localPart.substring(0, Math.min(3, localPart.length)) + '***';
                    return `${maskedLocal}@${domainPart}`;
                }
            }
            return 'Unknown Player';
        }

        /**
         * Fetches and displays the leaderboard.
         */
        async function displayLeaderboard() {
            showLoading("Fetching leaderboard...");
            const { data, error } = await supabase
                .from('high_scores') // Query the high_scores table
                .select(`
                    combined_score,
                    score,        
                    market_cap,   
                    profiles (
                        x_account_name,
                        email,
                        id
                    )
                `)
                .order('combined_score', { ascending: false })
                .limit(10); // Still showing top 10, will highlight top 3 visually
            hideLoading();

            if (error) {
                console.error("Error fetching leaderboard:", error);
                leaderboardTableBody.innerHTML = `<tr><td colspan="5">Error loading leaderboard: ${error.message}</td></tr>`;
                return;
            }

            leaderboardTableBody.innerHTML = ''; // Clear previous list

            if (data.length === 0) {
                leaderboardTableBody.innerHTML = '<tr><td colspan="5">No scores yet! Be the first to play.</td></tr>';
                return;
            }

            data.forEach((entry, index) => {
                const tr = document.createElement('tr');
                const rank = index + 1;
                const username = formatPlayerName(entry.profiles);
                
                tr.innerHTML = `
                    <td>#${rank}</td>
                    <td>${username}</td>
                    <td>${entry.score}</td>
                    <td>${formatCurrency(entry.market_cap)}</td>
                    <td class="glowing-score">${entry.combined_score}</td>
                `;
                if (currentUser && entry.profiles && entry.profiles.id === currentUser.id) { 
                    tr.classList.add('current-user');
                }
                if (rank <= 3) {
                    tr.classList.add('top-3');
                }
                leaderboardTableBody.appendChild(tr);
            });
            leaderboardModal.style.display = 'flex';
        }

        /**
         * Calculates and displays the current user's rank.
         */
        async function displayUserRank() {
            if (!currentUser) {
                profileRankDisplay.textContent = 'Rank: N/A (Sign in to see)';
                return;
            }

            showLoading("Calculating rank...");
            // Get the user's highest score
            const { data: userScores, error: userScoresError } = await supabase
                .from('high_scores') // Query high_scores for user's best
                .select('combined_score')
                .eq('user_id', currentUser.id)
                .order('combined_score', { ascending: false })
                .limit(1)
                .single();
            
            if (userScoresError && userScoresError.code !== 'PGRST116') {
                console.error("Error fetching user's highest score:", userScoresError);
                profileRankDisplay.textContent = 'Rank: Error loading';
                hideLoading();
                return;
            }

            if (!userScores) {
                profileRankDisplay.textContent = 'Rank: No scores yet';
                hideLoading();
                return;
            }

            const userHighestScore = userScores.combined_score;

            // Count how many scores are greater than or equal to the user's score from high_scores
            const { count, error: countError } = await supabase
                .from('high_scores')
                .select('id', { count: 'exact' })
                .gte('combined_score', userHighestScore); 

            hideLoading();

            if (countError) {
                console.error("Error counting scores for rank:", countError);
                profileRankDisplay.textContent = 'Rank: Error loading';
                return;
            }

            // The rank is the count of scores that are equal to or higher than the user's score
            profileRankDisplay.textContent = `Rank: ${count}`;
        }


        /**
         * Handles the sign-in with email magic link process.
         */
        async function handleSignInWithEmailLink() {
            const email = emailInput.value.trim();
            if (!email) {
                alert("Please enter your email address.");
                return;
            }

            showLoading("Sending magic link...");
            const { error } = await supabase.auth.signInWithOtp({
                email: email,
                options: {
                    emailRedirectTo: window.location.origin // Redirect back to this page
                }
            });
            hideLoading();

            if (error) {
                console.error("Error sending magic link:", error);
                alert("Error sending magic link: " + error.message);
            } else {
                alert("Magic link sent to your email! Check your inbox to sign in.");
                messageText.textContent = `Magic link sent to ${email}. Check your inbox!`;
                emailInput.value = ''; // Clear input
                emailInput.classList.add('hidden');
                xAccountNameInput.classList.add('hidden');
                authButtonsDiv.classList.add('hidden');
                startButton.classList.remove('hidden'); // Allow playing as guest
                leaderboardButton.classList.remove('hidden');
                startButton.textContent = "üïπÔ∏è START GAME (GUEST)";
            }
        }

        /**
         * Verifies the email magic link upon redirect.
         * This function should be called explicitly on page load if the URL contains magic link parameters.
         */
        async function verifyEmailLink() {
            showLoading("Verifying magic link...");
            // supabase.auth.getSession() automatically parses the URL for magic link tokens
            const { data, error } = await supabase.auth.getSession();
            hideLoading();
            if (error) {
                console.error("Error verifying session from magic link:", error);
                // Even on error, onAuthStateChange will eventually be called with a null session
            } else if (data.session) {
                console.log("Session established after magic link:", data.session);
                // onAuthStateChange will handle updating UI and state
            }
        }

        /**
         * Handles user logout.
         */
        async function handleLogout() {
            showLoading("Logging out...");
            const { error } = await supabase.auth.signOut();
            hideLoading();
            if (error) {
                console.error("Error logging out:", error);
                alert("Error logging out: " + error.message);
            } else {
                currentUser = null;
                isLoggedIn = false;
                currentProfile = null;
                updateAuthUI();
                // After logout, always show the device selection if no preference is explicitly saved
                const preferredDevice = localStorage.getItem('cryptoFlapDevice');
                if (!preferredDevice) { // If no preference, show device selection
                    showDeviceSelection(); 
                } else { // If a preference exists, go to welcome with that preference
                    showWelcomeScreen(false); 
                }
                alert("Logged out successfully!");
            }
        }

        /**
         * Updates the visibility and content of UI elements based on authentication state.
         */
        function updateAuthUI() {
            if (isLoggedIn && currentUser) {
                userNameDisplay.textContent = formatPlayerName(currentProfile);
                userInfoDisplay.style.display = 'flex'; // Ensure user info is shown when logged in
                profileButton.style.display = 'inline-block';
                deviceButton.style.display = 'inline-block'; // Show device button
                logoutButton.style.display = 'inline-block';
                signInEmailLinkButton.classList.add('hidden'); 
                registerButton.classList.add('hidden');
                startButton.textContent = "üïπÔ∏è START GAME"; 
                emailInput.classList.add('hidden');
                xAccountNameInput.classList.add('hidden');
                authButtonsDiv.classList.add('hidden');

                profileEmailDisplay.textContent = `Email: ${currentUser.email}`;
                profileXAccountDisplay.textContent = `X Handle: ${currentProfile ? (currentProfile.x_account_name || 'Not set') : 'Not set'}`;
                profileXAccountNameInput.value = currentProfile && currentProfile.x_account_name ? currentProfile.x_account_name : '';
                profileSignInEmailLinkButton.classList.add('hidden'); // Hide in profile if logged in
                profileLogoutButton.classList.remove('hidden'); // Show in profile if logged in

            } else {
                userNameDisplay.textContent = 'Guest';
                userInfoDisplay.style.display = 'none'; // Ensure user info is hidden when logged out unless on welcome screen
                profileButton.style.display = 'none';
                deviceButton.style.display = 'none'; // Hide device button
                logoutButton.style.display = 'none';
                signInEmailLinkButton.classList.remove('hidden'); 
                registerButton.classList.add('hidden'); 
                startButton.textContent = "üïπÔ∏è START GAME (GUEST)";
                emailInput.classList.remove('hidden');
                xAccountNameInput.classList.remove('hidden');
                authButtonsDiv.classList.remove('hidden');

                profileEmailDisplay.textContent = 'Email: Not logged in';
                profileXAccountDisplay.textContent = 'X Handle: Not set';
                profileXAccountNameInput.value = '';
                profileRankDisplay.textContent = 'Rank: Not available'; // Reset rank
            }
        }

        /**
         * Shows the main welcome/auth screen.
         * @param {boolean} isGameOver - True if showing after game over.
         */
        function showWelcomeScreen(isGameOver = false) { 
            deviceSelectionModal.style.display = 'none'; // Ensure device selection is hidden
            messageBox.style.display = 'block'; 
            particleCanvas.style.display = 'block'; 
            if (!particleAnimationFrameId) { 
                createParticles(); 
                particleAnimationLoop(); 
            }
            
            if (isGameOver) {
                userInfoDisplay.classList.add('in-game-over'); 
                userInfoDisplay.classList.remove('in-game'); 
                backToWelcomeButton.classList.remove('hidden'); 
            } else {
                userInfoDisplay.classList.remove('in-game'); 
                userInfoDisplay.classList.remove('in-game-over'); 
                // Only show userInfoDisplay if user is logged in, otherwise it's handled by showAuthScreen/showDeviceSelection
                if (isLoggedIn) {
                    userInfoDisplay.style.display = 'flex'; 
                } else {
                    userInfoDisplay.style.display = 'none'; // Keep hidden on welcome for guests initially
                }
                backToWelcomeButton.classList.add('hidden'); 
            }

            startButton.classList.remove('hidden');
            leaderboardButton.classList.remove('hidden');

            xAccountNameInput.classList.add('hidden');

            if (!isLoggedIn) {
                emailInput.classList.remove('hidden');
                authButtonsDiv.classList.remove('hidden');
                signInEmailLinkButton.classList.remove('hidden');
                registerButton.classList.add('hidden'); 
            } else {
                emailInput.classList.add('hidden');
                authButtonsDiv.classList.add('hidden');
                signInEmailLinkButton.classList.add('hidden');
                registerButton.classList.add('hidden');
            }

            if (!isGameOver) {
                messageTitle.textContent = "üöÄ Welcome to ùóñùó•ùó¨ùó£ùóßùó¢ ùóôùóüùóîùó£!"; 
                messageText.innerHTML = "‚õèÔ∏è Flap through green candles, dodge the red ones.<br>üí∏ Stack up your $FLAPPY and fly to crypto glory!<br><br>Sign in to save your scores!"; 
            } 
        }

        /**
         * Shows the initial device selection modal.
         */
        function showDeviceSelection() {
            deviceSelectionModal.style.display = 'flex';
            messageBox.style.display = 'none';
            leaderboardModal.style.display = 'none';
            profileModal.style.display = 'none';
            // Show userInfo if logged in and accessing via device button
            if (isLoggedIn) { 
                userInfoDisplay.style.display = 'flex'; 
            } else {
                userInfoDisplay.style.display = 'none'; 
            }
            
            particleCanvas.style.display = 'block'; 
            if (!particleAnimationFrameId) { 
                createParticles(); 
                particleAnimationLoop(); 
            }
        }

        /**
         * Sets the current game configuration based on the selected device.
         * @param {string} deviceType - 'laptop', 'smallMobile', or 'largeMobile'.
         */
        function setDeviceConfig(deviceType) {
            switch (deviceType) {
                case 'laptop':
                    currentConfig = laptopConfig;
                    break;
                case 'smallMobile':
                    currentConfig = smallMobileConfig;
                    break;
                case 'largeMobile':
                    currentConfig = largeMobileConfig;
                    break;
                default:
                    console.warn("Unknown device type, defaulting to laptop config.");
                    currentConfig = laptopConfig;
            }
            localStorage.setItem('cryptoFlapDevice', deviceType);
            calculateGameDimensions(); // Apply the new configuration
            console.log(`Device config set to ${deviceType} (via selection or auto-detect)`);
        }


        // --- Event Listeners ---

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                // Allow flap only if not in a modal and not already in game
                // AND the message box is NOT visible (meaning game is active OR about to start from Start button)
                if (window.gameStarted && !window.gameOver) { 
                    flap(); 
                }
            }
        });

        gameContainer.addEventListener('click', async (e) => {
            // Check if the click target is a button inside any modal or userInfo buttons.
            const isAnyModalButton = e.target.closest('#messageBox button') || 
                                     e.target.closest('.leaderboard-modal button') || 
                                     e.target.closest('.profile-modal button') ||
                                     e.target.closest('#deviceSelectionModal button'); 
            const isUserInfoButton = e.target.closest('#userInfo button');
            const isInput = e.target.closest('input'); 

            // If an input field is clicked, do nothing to prevent unintended game starts or flaps.
            if (isInput) {
                return;
            }

            if (isAnyModalButton || isUserInfoButton) {
                e.stopPropagation(); // Prevent this click from bubbling up to the gameContainer's general handler

                if (e.target.closest('#playOnLaptopButton')) { 
                    setDeviceConfig('laptop');
                    showWelcomeScreen(false); 
                } else if (e.target.closest('#playOnLargeMobileButton')) { 
                    setDeviceConfig('largeMobile');
                    showWelcomeScreen(false); 
                } else if (e.target.closest('#playOnSmallMobileButton')) { 
                    setDeviceConfig('smallMobile');
                    showWelcomeScreen(false); 
                } else if (e.target.closest('#signInEmailLinkButton')) {
                    await handleSignInWithEmailLink();
                } else if (e.target.closest('#startButton')) { 
                    startGame();
                } else if (e.target.closest('#leaderboardButton')) {
                    await displayLeaderboard();
                } else if (e.target.closest('#leaderboardCloseButton')) {
                    leaderboardModal.style.display = 'none';
                    if (window.gameOver) {
                        showWelcomeScreen(true); 
                    } else {
                        showWelcomeScreen(false); 
                    }
                } else if (e.target.closest('#profileButton')) { 
                    profileModal.style.display = 'flex';
                    if (currentUser) {
                        currentProfile = await fetchUserProfile(currentUser.id); 
                        profileEmailDisplay.textContent = `Email: ${currentUser.email}`;
                        profileXAccountDisplay.textContent = `X Handle: ${currentProfile ? (currentProfile.x_account_name || 'Not set') : 'Not set'}`;
                        profileXAccountNameInput.value = currentProfile && currentProfile.x_account_name ? currentProfile.x_account_name : '';
                        await displayUserRank(); // Fetch and display rank
                    } else {
                        profileEmailDisplay.textContent = 'Email: Not logged in';
                        profileXAccountDisplay.textContent = 'X Handle: Not set';
                        profileXAccountNameInput.value = '';
                        profileRankDisplay.textContent = 'Rank: N/A (Sign in to see)';
                    }
                    updateAuthUI(); 
                } else if (e.target.closest('#profileSetXAccountNameButton')) {
                    const newXAccountName = profileXAccountNameInput.value.trim();
                    await updateXAccountName(newXAccountName);
                } else if (e.target.closest('#profileSignInEmailLinkButton')) { 
                    alert("Please use the main screen's 'Sign In with Email Link' feature or refresh the page to sign in.");
                } else if (e.target.closest('#profileLogoutButton')) { 
                    await handleLogout();
                }
                else if (e.target.closest('#profileCloseButton')) { 
                    profileModal.style.display = 'none';
                    if (window.gameOver) {
                        showWelcomeScreen(true); 
                    } else {
                        showWelcomeScreen(false); 
                    }
                } else if (e.target.closest('#backToWelcomeButton')) { 
                    showWelcomeScreen(false); 
                } else if (e.target.closest('#logoutButton')) { 
                    await handleLogout();
                } else if (e.target.closest('#deviceButton')) { // Handle new Device button
                    showDeviceSelection();
                }
            } else { 
                // This is a click on the game container itself, outside of specific buttons/modals
                // Only flap if the game is currently running
                if (window.gameStarted && !window.gameOver) { 
                    flap();
                }
            }
        }, { passive: false }); 

        // Named function for window.onload
        async function initializeGame() {
            // 1. Determine initial device config
            const preferredDevice = localStorage.getItem('cryptoFlapDevice');
            if (preferredDevice) {
                setDeviceConfig(preferredDevice); // Use saved preference
            } else {
                // Auto-detect and apply, but don't save. If mobile, will show selection.
                const isMobileAuto = /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (window.innerWidth <= 768 && window.innerHeight <= 1024);
                if (isMobileAuto) {
                    currentConfig = largeMobileConfig; // Default mobile to large, then offer choice
                    console.log("Auto-detected MOBILE, defaulting to largeMobileConfig for initial setup.");
                } else {
                    currentConfig = laptopConfig;
                    console.log("Auto-detected LAPTOP, applying laptopConfig.");
                }
                calculateGameDimensions(); // Apply this initial config
            }
            
            // Initial player size setup (will be refined by calculateGameDimensions)
            player.style.width = `${PLAYER_SPRITE_WIDTH}px`;
            player.style.height = `${PLAYER_SPRITE_HEIGHT}px`;
            updatePlayerSize();
            // Player Y is calculated in calculateGameDimensions based on its dimensions, if valid.
            // Only explicitly set here if calculateGameDimensions returned early due to zero dimensions.
            if (window.innerWidth === 0 || window.innerHeight === 0) {
                 window.playerY = (GAME_HEIGHT / 2) - (player.offsetHeight / 2);
                 player.style.top = `${window.playerY}px`; 
                 player.style.left = `${(GAME_WIDTH / 2) - (player.offsetWidth / 2)}px`;
            }
            player.style.transform = `rotateZ(0deg)`;
            marketCapDisplay.textContent = `MC: ${formatCurrency(INITIAL_MARKET_CAP)}`;
            updateScoreDisplay();
            
            // This listener will fire immediately on page load with the current session status
            // and whenever the auth state changes (login, logout, token refresh).
            window.supabase.auth.onAuthStateChange(async (event, session) => {
                console.log("Auth state changed:", event, session);
                if (session) {
                    currentUser = session.user;
                    isLoggedIn = true;
                    currentProfile = await fetchUserProfile(currentUser.id);
                    if (!currentProfile) {
                        // Create profile if it's not present
                        await upsertUserProfile({ id: currentUser.id, email: currentUser.email, x_account_name: null });
                        currentProfile = await fetchUserProfile(currentUser.id); 
                    }
                    updateAuthUI();
                    // After login, show the welcome screen (or game over screen if applicable)
                    showWelcomeScreen(window.gameOver); 
                } else {
                    currentUser = null;
                    isLoggedIn = false;
                    currentProfile = null;
                    updateAuthUI();
                    
                    const savedDevice = localStorage.getItem('cryptoFlapDevice');
                    const isMobileAuto = /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (window.innerWidth <= 768 && window.innerHeight <= 1024);

                    if (!savedDevice && isMobileAuto) { 
                        showDeviceSelection(); // Only show device selection if no saved device AND it's a mobile device
                    } else {
                        showWelcomeScreen(false); // Otherwise, go straight to welcome screen
                    }
                }
            });

            // Handle magic link redirect. This will cause onAuthStateChange to fire.
            const params = new URLSearchParams(window.location.search);
            if (params.has('type') && params.get('type') === 'magiclink') {
                await verifyEmailLink(); // This will trigger onAuthStateChange to update the session
            } else {
                // For initial page loads not originating from a magic link,
                // onAuthStateChange will still fire immediately with the existing session or null,
                // determining the initial display. No extra logic needed here.
            }
        }

        // Assign the named function to window.onload
        window.onload = initializeGame;


        document.addEventListener('touchstart', (e) => {
            // Prevent default touch behavior only if not interacting with a button or input
            if (e.target.closest('button') || e.target.closest('input')) {
            } else {
                e.preventDefault(); 
                // Only flap if the game is currently running
                if (window.gameStarted && !window.gameOver) { 
                    flap(); 
                }
            }
        }, { passive: false });

        window.addEventListener('resize', () => {
            calculateGameDimensions(); 

            if (!window.gameStarted || window.gameOver) { 
                window.playerY = (GAME_HEIGHT / 2) - (player.offsetHeight / 2);
                player.style.top = `${window.playerY}px`; 
                player.style.left = `${(GAME_WIDTH / 2) - (player.offsetWidth / 2)}px`;
            }
            // Ensure modals are centered on resize
            document.querySelectorAll('.message-box, .device-selection-modal, .leaderboard-modal, .profile-modal').forEach(modal => {
                modal.style.top = '50%';
                modal.style.left = '50%';
                modal.style.transform = 'translate(-50%, -50%)';
            });
        });
    </script>
</body>
</html>
