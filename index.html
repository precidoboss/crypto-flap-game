<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate DEX Simulator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }
        .container {
            background-color: rgba(26, 33, 46, 0.9); /* Slightly transparent dark background */
            border: 1px solid rgba(49, 61, 88, 0.5);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            max-width: 1200px; /* Increased max-width for more content */
            width: 100%;
            border-radius: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 10;
        }
        .tab-button {
            padding: 12px 24px;
            font-weight: 600;
            border-radius: 10px;
            transition: all 0.3s ease;
            cursor: pointer;
            background-color: transparent;
            color: #9ca3af;
        }
        .tab-button.active {
            background: linear-gradient(45deg, #6366f1, #8b5cf6);
            color: #ffffff;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }
        .input-group {
            background-color: #2c3e50;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid #3d5a80;
            transition: border-color 0.3s ease;
        }
        .input-group:focus-within {
            border-color: #6366f1;
        }
        .input-group input {
            background: none;
            border: none;
            outline: none;
            color: #e0e0e0;
            font-size: 1.25rem;
            flex-grow: 1;
        }
        .input-group select {
            background-color: #3d5a80;
            color: #e0e0e0;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            outline: none;
        }
        .action-button {
            background: linear-gradient(90deg, #6366f1, #8b5cf6);
            color: white;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 1.25rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            box-shadow: 0 5px 20px rgba(99, 102, 241, 0.4);
            position: relative;
            overflow: hidden;
        }
        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(99, 102, 241, 0.6);
        }
        .action-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(99, 102, 241, 0.3);
        }
        .action-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300%;
            height: 300%;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            transition: all 0.75s ease-out;
            transform: translate(-50%, -50%) scale(0);
            opacity: 0;
        }
        .action-button:hover::before {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }

        .balance-item, .pool-item, .portfolio-item, .proposal-item, .genesis-pool-item, .launch-pool-item, .token-info-item, .dashboard-item, .staking-pool-item, .short-it-item, .nft-item {
            background-color: #2c3e50;
            padding: 10px 15px;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #3d5a80;
        }
        .proposal-item, .genesis-pool-item, .launch-pool-item, .token-info-item, .dashboard-item, .staking-pool-item, .short-it-item, .nft-item {
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
        }
        .proposal-item .vote-buttons button {
            padding: 8px 15px;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        .proposal-item .vote-buttons .vote-yes {
            background-color: #10b981; /* Green */
            color: white;
        }
        .proposal-item .vote-buttons .vote-no {
            background-color: #ef4444; /* Red */
            color: white;
        }
        .proposal-item .vote-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }


        .transaction-status {
            background-color: #2c3e50;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #3d5a80;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-style: italic;
            color: #9ca3af;
            position: relative; /* For slingshot animation */
            overflow: hidden; /* For slingshot animation */
        }

        .threejs-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5; /* Behind the main UI */
            pointer-events: none; /* Allow clicks to pass through to UI */
        }

        /* Animation for transaction success */
        @keyframes burst-effect {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        .burst-animation {
            animation: burst-effect 0.8s ease-out forwards;
        }

        /* Loading spinner */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #8b5cf6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Custom scrollbar for transaction history */
        .transaction-history-scroll, .pool-list-scroll, .proposals-list-scroll, .genesis-pools-scroll, .launch-pools-scroll, .token-list-scroll, .staking-pools-scroll, .short-it-history-scroll, .nft-list-scroll, .nft-marketplace-scroll, .nft-staking-scroll {
            max-height: 200px; /* Adjust as needed */
            overflow-y: auto;
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: #6366f1 #2c3e50; /* Firefox */
        }

        .transaction-history-scroll::-webkit-scrollbar, .pool-list-scroll::-webkit-scrollbar, .proposals-list-scroll::-webkit-scrollbar, .genesis-pools-scroll::-webkit-scrollbar, .launch-pools-scroll::-webkit-scrollbar, .token-list-scroll::-webkit-scrollbar, .staking-pools-scroll::-webkit-scrollbar, .short-it-history-scroll::-webkit-scrollbar, .nft-list-scroll::-webkit-scrollbar, .nft-marketplace-scroll::-webkit-scrollbar, .nft-staking-scroll::-webkit-scrollbar {
            width: 8px;
        }

        .transaction-history-scroll::-webkit-scrollbar-track, .pool-list-scroll::-webkit-scrollbar-track, .proposals-list-scroll::-webkit-scrollbar-track, .genesis-pools-scroll::-webkit-scrollbar-track, .launch-pools-scroll::-webkit-scrollbar-track, .token-list-scroll::-webkit-scrollbar-track, .staking-pools-scroll::-webkit-scrollbar-track, .short-it-history-scroll::-webkit-scrollbar-track, .nft-list-scroll::-webkit-scrollbar-track, .nft-marketplace-scroll::-webkit-scrollbar-track, .nft-staking-scroll::-webkit-scrollbar-track {
            background: #2c3e50;
            border-radius: 10px;
        }

        .transaction-history-scroll::-webkit-scrollbar-thumb, .pool-list-scroll::-webkit-scrollbar-thumb, .proposals-list-scroll::-webkit-scrollbar-thumb, .genesis-pools-scroll::-webkit-scrollbar-thumb, .launch-pools-scroll::-webkit-scrollbar-thumb, .token-list-scroll::-webkit-scrollbar-thumb, .staking-pools-scroll::-webkit-scrollbar-thumb, .short-it-history-scroll::-webkit-scrollbar-thumb, .nft-list-scroll::-webkit-scrollbar-thumb, .nft-marketplace-scroll::-webkit-scrollbar-thumb, .nft-staking-scroll::-webkit-scrollbar-thumb {
            background-color: #6366f1;
            border-radius: 10px;
            border: 2px solid #2c3e50;
        }

        /* Slingshot Animation */
        .slingshot-animation {
            position: absolute;
            width: 30px;
            height: 30px;
            background: linear-gradient(45deg, #8b5cf6, #ec4899);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            animation: slingshot 1s ease-out forwards;
        }

        @keyframes slingshot {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            20% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translate(calc(var(--target-x) - 50%), calc(var(--target-y) - 50%)) scale(0);
                opacity: 0;
            }
        }
        /* Basic Chart Styling */
        .chart-container {
            width: 100%;
            height: 150px;
            background-color: #1e2a3b;
            border-radius: 8px;
            padding: 10px;
            position: relative;
            overflow: hidden;
        }
        .chart-line {
            position: absolute;
            bottom: 10px; /* Offset from bottom padding */
            left: 10px; /* Offset from left padding */
            height: calc(100% - 20px); /* Height minus top/bottom padding */
            width: calc(100% - 20px); /* Width minus left/right padding */
            border-left: 1px solid rgba(255, 255, 255, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        .chart-point {
            position: absolute;
            width: 6px;
            height: 6px;
            background-color: #6366f1;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
        }
        .chart-gradient {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to top, rgba(99, 102, 241, 0.3), rgba(99, 102, 241, 0));
            z-index: 1;
        }
        .max-button {
            background-color: #4a5568;
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .max-button:hover {
            background-color: #6366f1;
        }
        .max-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .short-it-chart-container {
            width: 100%;
            height: 100px;
            background-color: #1e2a3b;
            border-radius: 8px;
            padding: 5px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: flex-end; /* Align bars to the bottom */
        }
        .short-it-chart-bar {
            width: 5px; /* Width of each bar */
            margin: 0 1px; /* Space between bars */
            background-color: #6366f1; /* Default color */
            transition: height 0.1s linear, background-color 0.1s linear;
            position: relative;
            bottom: 0;
        }
        .short-it-chart-bar.up {
            background-color: #10b981; /* Green for up */
        }
        .short-it-chart-bar.down {
            background-color: #ef4444; /* Red for down */
        }
        .nft-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }
        .nft-card {
            background-color: #1e2a3b;
            border-radius: 8px;
            padding: 8px;
            text-align: center;
            font-size: 0.8rem;
        }
        .nft-card img {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 4px;
            margin-bottom: 5px;
        }
        .nft-trait {
            font-weight: 600;
            color: #a78bfa;
        }
    </style>
</head>
<body>
    <canvas id="threejs-canvas" class="threejs-canvas"></canvas>

    <div class="container">
        <!-- Header -->
        <div class="p-6 border-b border-gray-700 flex justify-between items-center">
            <h1 class="text-3xl font-bold text-white">Ultimate DEX Simulator</h1>
            <button id="connect-wallet-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-6 rounded-full transition duration-300 ease-in-out shadow-lg">
                Connect Wallet
            </button>
        </div>

        <!-- Tabs -->
        <div class="flex justify-center p-4 bg-gray-800 rounded-t-xl">
            <button id="swap-tab-btn" class="tab-button active mr-2">Swap</button>
            <button id="bridge-tab-btn" class="tab-button mr-2">Bridge</button>
            <button id="liquidity-tab-btn" class="tab-button mr-2">Liquidity</button>
            <button id="launchpad-tab-btn" class="tab-button mr-2">Launchpad</button>
            <button id="tokens-tab-btn" class="tab-button mr-2">Tokens</button>
            <button id="staking-tab-btn" class="tab-button mr-2">Staking</button>
            <button id="short-it-tab-btn" class="tab-button mr-2">Short It</button>
            <button id="nft-tab-btn" class="tab-button mr-2">NFT</button>
            <button id="governance-tab-btn" class="tab-button mr-2">Governance</button>
            <button id="dashboard-tab-btn" class="tab-button">Dashboard</button>
        </div>

        <!-- Main Content Area -->
        <div class="p-6 grid grid-cols-1 md:grid-cols-3 gap-6">
            <!-- Left Panel: Swap/Bridge/Liquidity/Launchpad/Tokens/Governance Interface -->
            <div class="md:col-span-2">
                <!-- Swap Interface -->
                <div id="swap-interface" class="space-y-4">
                    <h2 class="text-xl font-semibold text-white mb-4">Swap Tokens</h2>

                    <!-- From Input -->
                    <div>
                        <label for="from-amount-swap" class="block text-sm font-medium text-gray-400 mb-1">You pay</label>
                        <div class="input-group">
                            <input type="number" id="from-amount-swap" placeholder="0.0" min="0" class="w-full">
                            <select id="from-token-swap">
                                <option value="ETH">ETH</option>
                                <option value="USDC">USDC</option>
                                <option value="BNB">BNB</option>
                                <option value="DAI">DAI</option>
                                <option value="GOV">GOV</option>
                            </select>
                        </div>
                    </div>

                    <!-- Swap Icon -->
                    <div class="flex justify-center my-2">
                        <button class="p-2 bg-gray-700 rounded-full text-white hover:bg-gray-600 transition duration-200">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M8 7l4-4m0 0l4 4m-4-4v18" />
                            </svg>
                        </button>
                    </div>

                    <!-- To Input -->
                    <div>
                        <label for="to-amount-swap" class="block text-sm font-medium text-gray-400 mb-1">You receive</label>
                        <div class="input-group">
                            <input type="text" id="to-amount-swap" placeholder="0.0" readonly class="w-full cursor-not-allowed">
                            <select id="to-token-swap">
                                <option value="USDC">USDC</option>
                                <option value="ETH">ETH</option>
                                <option value="BNB">BNB</option>
                                <option value="DAI">DAI</option>
                                <option value="GOV">GOV</option>
                            </select>
                        </div>
                    </div>

                    <!-- Slippage and Gas -->
                    <div class="flex justify-between items-center text-sm text-gray-400">
                        <span>Slippage: <span id="slippage-display">0.5%</span></span>
                        <span>Gas Fee: <span id="gas-fee-swap">0.00 ETH</span></span>
                    </div>

                    <!-- Swap Button -->
                    <button id="swap-btn" class="action-button w-full mt-6">Swap</button>
                </div>

                <!-- Bridge Interface (hidden by default) -->
                <div id="bridge-interface" class="space-y-4 hidden">
                    <h2 class="text-xl font-semibold text-white mb-4">Bridge Tokens</h2>

                    <!-- From Chain & Token -->
                    <div>
                        <label for="from-chain-bridge" class="block text-sm font-medium text-gray-400 mb-1">From Chain</label>
                        <div class="input-group mb-4">
                            <select id="from-chain-bridge" class="flex-grow">
                                <option value="Ethereum">Ethereum Mainnet</option>
                                <option value="BSC">Binance Smart Chain</option>
                                <option value="Polygon">Polygon</option>
                            </select>
                        </div>
                        <label for="from-amount-bridge" class="block text-sm font-medium text-gray-400 mb-1">You send</label>
                        <div class="input-group">
                            <input type="number" id="from-amount-bridge" placeholder="0.0" min="0" class="w-full">
                            <select id="from-token-bridge">
                                <option value="ETH">ETH</option>
                                <option value="USDC">USDC</option>
                                <option value="BNB">BNB</option>
                                <option value="DAI">DAI</option>
                                <option value="GOV">GOV</option>
                            </select>
                        </div>
                    </div>

                    <!-- Bridge Icon -->
                    <div class="flex justify-center my-2">
                        <button class="p-2 bg-gray-700 rounded-full text-white hover:bg-gray-600 transition duration-200">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M17 8l4 4m0 0l-4 4m4-4H3" />
                            </svg>
                        </button>
                    </div>

                    <!-- To Chain & Token -->
                    <div>
                        <label for="to-chain-bridge" class="block text-sm font-medium text-gray-400 mb-1">To Chain</label>
                        <div class="input-group mb-4">
                            <select id="to-chain-bridge" class="flex-grow">
                                <option value="BSC">Binance Smart Chain</option>
                                <option value="Ethereum">Ethereum Mainnet</option>
                                <option value="Polygon">Polygon</option>
                            </select>
                        </div>
                        <label for="to-amount-bridge" class="block text-sm font-medium text-gray-400 mb-1">You receive</label>
                        <div class="input-group">
                            <input type="text" id="to-amount-bridge" placeholder="0.0" readonly class="w-full cursor-not-allowed">
                            <select id="to-token-bridge">
                                <option value="ETH">ETH</option>
                                <option value="USDC">USDC</option>
                                <option value="BNB">BNB</option>
                                <option value="DAI">DAI</option>
                                <option value="GOV">GOV</option>
                            </select>
                        </div>
                    </div>

                    <!-- Bridge Fee and Est. Time -->
                    <div class="flex justify-between items-center text-sm text-gray-400">
                        <span>Bridge Fee: <span id="bridge-fee-display">0.00 ETH</span></span>
                        <span>Est. Time: <span id="bridge-time-display">~2 mins</span></span>
                    </div>

                    <!-- Bridge Button -->
                    <button id="bridge-btn" class="action-button w-full mt-6">Bridge</button>
                </div>

                <!-- Liquidity Interface (hidden by default) -->
                <div id="liquidity-interface" class="space-y-6 hidden">
                    <h2 class="text-xl font-semibold text-white mb-4">Liquidity Pools</h2>

                    <!-- Available Pools -->
                    <div>
                        <h3 class="text-lg font-semibold text-white mb-3">Available Pools</h3>
                        <div id="available-pools-list" class="pool-list-scroll space-y-3">
                            <!-- Pools will be dynamically inserted here -->
                        </div>
                    </div>

                    <!-- Add Liquidity -->
                    <div class="bg-gray-800 p-5 rounded-lg border border-gray-700 space-y-4">
                        <h3 class="text-lg font-semibold text-white">Add Liquidity</h3>
                        <div>
                            <label for="add-liquidity-pool-select" class="block text-sm font-medium text-gray-400 mb-1">Select Pool</label>
                            <select id="add-liquidity-pool-select" class="input-group w-full">
                                <option value="ETH-USDC">ETH-USDC</option>
                                <option value="BNB-USDC">BNB-USDC</option>
                                <option value="ETH-DAI">ETH-DAI</option>
                            </select>
                        </div>
                        <div>
                            <label for="add-liquidity-amount-a" class="block text-sm font-medium text-gray-400 mb-1">Amount Token A</label>
                            <div class="input-group">
                                <input type="number" id="add-liquidity-amount-a" placeholder="0.0" min="0" class="w-full">
                                <span id="add-liquidity-token-a-display" class="text-gray-300">ETH</span>
                            </div>
                        </div>
                        <div>
                            <label for="add-liquidity-amount-b" class="block text-sm font-medium text-gray-400 mb-1">Amount Token B (Est.)</label>
                            <div class="input-group">
                                <input type="text" id="add-liquidity-amount-b" placeholder="0.0" readonly class="w-full cursor-not-allowed">
                                <span id="add-liquidity-token-b-display" class="text-gray-300">USDC</span>
                            </div>
                        </div>
                        <button id="add-liquidity-btn" class="action-button w-full">Add Liquidity</button>
                    </div>

                    <!-- Remove Liquidity -->
                    <div class="bg-gray-800 p-5 rounded-lg border border-gray-700 space-y-4">
                        <h3 class="text-lg font-semibold text-white">Remove Liquidity</h3>
                        <div>
                            <label for="remove-liquidity-pool-select" class="block text-sm font-medium text-gray-400 mb-1">Select Pool</label>
                            <select id="remove-liquidity-pool-select" class="input-group w-full">
                                <!-- Options populated dynamically -->
                            </select>
                        </div>
                        <div>
                            <label for="remove-liquidity-amount-lp" class="block text-sm font-medium text-gray-400 mb-1">LP Tokens to Remove</label>
                            <div class="input-group">
                                <input type="number" id="remove-liquidity-amount-lp" placeholder="0.0" min="0" class="w-full">
                                <span class="text-gray-300">LP</span>
                            </div>
                        </div>
                        <button id="remove-liquidity-btn" class="action-button w-full">Remove Liquidity</button>
                    </div>

                    <!-- Claim Fees -->
                    <div class="bg-gray-800 p-5 rounded-lg border border-gray-700 space-y-4">
                        <h3 class="text-lg font-semibold text-white">Claim Fees</h3>
                        <div>
                            <label for="claim-fees-pool-select" class="block text-sm font-medium text-gray-400 mb-1">Select Pool</label>
                            <select id="claim-fees-pool-select" class="input-group w-full">
                                <!-- Options populated dynamically -->
                            </select>
                        </div>
                        <div class="flex justify-between items-center text-sm text-gray-400">
                            <span>Claimable Fees: <span id="claimable-fees-display" class="text-white">0.00 USDC</span></span>
                        </div>
                        <button id="claim-fees-btn" class="action-button w-full">Claim Fees</button>
                    </div>
                </div>

                <!-- Launchpad Interface (hidden by default) -->
                <div id="launchpad-interface" class="space-y-6 hidden">
                    <h2 class="text-xl font-semibold text-white mb-4">Launchpad: Genesis & Launch Pools</h2>

                    <!-- Genesis Pools -->
                    <div>
                        <h3 class="text-lg font-semibold text-white mb-3">Active Genesis Pools</h3>
                        <div id="genesis-pools-list" class="genesis-pools-scroll space-y-3">
                            <p class="text-sm text-gray-500 text-center">No active genesis pools.</p>
                        </div>
                    </div>

                    <!-- Launch Pools (Staking GOV) -->
                    <div>
                        <h3 class="text-lg font-semibold text-white mb-3">Active Launch Pools (Stake GOV)</h3>
                        <div id="launch-pools-list" class="launch-pools-scroll space-y-3">
                            <p class="text-sm text-gray-500 text-center">No active launch pools.</p>
                        </div>
                    </div>
                </div>

                <!-- Tokens Info Interface (hidden by default) -->
                <div id="tokens-interface" class="space-y-6 hidden">
                    <h2 class="text-xl font-semibold text-white mb-4">Launched Token Info</h2>

                    <div>
                        <label for="select-token-info" class="block text-sm font-medium text-gray-400 mb-1">Select Token</label>
                        <select id="select-token-info" class="input-group w-full">
                            <option value="">Select a launched token...</option>
                            <!-- Options populated dynamically -->
                        </select>
                    </div>

                    <div id="selected-token-details" class="space-y-4 hidden">
                        <div class="token-info-item">
                            <span class="text-gray-300 font-medium">Symbol</span>
                            <span id="token-symbol-display" class="text-white text-lg font-semibold"></span>
                        </div>
                        <div class="token-info-item">
                            <span class="text-gray-300 font-medium">Name</span>
                            <span id="token-name-display" class="text-white text-lg font-semibold"></span>
                        </div>
                        <div class="token-info-item">
                            <span class="text-gray-300 font-medium">Current Price (USDC)</span>
                            <span id="token-price-display" class="text-white text-lg font-semibold"></span>
                        </div>
                        <div class="token-info-item">
                            <span class="text-gray-300 font-medium">Market Cap (USDC)</span>
                            <span id="token-market-cap-display" class="text-white text-lg font-semibold"></span>
                        </div>
                        <div class="token-info-item">
                            <span class="text-gray-300 font-medium">Total Supply</span>
                            <span id="token-supply-display" class="text-white text-lg font-semibold"></span>
                        </div>
                        <div class="token-info-item">
                            <span class="text-gray-300 font-medium">Liquidity (USDC)</span>
                            <span id="token-liquidity-display" class="text-white text-lg font-semibold"></span>
                        </div>
                        <div class="token-info-item">
                            <span class="text-gray-300 font-medium">Developer Holdings</span>
                            <span id="token-dev-holdings-display" class="text-white text-lg font-semibold"></span>
                        </div>
                        <div class="token-info-item">
                            <span class="text-gray-300 font-medium">Top 10 Holders Share</span>
                            <span id="token-top-holders-display" class="text-white text-lg font-semibold"></span>
                        </div>
                        <div class="token-info-item">
                            <span class="text-gray-300 font-medium">Buy Volume (24h)</span>
                            <span id="token-buy-volume-display" class="text-white text-lg font-semibold"></span>
                        </div>
                        <div class="token-info-item">
                            <span class="text-gray-300 font-medium">Sell Volume (24h)</span>
                            <span id="token-sell-volume-display" class="text-white text-lg font-semibold"></span>
                        </div>

                        <!-- Simple Chart -->
                        <h3 class="text-lg font-semibold text-white mt-4">Price Chart</h3>
                        <div class="chart-container">
                            <svg id="token-chart-svg" class="chart-line" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>
                        </div>
                    </div>
                </div>

                <!-- Staking Interface (NEW) -->
                <div id="staking-interface" class="space-y-6 hidden">
                    <h2 class="text-xl font-semibold text-white mb-4">Staking Pools</h2>

                    <div id="staking-pools-list" class="staking-pools-scroll space-y-3">
                        <p class="text-sm text-gray-500 text-center">No active staking pools.</p>
                    </div>
                </div>

                <!-- Short It Interface (NEW) -->
                <div id="short-it-interface" class="space-y-6 hidden">
                    <h2 class="text-xl font-semibold text-white mb-4">Short It: Price Prediction Game</h2>

                    <div>
                        <label for="short-it-token-select" class="block text-sm font-medium text-gray-400 mb-1">Select Token</label>
                        <select id="short-it-token-select" class="input-group w-full">
                            <option value="">Select a launched token...</option>
                        </select>
                    </div>

                    <div id="short-it-game-area" class="space-y-4 hidden">
                        <div class="bg-gray-800 p-5 rounded-lg border border-gray-700 space-y-4">
                            <h3 class="text-lg font-semibold text-white">Place Your Bet</h3>
                            <div class="flex justify-between items-center text-sm text-gray-400">
                                <span>Current Price: <span id="short-it-current-price" class="text-white"></span></span>
                                <span>Pool Balance: <span id="short-it-pool-balance" class="text-white"></span></span>
                            </div>
                            <div>
                                <label for="short-it-amount" class="block text-sm font-medium text-gray-400 mb-1">Bet Amount</label>
                                <div class="input-group">
                                    <input type="number" id="short-it-amount" placeholder="0.0" min="0" class="w-full">
                                    <button class="max-button" data-input-id="short-it-amount" data-balance-token="selectedShortItToken">Max</button>
                                </div>
                            </div>
                            <div>
                                <label for="short-it-time" class="block text-sm font-medium text-gray-400 mb-1">Prediction Time</label>
                                <select id="short-it-time" class="input-group w-full">
                                    <option value="3">3 Seconds (x2)</option>
                                    <option value="5">5 Seconds (x3)</option>
                                    <option value="10">10 Seconds (x4)</option>
                                </select>
                            </div>
                            <div class="flex gap-4">
                                <button id="short-it-bet-up" class="action-button flex-1 bg-green-600 hover:bg-green-700">Bet UP</button>
                                <button id="short-it-bet-down" class="action-button flex-1 bg-red-600 hover:bg-red-700">Bet DOWN</button>
                            </div>
                            <div class="text-center text-yellow-400 font-semibold" id="short-it-timer"></div>
                        </div>

                        <h3 class="text-lg font-semibold text-white mt-4">Price Movement</h3>
                        <div class="short-it-chart-container" id="short-it-chart-container">
                            <!-- Bars will be dynamically added here -->
                        </div>

                        <h3 class="text-lg font-semibold text-white mt-4">My Short It History</h3>
                        <div id="short-it-history" class="short-it-history-scroll space-y-2 p-3 bg-gray-800 rounded-lg border border-gray-700">
                            <p class="text-sm text-gray-500 text-center">No bets yet.</p>
                        </div>
                    </div>
                </div>

                <!-- NFT Interface (NEW) -->
                <div id="nft-interface" class="space-y-6 hidden">
                    <h2 class="text-xl font-semibold text-white mb-4">NFT Launchpad & Marketplace</h2>

                    <div id="nft-launch-section" class="bg-gray-800 p-5 rounded-lg border border-gray-700 space-y-4">
                        <h3 class="text-lg font-semibold text-white">Launch Your NFT Collection</h3>
                        <p class="text-sm text-gray-400">Launch your collection and a paired token once!</p>
                        <div>
                            <label for="nft-collection-name" class="block text-sm font-medium text-gray-400 mb-1">Collection Name</label>
                            <input type="text" id="nft-collection-name" placeholder="My Awesome Collection" class="input-group w-full">
                        </div>
                        <div>
                            <label for="nft-base-mint-price" class="block text-sm font-medium text-gray-400 mb-1">Base Mint Price (USDC)</label>
                            <input type="number" id="nft-base-mint-price" placeholder="100" min="1" class="input-group w-full">
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div>
                                <label for="nft-common-count" class="block text-sm font-medium text-gray-400 mb-1">Common NFTs (Count)</label>
                                <input type="number" id="nft-common-count" placeholder="100" min="0" class="input-group w-full">
                                <label for="nft-common-img" class="block text-sm font-medium text-gray-400 mt-2 mb-1">Common Image (Imgur URL)</label>
                                <input type="text" id="nft-common-img" placeholder="https://i.imgur.com/common.png" class="input-group w-full">
                            </div>
                            <div>
                                <label for="nft-rare-count" class="block text-sm font-medium text-gray-400 mb-1">Rare NFTs (Count)</label>
                                <input type="number" id="nft-rare-count" placeholder="20" min="0" class="input-group w-full">
                                <label for="nft-rare-img" class="block text-sm font-medium text-gray-400 mt-2 mb-1">Rare Image (Imgur URL)</label>
                                <input type="text" id="nft-rare-img" placeholder="https://i.imgur.com/rare.png" class="input-group w-full">
                            </div>
                            <div>
                                <label for="nft-legendary-count" class="block text-sm font-medium text-gray-400 mb-1">Legendary NFTs (Count)</label>
                                <input type="number" id="nft-legendary-count" placeholder="5" min="0" class="input-group w-full">
                                <label for="nft-legendary-img" class="block text-sm font-medium text-gray-400 mt-2 mb-1">Legendary Image (Imgur URL)</label>
                                <input type="text" id="nft-legendary-img" placeholder="https://i.imgur.com/legendary.png" class="input-group w-full">
                            </div>
                        </div>
                        <h4 class="text-md font-semibold text-white mt-4">Paired Token Allocation (%)</h4>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label for="nft-token-lp-percent" class="block text-sm font-medium text-gray-400 mb-1">LP Allocation (%)</label>
                                <input type="number" id="nft-token-lp-percent" placeholder="50" min="0" max="100" class="input-group w-full">
                            </div>
                            <div>
                                <label for="nft-token-lp-rewards-percent" class="block text-sm font-medium text-gray-400 mb-1">LP Rewards (%)</label>
                                <input type="number" id="nft-token-lp-rewards-percent" placeholder="10" min="0" max="100" class="input-group w-full">
                            </div>
                            <div>
                                <label for="nft-token-staking-rewards-percent" class="block text-sm font-medium text-gray-400 mb-1">Staking Rewards (%)</label>
                                <input type="number" id="nft-token-staking-rewards-percent" placeholder="10" min="0" max="100" class="input-group w-full">
                            </div>
                            <div>
                                <label for="nft-token-dev-wallet-percent" class="block text-sm font-medium text-gray-400 mb-1">Your Wallet (%)</label>
                                <input type="number" id="nft-token-dev-wallet-percent" placeholder="30" min="0" max="100" class="input-group w-full">
                            </div>
                        </div>
                        <button id="launch-nft-collection-btn" class="action-button w-full mt-6">Launch Collection</button>
                    </div>

                    <div id="nft-collection-info" class="space-y-4 hidden">
                        <h3 class="text-lg font-semibold text-white">Your Collection: <span id="my-nft-collection-name"></span></h3>
                        <div class="nft-info-item">
                            <span class="text-gray-300 font-medium">Floor Price</span>
                            <span id="my-nft-floor-price" class="text-white text-lg font-semibold"></span>
                        </div>
                        <div class="nft-info-item">
                            <span class="text-gray-300 font-medium">Total Minted</span>
                            <span id="my-nft-total-minted" class="text-white text-lg font-semibold"></span>
                        </div>
                        <div class="nft-info-item">
                            <span class="text-gray-300 font-medium">Your NFTs</span>
                            <span id="my-nft-owned" class="text-white text-lg font-semibold"></span>
                        </div>
                        <button id="claim-nft-fees-btn" class="action-button w-full">Claim NFT Marketplace Fees</button>
                        <p class="text-sm text-gray-400">Claimable: <span id="my-nft-claimable-fees">0.00</span> <span id="my-nft-token-symbol"></span></p>

                        <h3 class="text-lg font-semibold text-white mt-4">NFT Marketplace</h3>
                        <div id="nft-marketplace-list" class="nft-marketplace-scroll nft-grid space-y-3">
                            <p class="text-sm text-gray-500 text-center col-span-full">No NFTs listed for sale.</p>
                        </div>

                        <h3 class="text-lg font-semibold text-white mt-4">NFT Staking Pool</h3>
                        <div id="nft-staking-pool-info" class="bg-gray-800 p-5 rounded-lg border border-gray-700 space-y-4">
                            <p class="text-sm text-gray-400">Total Staked NFTs: <span id="nft-staking-total-staked">0</span></p>
                            <p class="text-sm text-gray-400">Your Staked NFTs: <span id="nft-staking-user-staked">0</span></p>
                            <p class="text-sm text-gray-400">Your Earned Rewards: <span id="nft-staking-user-earned">0.00</span> <span id="nft-staking-reward-token"></span></p>
                            <p class="text-sm text-gray-400">Rewards Supplied by Dev: <span id="nft-staking-dev-supplied-rewards">0.00</span> <span id="nft-staking-reward-token-dev"></span></p>
                            <div>
                                <label for="nft-staking-supply-amount" class="block text-sm font-medium text-gray-400 mb-1">Supply Rewards</label>
                                <div class="input-group">
                                    <input type="number" id="nft-staking-supply-amount" placeholder="0.0" min="0" class="w-full">
                                    <select id="nft-staking-supply-token" class="w-24">
                                        <!-- Populated dynamically with all available tokens -->
                                    </select>
                                </div>
                                <button id="supply-nft-staking-rewards-btn" class="action-button w-full mt-2">Supply Rewards</button>
                            </div>
                            <div class="flex gap-4">
                                <button id="stake-my-nft-btn" class="action-button flex-1">Stake My NFT</button>
                                <button id="unstake-claim-nft-rewards-btn" class="action-button flex-1">Unstake & Claim</button>
                            </div>
                        </div>

                        <h3 class="text-lg font-semibold text-white mt-4">Your Staked NFTs</h3>
                        <div id="my-staked-nfts-list" class="nft-staking-scroll nft-grid space-y-3">
                            <p class="text-sm text-gray-500 text-center col-span-full">No NFTs staked.</p>
                        </div>
                    </div>
                </div>

                <!-- Governance Interface -->
                <div id="governance-interface" class="space-y-6 hidden">
                    <h2 class="text-xl font-semibold text-white mb-4">Governance Proposals</h2>

                    <!-- Proposals List -->
                    <div>
                        <h3 class="text-lg font-semibold text-white mb-3">Active Proposals</h3>
                        <div id="proposals-list" class="proposals-list-scroll space-y-4">
                            <!-- Proposals will be dynamically inserted here -->
                        </div>
                    </div>
                </div>

                <!-- Dashboard Interface (New) -->
                <div id="dashboard-interface" class="space-y-6 hidden">
                    <h2 class="text-xl font-semibold text-white mb-4">Platform Dashboard</h2>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="dashboard-item">
                            <span class="text-gray-300 font-medium">Total Value Locked (TVL)</span>
                            <span id="dashboard-tvl" class="text-white text-lg font-semibold">$0.00</span>
                        </div>
                        <div class="dashboard-item">
                            <span class="text-gray-300 font-medium">Total Platform Revenue</span>
                            <span id="dashboard-revenue" class="text-white text-lg font-semibold">$0.00</span>
                        </div>
                        <div class="dashboard-item">
                            <span class="text-gray-300 font-medium">Total Trading Volume</span>
                            <span id="dashboard-volume" class="text-white text-lg font-semibold">$0.00</span>
                        </div>
                        <div class="dashboard-item">
                            <span class="text-gray-300 font-medium">Total Launched Tokens</span>
                            <span id="dashboard-launched-tokens" class="text-white text-lg font-semibold">0</span>
                        </div>
                        <div class="dashboard-item">
                            <span class="text-gray-300 font-medium">Average Pool APR</span>
                            <span id="dashboard-avg-apr" class="text-white text-lg font-semibold">0.00%</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Balances, Portfolio, Transaction Status & History -->
            <div class="md:col-span-1 space-y-6">
                <!-- Portfolio Tracker Section -->
                <div>
                    <h2 class="text-xl font-semibold text-white mb-4">Your Portfolio</h2>
                    <div id="portfolio-tracker" class="space-y-3">
                        <div class="portfolio-item">
                            <span class="text-gray-300 font-medium">Total Assets Value</span>
                            <span id="total-assets-value" class="text-white text-lg font-semibold">$0.00</span>
                        </div>
                        <div class="portfolio-item">
                            <span class="text-gray-300 font-medium">LP Positions Value</span>
                            <span id="lp-positions-value" class="text-white text-lg font-semibold">$0.00</span>
                        </div>
                        <div class="portfolio-item">
                            <span class="text-gray-300 font-medium">Earned Fees</span>
                            <span id="earned-fees-value" class="text-white text-lg font-semibold">$0.00</span>
                        </div>
                    </div>
                </div>

                <!-- Balances Section -->
                <div>
                    <h2 class="text-xl font-semibold text-white mb-4">Your Balances</h2>
                    <div id="balances-list" class="space-y-3">
                        <!-- Balances will be dynamically inserted here -->
                    </div>
                </div>

                <!-- Transaction Status Section -->
                <div>
                    <h2 class="text-xl font-semibold text-white mb-4">Transaction Status</h2>
                    <div id="transaction-status-message" class="transaction-status">
                        No active transactions.
                    </div>
                </div>

                <!-- Transaction History -->
                <div>
                    <h2 class="text-xl font-semibold text-white mb-4">Transaction History</h2>
                    <div id="transaction-history" class="transaction-history-scroll space-y-2 p-3 bg-gray-800 rounded-lg border border-gray-700">
                        <!-- History items will be dynamically inserted here -->
                        <p class="text-sm text-gray-500 text-center">No history yet.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Global State ---
        const state = {
            isConnected: false,
            // Starting balances including the new GOV token
            balances: {
                ETH: 10.00,
                USDC: 50000.00,
                BNB: 50.00,
                DAI: 10000.00,
                GOV: 1000.00, // New governance token
                PEPE: 1000000.00, // New base asset
                DOGE: 500000.00, // New base asset
                XRP: 10000.00, // New base asset
                SUI: 5000.00, // New base asset
            },
            exchangeRates: { // Base rates for simulation (1 ETH = 2000 USDC)
                'ETH/USDC': 2000,
                'USDC/ETH': 1 / 2000,
                'ETH/BNB': 15,
                'BNB/ETH': 1 / 15,
                'USDC/DAI': 1, // Stablecoin to stablecoin
                'DAI/USDC': 1,
                'BNB/USDC': 300,
                'USDC/BNB': 1 / 300,
                'ETH/DAI': 2000,
                'DAI/ETH': 1 / 2000,
                'BNB/DAI': 300,
                'DAI/BNB': 1 / 300,
                'GOV/USDC': 0.5, // 1 GOV = 0.5 USDC
                'USDC/GOV': 1 / 0.5,
                'ETH/GOV': 2000 / 0.5, // ETH price / GOV price
                'GOV/ETH': 0.5 / 2000,
                'PEPE/USDC': 0.000001, // New base asset price
                'USDC/PEPE': 1 / 0.000001,
                'DOGE/USDC': 0.08, // New base asset price
                'USDC/DOGE': 1 / 0.08,
                'XRP/USDC': 0.5, // New base asset price
                'USDC/XRP': 1 / 0.5,
                'SUI/USDC': 1.2, // New base asset price
                'USDC/SUI': 1 / 1.2,
            },
            slippagePercentage: 0.5, // Default slippage
            gasFeeEth: 0.005, // Simulated gas fee in ETH
            bridgeFeeEth: 0.01, // Simulated bridge fee in ETH
            bridgeTimeMinutes: 2, // Simulated bridge time
            transactionHistory: [],
            liquidityPools: {
                'ETH-USDC': { tokenA: 'ETH', tokenB: 'USDC', tvl: 100000, apr: 0.85, userLiquidityLP: 0, userFees: 0, totalLP: 1000, totalFeesCollected: 0, devRewards: 0 },
                'BNB-USDC': { tokenA: 'BNB', tokenB: 'USDC', tvl: 50000, apr: 1.20, userLiquidityLP: 0, userFees: 0, totalLP: 500, totalFeesCollected: 0, devRewards: 0 },
                'ETH-DAI': { tokenA: 'ETH', tokenB: 'DAI', tvl: 75000, apr: 0.92, userLiquidityLP: 0, userFees: 0, totalLP: 750, totalFeesCollected: 0, devRewards: 0 },
                'PEPE-USDC': { tokenA: 'PEPE', tokenB: 'USDC', tvl: 10000, apr: 1.50, userLiquidityLP: 0, userFees: 0, totalLP: 100, totalFeesCollected: 0, devRewards: 0 },
                'DOGE-USDC': { tokenA: 'DOGE', tokenB: 'USDC', tvl: 20000, apr: 1.00, userLiquidityLP: 0, userFees: 0, totalLP: 200, totalFeesCollected: 0, devRewards: 0 },
                'XRP-USDC': { tokenA: 'XRP', tokenB: 'USDC', tvl: 15000, apr: 0.90, userLiquidityLP: 0, userFees: 0, totalLP: 150, totalFeesCollected: 0, devRewards: 0 },
                'SUI-USDC': { tokenA: 'SUI', tokenB: 'USDC', tvl: 12000, apr: 1.10, userLiquidityLP: 0, userFees: 0, totalLP: 120, totalFeesCollected: 0, devRewards: 0 },
            },
            proposals: [
                {
                    id: 'prop-1',
                    title: 'Adjust ETH-USDC Pool APR to 150%',
                    description: 'This proposal aims to increase the APR for the ETH-USDC liquidity pool to attract more liquidity providers.',
                    status: 'active',
                    votesYes: 150,
                    votesNo: 50,
                    totalVotingPower: 200,
                    endsAt: Date.now() + 60 * 1000 * 5, // 5 minutes from now
                    effect: { type: 'adjustApr', pool: 'ETH-USDC', newApr: 1.50 },
                    hasVoted: false // Tracks if the current user has voted
                },
                {
                    id: 'prop-2',
                    title: 'Reduce Global Swap Slippage to 0.2%',
                    description: 'A proposal to reduce the default swap slippage, improving trading efficiency for users.',
                    status: 'active',
                    votesYes: 200,
                    votesNo: 80,
                    totalVotingPower: 280,
                    endsAt: Date.now() + 60 * 1000 * 10, // 10 minutes from now
                    effect: { type: 'adjustSlippage', newSlippage: 0.2 },
                    hasVoted: false
                }
            ],
            genesisPools: [], // New: Tokens in pre-launch phase
            launchPools: [], // New: Staking pools for genesis tokens (GOV staking for new token)
            stakingPools: {}, // New: Staking pools for launched tokens (launched token staking for launched token)
            launchedTokens: {}, // New: Stores info for launched tokens (key: symbol)
            shortItPools: {}, // New: Stores short-it game pools
            shortItHistory: [], // New: User's short-it game history
            nftCollections: {}, // New: Stores launched NFT collections
            myNFTCollection: null, // Stores the user's launched NFT collection
            myNFTs: [], // User's owned NFTs
            nftMarketplaceListings: [], // NFTs listed for sale by bots or users
            nftStakingPool: null, // The single NFT staking pool for the user's collection
            totalPortfolioValue: 0,
            totalEarnedFees: 0,
            userVotingPower: 0, // Will be set to GOV balance when connected

            // Dashboard Stats (New)
            totalPlatformTVL: 0,
            totalPlatformRevenue: 0,
            totalTradingVolume: 0,
            totalLaunchedTokensCount: 0,
            averagePoolAPR: 0
        };

        // --- DOM Elements ---
        const connectWalletBtn = document.getElementById('connect-wallet-btn');
        const swapTabBtn = document.getElementById('swap-tab-btn');
        const bridgeTabBtn = document.getElementById('bridge-tab-btn');
        const liquidityTabBtn = document.getElementById('liquidity-tab-btn');
        const launchpadTabBtn = document.getElementById('launchpad-tab-btn'); // New
        const tokensTabBtn = document.getElementById('tokens-tab-btn'); // New
        const stakingTabBtn = document.getElementById('staking-tab-btn'); // New
        const shortItTabBtn = document.getElementById('short-it-tab-btn'); // New
        const nftTabBtn = document.getElementById('nft-tab-btn'); // New
        const governanceTabBtn = document.getElementById('governance-tab-btn');
        const dashboardTabBtn = document.getElementById('dashboard-tab-btn'); // New
        const swapInterface = document.getElementById('swap-interface');
        const bridgeInterface = document.getElementById('bridge-interface');
        const liquidityInterface = document.getElementById('liquidity-interface');
        const launchpadInterface = document.getElementById('launchpad-interface'); // New
        const tokensInterface = document.getElementById('tokens-interface'); // New
        const stakingInterface = document.getElementById('staking-interface'); // New
        const shortItInterface = document.getElementById('short-it-interface'); // New
        const nftInterface = document.getElementById('nft-interface'); // New
        const governanceInterface = document.getElementById('governance-interface');
        const dashboardInterface = document.getElementById('dashboard-interface'); // New

        // Swap Elements
        const fromAmountSwap = document.getElementById('from-amount-swap');
        const fromTokenSwap = document.getElementById('from-token-swap');
        const toAmountSwap = document.getElementById('to-amount-swap');
        const toTokenSwap = document.getElementById('to-token-swap');
        const slippageDisplay = document.getElementById('slippage-display');
        const gasFeeSwapDisplay = document.getElementById('gas-fee-swap');
        const swapBtn = document.getElementById('swap-btn');

        // Bridge Elements
        const fromAmountBridge = document.getElementById('from-amount-bridge');
        const fromTokenBridge = document.getElementById('from-token-bridge');
        const fromChainBridge = document.getElementById('from-chain-bridge');
        const toAmountBridge = document.getElementById('to-amount-bridge');
        const toTokenBridge = document.getElementById('to-token-bridge');
        const toChainBridge = document.getElementById('to-chain-bridge');
        const bridgeFeeDisplay = document.getElementById('bridge-fee-display');
        const bridgeTimeDisplay = document.getElementById('bridge-time-display');
        const bridgeBtn = document.getElementById('bridge-btn');

        // Liquidity Elements
        const availablePoolsList = document.getElementById('available-pools-list');
        const addLiquidityPoolSelect = document.getElementById('add-liquidity-pool-select');
        const addLiquidityAmountA = document.getElementById('add-liquidity-amount-a');
        const addLiquidityTokenADisplay = document.getElementById('add-liquidity-token-a-display');
        const addLiquidityAmountB = document.getElementById('add-liquidity-amount-b');
        const addLiquidityTokenBDisplay = document.getElementById('add-liquidity-token-b-display');
        const addLiquidityBtn = document.getElementById('add-liquidity-btn');
        const removeLiquidityPoolSelect = document.getElementById('remove-liquidity-pool-select');
        const removeLiquidityAmountLP = document.getElementById('remove-liquidity-amount-lp');
        const removeLiquidityBtn = document.getElementById('remove-liquidity-btn');
        const claimFeesPoolSelect = document.getElementById('claim-fees-pool-select');
        const claimableFeesDisplay = document.getElementById('claimable-fees-display');
        const claimFeesBtn = document.getElementById('claim-fees-btn');

        // Launchpad Elements (New)
        const genesisPoolsList = document.getElementById('genesis-pools-list');
        const launchPoolsList = document.getElementById('launch-pools-list');

        // Tokens Info Elements (New)
        const selectTokenInfo = document.getElementById('select-token-info');
        const selectedTokenDetails = document.getElementById('selected-token-details');
        const tokenSymbolDisplay = document.getElementById('token-symbol-display');
        const tokenNameDisplay = document.getElementById('token-name-display');
        const tokenPriceDisplay = document.getElementById('token-price-display');
        const tokenMarketCapDisplay = document.getElementById('token-market-cap-display');
        const tokenSupplyDisplay = document.getElementById('token-supply-display');
        const tokenLiquidityDisplay = document.getElementById('token-liquidity-display');
        const tokenDevHoldingsDisplay = document.getElementById('token-dev-holdings-display');
        const tokenTopHoldersDisplay = document.getElementById('token-top-holders-display');
        const tokenBuyVolumeDisplay = document.getElementById('token-buy-volume-display'); // New
        const tokenSellVolumeDisplay = document.getElementById('token-sell-volume-display'); // New
        const tokenChartSVG = document.getElementById('token-chart-svg');

        // Staking Elements (New)
        const stakingPoolsList = document.getElementById('staking-pools-list');

        // Short It Elements (New)
        const shortItTokenSelect = document.getElementById('short-it-token-select');
        const shortItGameArea = document.getElementById('short-it-game-area');
        const shortItCurrentPrice = document.getElementById('short-it-current-price');
        const shortItPoolBalance = document.getElementById('short-it-pool-balance');
        const shortItAmountInput = document.getElementById('short-it-amount');
        const shortItTimeSelect = document.getElementById('short-it-time');
        const shortItBetUpBtn = document.getElementById('short-it-bet-up');
        const shortItBetDownBtn = document.getElementById('short-it-bet-down');
        const shortItTimerDisplay = document.getElementById('short-it-timer');
        const shortItChartContainer = document.getElementById('short-it-chart-container');
        const shortItHistoryDiv = document.getElementById('short-it-history');

        // NFT Elements (New)
        const nftLaunchSection = document.getElementById('nft-launch-section');
        const nftCollectionInfo = document.getElementById('nft-collection-info');
        const nftCollectionNameInput = document.getElementById('nft-collection-name');
        const nftBaseMintPriceInput = document.getElementById('nft-base-mint-price');
        const nftCommonCountInput = document.getElementById('nft-common-count');
        const nftCommonImgInput = document.getElementById('nft-common-img');
        const nftRareCountInput = document.getElementById('nft-rare-count');
        const nftRareImgInput = document.getElementById('nft-rare-img');
        const nftLegendaryCountInput = document.getElementById('nft-legendary-count');
        const nftLegendaryImgInput = document.getElementById('nft-legendary-img');
        const nftTokenLpPercentInput = document.getElementById('nft-token-lp-percent');
        const nftTokenLpRewardsPercentInput = document.getElementById('nft-token-lp-rewards-percent');
        const nftTokenStakingRewardsPercentInput = document.getElementById('nft-token-staking-rewards-percent');
        const nftTokenDevWalletPercentInput = document.getElementById('nft-token-dev-wallet-percent');
        const launchNftCollectionBtn = document.getElementById('launch-nft-collection-btn');

        const myNftCollectionNameDisplay = document.getElementById('my-nft-collection-name');
        const myNftFloorPriceDisplay = document.getElementById('my-nft-floor-price');
        const myNftTotalMintedDisplay = document.getElementById('my-nft-total-minted');
        const myNftOwnedDisplay = document.getElementById('my-nft-owned');
        const myNftClaimableFeesDisplay = document.getElementById('my-nft-claimable-fees');
        const myNftTokenSymbolDisplay = document.getElementById('my-nft-token-symbol');
        const claimNftFeesBtn = document.getElementById('claim-nft-fees-btn');

        const nftMarketplaceList = document.getElementById('nft-marketplace-list');

        const nftStakingPoolInfo = document.getElementById('nft-staking-pool-info');
        const nftStakingTotalStakedDisplay = document.getElementById('nft-staking-total-staked');
        const nftStakingUserStakedDisplay = document.getElementById('nft-staking-user-staked');
        const nftStakingUserEarnedDisplay = document.getElementById('nft-staking-user-earned');
        const nftStakingRewardTokenDisplay = document.getElementById('nft-staking-reward-token');
        const nftStakingDevSuppliedRewardsDisplay = document.getElementById('nft-staking-dev-supplied-rewards');
        const nftStakingRewardTokenDevDisplay = document.getElementById('nft-staking-reward-token-dev');
        const nftStakingSupplyAmountInput = document.getElementById('nft-staking-supply-amount');
        const nftStakingSupplyTokenSelect = document.getElementById('nft-staking-supply-token');
        const supplyNftStakingRewardsBtn = document.getElementById('supply-nft-staking-rewards-btn');
        const stakeMyNftBtn = document.getElementById('stake-my-nft-btn');
        const unstakeClaimNftRewardsBtn = document.getElementById('unstake-claim-nft-rewards-btn');
        const myStakedNftsList = document.getElementById('my-staked-nfts-list');


        // Governance Elements
        const proposalsList = document.getElementById('proposals-list');

        // Dashboard Elements (New)
        const dashboardTVL = document.getElementById('dashboard-tvl');
        const dashboardRevenue = document.getElementById('dashboard-revenue');
        const dashboardVolume = document.getElementById('dashboard-volume');
        const dashboardLaunchedTokens = document.getElementById('dashboard-launched-tokens');
        const dashboardAvgAPR = document.getElementById('dashboard-avg-apr');


        // General Display Elements
        const balancesList = document.getElementById('balances-list');
        const transactionStatusMessage = document.getElementById('transaction-status-message');
        const transactionHistoryDiv = document.getElementById('transaction-history');
        const portfolioTrackerDiv = document.getElementById('portfolio-tracker');
        const totalAssetsValue = document.getElementById('total-assets-value');
        const lpPositionsValue = document.getElementById('lp-positions-value');
        const earnedFeesValue = document.getElementById('earned-fees-value');


        // --- Three.js Setup ---
        let scene, camera, renderer;
        let particles = [];
        let lines = []; // For connecting particles
        const particleCount = 200;
        const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const particleMaterial = new THREE.MeshBasicMaterial({ color: 0x8b5cf6 }); // Purple color
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x6366f1, transparent: true, opacity: 0.3 });

        function initThreeJS() {
            const canvas = document.getElementById('threejs-canvas');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true }); // alpha: true for transparent background
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            camera.position.z = 5;

            // Create particles
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.01,
                    (Math.random() - 0.5) * 0.01,
                    (Math.random() - 0.5) * 0.01
                );
                scene.add(particle);
                particles.push(particle);
            }

            // Create lines between nearby particles
            const maxDistance = 1.5; // Max distance for particles to be connected
            for (let i = 0; i < particleCount; i++) {
                for (let j = i + 1; j < particleCount; j++) {
                    if (particles[i].position.distanceTo(particles[j].position) < maxDistance) {
                        const geometry = new THREE.BufferGeometry().setFromPoints([particles[i].position, particles[j].position]);
                        const line = new THREE.Line(geometry, lineMaterial);
                        scene.add(line);
                        lines.push({ line: line, p1: particles[i], p2: particles[j] });
                    }
                }
            }


            // Add a subtle ambient light
            const ambientLight = new THREE.AmbientLight(0x404040); // soft white light
            scene.add(ambientLight);

            // Add a directional light for some highlights
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
        }

        function animateThreeJS() {
            requestAnimationFrame(animateThreeJS);

            // Animate particles
            particles.forEach(p => {
                p.position.add(p.velocity);
                if (p.position.length() > 7) { // Reset if too far
                    p.position.set(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10
                    );
                }
                p.rotation.x += 0.01;
                p.rotation.y += 0.005;
            });

            // Update lines
            lines.forEach(lineObj => {
                const positions = lineObj.line.geometry.attributes.position.array;
                positions[0] = lineObj.p1.position.x;
                positions[1] = lineObj.p1.position.y;
                positions[2] = lineObj.p1.position.z;
                positions[3] = lineObj.p2.position.x;
                positions[4] = lineObj.p2.position.y;
                positions[5] = lineObj.p2.position.z;
                lineObj.line.geometry.attributes.position.needsUpdate = true;
            });

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Visual Effects Functions ---
        function triggerBurstEffect() {
            // Temporarily change particle color to a bright one and make them expand
            particles.forEach(p => {
                p.material.color.set(0xffffff); // White burst
                p.scale.set(1, 1, 1);
                p.initialPosition = p.position.clone();
                p.burstVelocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
            });

            let burstProgress = 0;
            const burstDuration = 60; // frames

            function animateBurst() {
                if (burstProgress < burstDuration) {
                    particles.forEach(p => {
                        p.position.add(p.burstVelocity);
                        p.material.opacity = 1 - (burstProgress / burstDuration);
                        p.material.transparent = true;
                    });
                    burstProgress++;
                    requestAnimationFrame(animateBurst);
                } else {
                    // Reset particles after burst
                    particles.forEach(p => {
                        p.material.color.set(0x8b5cf6); // Reset to purple
                        p.material.opacity = 1;
                        p.material.transparent = false;
                        p.position.set(
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10
                        );
                        p.scale.set(1, 1, 1); // Reset scale
                    });
                }
            }
            animateBurst();
        }

        function triggerSlingshotAnimation() {
            const slingshotEl = document.createElement('div');
            slingshotEl.className = 'slingshot-animation';
            // Random target position within the transaction status box
            const targetX = Math.random() * 80 + 10; // 10% to 90%
            const targetY = Math.random() * 80 + 10; // 10% to 90%
            slingshotEl.style.setProperty('--target-x', `${targetX}%`);
            slingshotEl.style.setProperty('--target-y', `${targetY}%`);

            transactionStatusMessage.appendChild(slingshotEl);

            setTimeout(() => {
                slingshotEl.remove();
            }, 1000); // Remove after animation
        }


        // --- UI Update Functions ---
        function updateBalancesUI() {
            balancesList.innerHTML = ''; // Clear existing balances
            for (const token in state.balances) {
                const balanceItem = document.createElement('div');
                balanceItem.className = 'balance-item';
                balanceItem.innerHTML = `
                    <span class="text-gray-300 font-medium">${token}</span>
                    <span class="text-white text-lg font-semibold">${state.balances[token].toFixed(2)}</span>
                `;
                balancesList.appendChild(balanceItem);
            }
            // Update token select options for swap/bridge if new tokens are launched
            updateSwapBridgeTokenOptions();
        }

        function updateSwapBridgeTokenOptions() {
            const allTokens = Object.keys(state.balances);
            const swapFromSelect = document.getElementById('from-token-swap');
            const swapToSelect = document.getElementById('to-token-swap');
            const bridgeFromSelect = document.getElementById('from-token-bridge');
            const bridgeToSelect = document.getElementById('to-token-bridge');
            const shortItTokenSelect = document.getElementById('short-it-token-select');
            const nftStakingSupplyTokenSelect = document.getElementById('nft-staking-supply-token');


            // Store current selections to re-apply after update
            const currentSwapFrom = swapFromSelect.value;
            const currentSwapTo = swapToSelect.value;
            const currentBridgeFrom = bridgeFromSelect.value;
            const currentBridgeTo = bridgeToSelect.value;
            const currentShortItToken = shortItTokenSelect.value;
            const currentNftStakingSupplyToken = nftStakingSupplyTokenSelect.value;


            swapFromSelect.innerHTML = '';
            swapToSelect.innerHTML = '';
            bridgeFromSelect.innerHTML = '';
            bridgeToSelect.innerHTML = '';
            shortItTokenSelect.innerHTML = '<option value="">Select a launched token...</option>';
            nftStakingSupplyTokenSelect.innerHTML = '';


            allTokens.forEach(token => {
                const option1 = document.createElement('option');
                option1.value = token;
                option1.textContent = token;
                swapFromSelect.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = token;
                option2.textContent = token;
                swapToSelect.appendChild(option2);

                const option3 = document.createElement('option');
                option3.value = token;
                option3.textContent = token;
                bridgeFromSelect.appendChild(option3);

                const option4 = document.createElement('option');
                option4.value = token;
                option4.textContent = token;
                bridgeToSelect.appendChild(option4);

                // Add launched tokens to Short It select
                if (state.launchedTokens[token]) {
                    const optionShortIt = document.createElement('option');
                    optionShortIt.value = token;
                    optionShortIt.textContent = token;
                    shortItTokenSelect.appendChild(optionShortIt);
                }

                // Add all tokens to NFT staking supply select
                const optionNftStaking = document.createElement('option');
                optionNftStaking.value = token;
                optionNftStaking.textContent = token;
                nftStakingSupplyTokenSelect.appendChild(optionNftStaking);
            });

            // Re-apply previous selections or default
            swapFromSelect.value = currentSwapFrom && allTokens.includes(currentSwapFrom) ? currentSwapFrom : 'ETH';
            swapToSelect.value = currentSwapTo && allTokens.includes(currentSwapTo) ? currentSwapTo : 'USDC';
            bridgeFromSelect.value = currentBridgeFrom && allTokens.includes(currentBridgeFrom) ? currentBridgeFrom : 'ETH';
            bridgeToSelect.value = currentBridgeTo && allTokens.includes(currentBridgeTo) ? currentBridgeTo : 'USDC';
            shortItTokenSelect.value = currentShortItToken && Object.keys(state.launchedTokens).includes(currentShortItToken) ? currentShortItToken : '';
            nftStakingSupplyTokenSelect.value = currentNftStakingSupplyToken && allTokens.includes(currentNftStakingSupplyToken) ? currentNftStakingSupplyToken : 'USDC';


            // Ensure swap to is not same as swap from
            if (swapFromSelect.value === toTokenSwap.value && allTokens.length > 1) {
                const newToToken = allTokens.find(t => t !== swapFromSelect.value);
                if (newToToken) swapToSelect.value = newToToken;
            }
            if (bridgeFromSelect.value === bridgeToSelect.value && allTokens.length > 1) {
                const newToToken = allTokens.find(t => t !== bridgeFromSelect.value);
                if (newToToken) bridgeToSelect.value = newToToken;
            }
            updateShortItGameArea(); // Update short-it game area based on selection
        }


        function updateTransactionStatus(message, type = 'info') {
            transactionStatusMessage.innerHTML = message;
            transactionStatusMessage.className = 'transaction-status'; // Reset classes
            if (type === 'pending') {
                transactionStatusMessage.classList.add('text-yellow-400');
                transactionStatusMessage.innerHTML = `<div class="spinner mr-3"></div> ${message}`;
                triggerSlingshotAnimation(); // Trigger slingshot on pending
            } else if (type === 'success') {
                transactionStatusMessage.classList.add('text-green-400');
                transactionStatusMessage.classList.add('font-bold');
            } else if (type === 'error') {
                transactionStatusMessage.classList.add('text-red-400');
                transactionStatusMessage.classList.add('font-bold');
            } else { // info
                transactionStatusMessage.classList.add('text-gray-400');
            }
        }

        function addTransactionToHistory(tx) {
            state.transactionHistory.unshift(tx); // Add to beginning
            if (state.transactionHistory.length > 10) { // Keep history limited
                state.transactionHistory.pop();
            }
            renderTransactionHistory();
        }

        function renderTransactionHistory() {
            transactionHistoryDiv.innerHTML = '';
            if (state.transactionHistory.length === 0) {
                transactionHistoryDiv.innerHTML = '<p class="text-sm text-gray-500 text-center">No history yet.</p>';
                return;
            }
            state.transactionHistory.forEach(tx => {
                // Safely format numbers, display strings as-is
                const fromAmountDisplay = typeof tx.fromAmount === 'number' ? tx.fromAmount.toFixed(2) : tx.fromAmount || '';
                const toAmountDisplay = typeof tx.toAmount === 'number' ? tx.toAmount.toFixed(2) : tx.toAmount || '';

                let transactionDescription = '';
                switch (tx.type) {
                    case 'swap':
                        transactionDescription = `Swap ${fromAmountDisplay} ${tx.fromToken} for ${toAmountDisplay} ${tx.toToken}`;
                        break;
                    case 'bridge':
                        transactionDescription = `Bridge ${fromAmountDisplay} ${tx.fromToken} from ${tx.fromChain} to ${tx.toChain}`;
                        break;
                    case 'addLiquidity':
                        transactionDescription = `Add LP ${fromAmountDisplay} to ${tx.toToken}`;
                        break;
                    case 'removeLiquidity':
                        transactionDescription = `Remove LP ${fromAmountDisplay} from ${tx.fromToken} for ${toAmountDisplay}`;
                        break;
                    case 'claimFees':
                        transactionDescription = `Claim Fees $${toAmountDisplay} from ${tx.fromToken}`;
                        break;
                    case 'vote': // New transaction type
                        transactionDescription = `Voted ${tx.voteType} on "${tx.proposalTitle}" with ${fromAmountDisplay} GOV`;
                        break;
                    case 'stakeGOV':
                        transactionDescription = `Staked ${fromAmountDisplay} GOV in ${tx.poolName} Launch Pool`;
                        break;
                    case 'unstakeGOV':
                        transactionDescription = `Unstaked ${fromAmountDisplay} GOV from ${tx.poolName} Launch Pool`;
                        break;
                    case 'claimLaunchReward':
                        transactionDescription = `Claimed ${toAmountDisplay} ${tx.toToken} from ${tx.poolName} Launch Pool`;
                        break;
                    case 'contributeGenesis':
                        transactionDescription = `Contributed ${fromAmountDisplay} USDC to ${tx.tokenSymbol} Genesis Pool`;
                        break;
                    case 'claimGenesisTokens': // New
                        transactionDescription = `Claimed ${toAmountDisplay} ${tx.tokenSymbol} from Genesis Pool`;
                        break;
                    case 'stakeToken': // New
                        transactionDescription = `Staked ${fromAmountDisplay} ${tx.tokenSymbol} in Staking Pool`;
                        break;
                    case 'unstakeToken': // New
                        transactionDescription = `Unstaked ${fromAmountDisplay} ${tx.tokenSymbol} from Staking Pool`;
                        break;
                    case 'claimStakingReward': // New
                        transactionDescription = `Claimed ${toAmountDisplay} ${tx.tokenSymbol} from Staking Pool`;
                        break;
                    case 'shortItBet': // New
                        transactionDescription = `Bet ${fromAmountDisplay} ${tx.tokenSymbol} ${tx.direction} for ${tx.time}s`;
                        break;
                    case 'shortItResult': // New
                        transactionDescription = `Short It: ${tx.tokenSymbol} ${tx.result} - ${tx.wonAmount.toFixed(4)} ${tx.tokenSymbol}`;
                        break;
                    case 'launchNFT': // New
                        transactionDescription = `Launched NFT Collection: ${tx.collectionName} with token ${tx.tokenSymbol}`;
                        break;
                    case 'mintNFT': // New
                        transactionDescription = `Minted ${tx.nftName} (${tx.trait}) for ${tx.price.toFixed(2)} USDC`;
                        break;
                    case 'listNFT': // New
                        transactionDescription = `Listed NFT #${tx.nftId} for ${tx.price.toFixed(2)} ${tx.tokenSymbol}`;
                        break;
                    case 'buyNFT': // New
                        transactionDescription = `Bought NFT #${tx.nftId} for ${tx.price.toFixed(2)} ${tx.tokenSymbol}`;
                        break;
                    case 'claimNFTFees': // New
                        transactionDescription = `Claimed ${toAmountDisplay} ${tx.tokenSymbol} NFT fees`;
                        break;
                    case 'stakeNFT': // New
                        transactionDescription = `Staked NFT #${tx.nftId} from ${tx.collectionName}`;
                        break;
                    case 'unstakeNFT': // New
                        transactionDescription = `Unstaked NFT #${tx.nftId} from ${tx.collectionName}`;
                        break;
                    case 'claimNFTReward': // New
                        transactionDescription = `Claimed ${toAmountDisplay} ${tx.rewardToken} from NFT Staking`;
                        break;
                    case 'supplyNFTRewards': // New
                        transactionDescription = `Supplied ${fromAmountDisplay} ${tx.rewardToken} to NFT Staking Pool`;
                        break;
                    default:
                        transactionDescription = `Transaction: ${tx.type}`;
                }

                const txItem = document.createElement('div');
                txItem.className = `p-3 rounded-lg text-sm ${tx.status === 'success' ? 'bg-green-900/30 border-green-700' : tx.status === 'failed' ? 'bg-red-900/30 border-red-700' : 'bg-yellow-900/30 border-yellow-700'} border`;
                txItem.innerHTML = `
                    <p class="font-semibold text-white">${transactionDescription}</p>
                    <p class="text-xs text-gray-400">Status: <span class="${tx.status === 'success' ? 'text-green-300' : tx.status === 'failed' ? 'text-red-300' : 'text-yellow-300'}">${tx.status.charAt(0).toUpperCase() + tx.status.slice(1)}</span></p>
                    <p class="text-xs text-gray-500">${new Date(tx.timestamp).toLocaleString()}</p>
                `;
                transactionHistoryDiv.appendChild(txItem);
            });
        }

        function updatePortfolioTrackerUI() {
            let totalAssets = 0;
            let lpValue = 0;
            let govValue = 0;

            // Calculate value of token balances
            for (const token in state.balances) {
                if (token === 'USDC' || token === 'DAI') { // Assume USDC and DAI are $1
                    totalAssets += state.balances[token];
                } else if (state.exchangeRates[`${token}/USDC`]) {
                    totalAssets += state.balances[token] * state.exchangeRates[`${token}/USDC`];
                } else {
                    // Fallback for tokens without a direct USDC rate, e.g., new tokens before liquidity
                    // For simplicity, assume new tokens have 0 value until they have an exchange rate
                }
            }

            // Calculate value of LP positions
            for (const poolName in state.liquidityPools) {
                const pool = state.liquidityPools[poolName];
                if (pool.userLiquidityLP > 0 && pool.totalLP > 0) {
                    // Simple approximation: value of LP tokens is proportional to user's share of TVL
                    const userShare = pool.userLiquidityLP / pool.totalLP;
                    lpValue += userShare * pool.tvl;
                }
            }

            totalAssetsValue.textContent = `$${totalAssets.toFixed(2)}`;
            lpPositionsValue.textContent = `$${lpValue.toFixed(2)}`;
            earnedFeesValue.textContent = `$${state.totalEarnedFees.toFixed(2)}`;

            state.totalPortfolioValue = totalAssets + lpValue;
        }

        function renderLiquidityPoolsUI() {
            availablePoolsList.innerHTML = '';
            let hasUserLiquidity = false;

            // Sort pools alphabetically
            const sortedPoolNames = Object.keys(state.liquidityPools).sort();

            sortedPoolNames.forEach(poolName => {
                const pool = state.liquidityPools[poolName];
                // Only display pools that have some total liquidity or user liquidity
                if (pool.tvl > 0 || pool.userLiquidityLP > 0) {
                    const poolItem = document.createElement('div');
                    poolItem.className = 'pool-item flex-col items-start space-y-2';
                    poolItem.innerHTML = `
                        <div class="flex justify-between w-full">
                            <span class="text-white text-lg font-semibold">${poolName} Pool</span>
                            <span class="text-green-400 font-bold">${(pool.apr * 100).toFixed(2)}% APR</span>
                        </div>
                        <div class="flex justify-between w-full text-sm text-gray-400">
                            <span>TVL: <span class="text-white">$${pool.tvl.toFixed(2)}</span></span>
                            <span>Your LP: <span class="text-white">${pool.userLiquidityLP.toFixed(4)}</span></span>
                        </div>
                        <div class="flex justify-between w-full text-sm text-gray-400">
                            <span>Claimable Fees: <span class="text-yellow-300">$${pool.userFees.toFixed(4)}</span></span>
                            <span>Dev Rewards: <span class="text-purple-300">${pool.devRewards.toFixed(4)} ${pool.tokenA === 'USDC' ? pool.tokenB : pool.tokenA}</span></span>
                        </div>
                    `;
                    availablePoolsList.appendChild(poolItem);
                }

                if (pool.userLiquidityLP > 0) {
                    hasUserLiquidity = true;
                }
            });

            // Populate add liquidity pool select
            addLiquidityPoolSelect.innerHTML = '';
            sortedPoolNames.forEach(poolName => {
                const pool = state.liquidityPools[poolName];
                // Only allow adding to pools that exist or have some liquidity
                if (pool.tvl > 0 || pool.userLiquidityLP > 0) {
                     const option = document.createElement('option');
                    option.value = poolName;
                    option.textContent = poolName;
                    addLiquidityPoolSelect.appendChild(option);
                }
            });


            // Populate remove/claim pool selects
            removeLiquidityPoolSelect.innerHTML = '';
            claimFeesPoolSelect.innerHTML = '';
            if (!hasUserLiquidity) {
                removeLiquidityPoolSelect.innerHTML = '<option value="">No active LP positions</option>';
                claimFeesPoolSelect.innerHTML = '<option value="">No claimable fees</option>';
                removeLiquidityBtn.disabled = true;
                claimFeesBtn.disabled = true;
            } else {
                removeLiquidityBtn.disabled = false;
                claimFeesBtn.disabled = false;
                for (const poolName in state.liquidityPools) {
                    const pool = state.liquidityPools[poolName];
                    if (pool.userLiquidityLP > 0) {
                        const optionRemove = document.createElement('option');
                        optionRemove.value = poolName;
                        optionRemove.textContent = poolName;
                        removeLiquidityPoolSelect.appendChild(optionRemove);

                        const optionClaim = document.createElement('option');
                        optionClaim.value = poolName;
                        optionClaim.textContent = poolName;
                        claimFeesPoolSelect.appendChild(optionClaim);
                    }
                }
            }
            updateClaimableFeesDisplay();
            calculateAddLiquidityOutput(); // Recalculate for current selected pool
        }

        function updateClaimableFeesDisplay() {
            const selectedPoolName = claimFeesPoolSelect.value;
            if (selectedPoolName && state.liquidityPools[selectedPoolName]) {
                const pool = state.liquidityPools[selectedPoolName];
                const tokenSymbol = pool.tokenA === 'USDC' ? pool.tokenB : pool.tokenA; // The non-USDC token
                claimableFeesDisplay.textContent = `$${pool.userFees.toFixed(4)} (Fees) + ${pool.devRewards.toFixed(4)} ${tokenSymbol} (Dev Rewards)`;
            } else {
                claimableFeesDisplay.textContent = '0.00 USDC';
            }
        }

        function renderProposalsUI() {
            proposalsList.innerHTML = '';
            if (state.proposals.length === 0) {
                proposalsList.innerHTML = '<p class="text-sm text-gray-500 text-center">No active proposals at this time.</p>';
                return;
            }

            state.proposals.forEach(proposal => {
                const proposalItem = document.createElement('div');
                proposalItem.className = 'proposal-item bg-gray-800 p-5 rounded-lg border border-gray-700';

                const now = Date.now();
                const timeLeft = proposal.endsAt - now;
                const minutesLeft = Math.ceil(timeLeft / (60 * 1000));
                let statusText = '';
                let statusColor = 'text-gray-400';
                let canVote = state.isConnected && !proposal.hasVoted && proposal.status === 'active';

                if (proposal.status === 'active') {
                    statusText = `Ends in ${minutesLeft} mins`;
                    statusColor = 'text-yellow-400';
                } else if (proposal.status === 'passed') {
                    statusText = 'PASSED';
                    statusColor = 'text-green-400';
                    canVote = false;
                } else if (proposal.status === 'failed') {
                    statusText = 'FAILED';
                    statusColor = 'text-red-400';
                    canVote = false;
                }

                const totalVotes = proposal.votesYes + proposal.votesNo;
                const yesPercentage = totalVotes > 0 ? (proposal.votesYes / totalVotes * 100).toFixed(1) : 0;
                const noPercentage = totalVotes > 0 ? (proposal.votesNo / totalVotes * 100).toFixed(1) : 0;

                proposalItem.innerHTML = `
                    <h3 class="text-xl font-semibold text-white">${proposal.title}</h3>
                    <p class="text-sm text-gray-400">${proposal.description}</p>
                    <div class="flex justify-between w-full text-sm mt-2">
                        <span>Status: <span class="${statusColor}">${statusText}</span></span>
                        <span>Your Vote: <span class="${proposal.hasVoted ? 'text-blue-400' : 'text-gray-500'}">${proposal.hasVoted ? 'Voted' : 'Not Voted'}</span></span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-2.5 mt-2">
                        <div class="bg-green-500 h-2.5 rounded-full" style="width: ${yesPercentage}%"></div>
                    </div>
                    <div class="flex justify-between w-full text-sm text-gray-400 mt-1">
                        <span>Yes: ${proposal.votesYes} (${yesPercentage}%)</span>
                        <span>No: ${proposal.votesNo} (${noPercentage}%)</span>
                    </div>
                    <div class="vote-buttons w-full flex justify-end gap-3 mt-4">
                        <button class="vote-yes px-4 py-2 rounded-lg ${!canVote || state.userVotingPower <= 0 ? 'opacity-50 cursor-not-allowed' : ''}" data-id="${proposal.id}" data-type="yes" ${!canVote || state.userVotingPower <= 0 ? 'disabled' : ''}>Vote Yes</button>
                        <button class="vote-no px-4 py-2 rounded-lg ${!canVote || state.userVotingPower <= 0 ? 'opacity-50 cursor-not-allowed' : ''}" data-id="${proposal.id}" data-type="no" ${!canVote || state.userVotingPower <= 0 ? 'disabled' : ''}>Vote No</button>
                    </div>
                `;
                proposalsList.appendChild(proposalItem);
            });

            // Add event listeners for vote buttons
            proposalsList.querySelectorAll('.vote-buttons button').forEach(button => {
                button.addEventListener('click', handleVote);
            });
        }

        function renderLaunchpadUI() {
            genesisPoolsList.innerHTML = '';
            launchPoolsList.innerHTML = '';

            const activeGenesisPools = state.genesisPools.filter(p => p.status === 'genesis' || (p.status === 'launched' && p.userClaimableTokens > 0));
            const activeLaunchPools = state.launchPools.filter(p => p.status === 'active' || p.userStakedGOV > 0 || p.userEarnedTokens > 0);


            if (activeGenesisPools.length === 0) {
                genesisPoolsList.innerHTML = '<p class="text-sm text-gray-500 text-center">No active genesis pools.</p>';
            }
            if (activeLaunchPools.length === 0) {
                launchPoolsList.innerHTML = '<p class="text-sm text-gray-500 text-center">No active launch pools.</p>';
            }

            activeGenesisPools.forEach(pool => {
                const timeLeft = Math.max(0, Math.ceil((pool.launchTime - Date.now()) / 1000)); // seconds
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                const timeLeftStr = `${minutes}m ${seconds}s`;
                const canContribute = state.isConnected && state.balances.USDC > 0 && pool.status === 'genesis';
                const canClaimGenesis = state.isConnected && pool.status === 'launched' && pool.userClaimableTokens > 0;

                const genesisItem = document.createElement('div');
                genesisItem.className = 'genesis-pool-item bg-gray-800 p-5 rounded-lg border border-gray-700';
                genesisItem.innerHTML = `
                    <h3 class="text-xl font-semibold text-white">${pool.tokenSymbol} Launch</h3>
                    <p class="text-sm text-gray-400">Status: <span class="${pool.status === 'genesis' ? 'text-yellow-400' : 'text-green-400'}">${pool.status.toUpperCase()}</span></p>
                    <p class="text-sm text-gray-400">Time to Launch: <span class="text-yellow-400">${timeLeftStr}</span></p>
                    <p class="text-sm text-gray-400">Total Liquidity: <span class="text-white">$${pool.liquidityContributed.toFixed(2)}</span></p>
                    <p class="text-sm text-gray-400">Your Contribution: <span class="text-white">$${pool.userContribution.toFixed(2)}</span></p>
                    <p class="text-sm text-gray-400">Your Claimable ${pool.tokenSymbol}: <span class="text-yellow-300">${pool.userClaimableTokens.toFixed(4)}</span></p>
                    <div class="flex justify-end w-full gap-3 mt-4">
                        <input type="number" placeholder="USDC Amt" class="w-28 p-2 rounded-md bg-gray-700 text-white text-sm" id="contribute-usdc-amount-${pool.tokenSymbol}" ${pool.status === 'launched' ? 'disabled' : ''}>
                        <button class="max-button" data-input-id="contribute-usdc-amount-${pool.tokenSymbol}" data-balance-token="USDC" data-action-type="contributeGenesis" data-token-symbol="${pool.tokenSymbol}" ${pool.status === 'launched' ? 'disabled' : ''}>Max</button>
                        <button class="action-button px-4 py-2 text-sm ${!canContribute ? 'opacity-50 cursor-not-allowed' : ''}" data-id="${pool.tokenSymbol}" data-action="contribute" ${!canContribute ? 'disabled' : ''}>Contribute USDC</button>
                        <button class="action-button px-4 py-2 text-sm ${!canClaimGenesis ? 'opacity-50 cursor-not-allowed' : ''}" data-id="${pool.tokenSymbol}" data-action="claimGenesis" ${!canClaimGenesis ? 'disabled' : ''}>Claim ${pool.tokenSymbol}</button>
                    </div>
                `;
                genesisPoolsList.appendChild(genesisItem);
            });

            activeLaunchPools.forEach(pool => {
                const launchItem = document.createElement('div');
                launchItem.className = 'launch-pool-item bg-gray-800 p-5 rounded-lg border border-gray-700';
                const canStake = state.isConnected && pool.status === 'active' && state.balances.GOV > 0;
                const canUnstakeClaim = state.isConnected && pool.status === 'closed' && (pool.userStakedGOV > 0 || pool.userEarnedTokens > 0);

                launchItem.innerHTML = `
                    <h3 class="text-xl font-semibold text-white">${pool.tokenSymbol} Launch Pool</h3>
                    <p class="text-sm text-gray-400">Status: <span class="${pool.status === 'active' ? 'text-green-400' : 'text-red-400'}">${pool.status.toUpperCase()}</span></p>
                    <p class="text-sm text-gray-400">Total GOV Staked: <span class="text-white">${pool.stakedGOV.toFixed(2)}</span></p>
                    <p class="text-sm text-gray-400">Your Staked GOV: <span class="text-white">${pool.userStakedGOV.toFixed(2)}</span></p>
                    <p class="text-sm text-gray-400">Your Earned ${pool.tokenSymbol}: <span class="text-yellow-300">${pool.userEarnedTokens.toFixed(4)}</span></p>
                    <div class="flex justify-end w-full gap-3 mt-4">
                        <input type="number" placeholder="GOV Amt" class="w-24 p-2 rounded-md bg-gray-700 text-white text-sm" id="stake-gov-amount-${pool.tokenSymbol}" ${pool.status === 'closed' ? 'disabled' : ''}>
                        <button class="max-button" data-input-id="stake-gov-amount-${pool.tokenSymbol}" data-balance-token="GOV" data-action-type="stakeGOV" data-token-symbol="${pool.tokenSymbol}" ${pool.status === 'closed' ? 'disabled' : ''}>Max</button>
                        <button class="action-button px-4 py-2 text-sm ${!canStake ? 'opacity-50 cursor-not-allowed' : ''}" data-id="${pool.tokenSymbol}" data-action="stake" ${!canStake ? 'disabled' : ''}>Stake GOV</button>
                        <button class="action-button px-4 py-2 text-sm ${!canUnstakeClaim ? 'opacity-50 cursor-not-allowed' : ''}" data-id="${pool.tokenSymbol}" data-action="unstake" ${!canUnstakeClaim ? 'disabled' : ''}>Unstake & Claim</button>
                    </div>
                `;
                launchPoolsList.appendChild(launchItem);
            });

            // Add event listeners for new buttons
            genesisPoolsList.querySelectorAll('button[data-action="contribute"]').forEach(button => {
                button.addEventListener('click', handleContributeGenesis);
            });
            genesisPoolsList.querySelectorAll('button[data-action="claimGenesis"]').forEach(button => {
                button.addEventListener('click', handleClaimGenesisTokens);
            });
            launchPoolsList.querySelectorAll('button[data-action="stake"]').forEach(button => {
                button.addEventListener('click', handleStakeGOV);
            });
            launchPoolsList.querySelectorAll('button[data-action="unstake"]').forEach(button => {
                button.addEventListener('click', handleUnstakeClaimLaunchReward);
            });
            document.querySelectorAll('.max-button').forEach(button => {
                button.addEventListener('click', handleMaxButtonClick);
            });
        }

        function renderTokenInfoUI() {
            selectTokenInfo.innerHTML = '<option value="">Select a launched token...</option>';
            const launchedTokenSymbols = Object.keys(state.launchedTokens);

            // Add GOV token to the select options
            const govOption = document.createElement('option');
            govOption.value = 'GOV';
            govOption.textContent = 'GOV';
            selectTokenInfo.appendChild(govOption);

            launchedTokenSymbols.forEach(symbol => {
                const option = document.createElement('option');
                option.value = symbol;
                option.textContent = symbol;
                selectTokenInfo.appendChild(option);
            });

            // If a token is already selected, try to re-select it. Otherwise, select the first launched token.
            const currentSelectedSymbol = selectTokenInfo.value;
            if (currentSelectedSymbol && (launchedTokenSymbols.includes(currentSelectedSymbol) || currentSelectedSymbol === 'GOV')) {
                selectTokenInfo.value = currentSelectedSymbol;
            } else if (launchedTokenSymbols.length > 0) {
                selectTokenInfo.value = launchedTokenSymbols[0];
            } else {
                selectedTokenDetails.classList.add('hidden');
                return;
            }

            const selectedSymbol = selectTokenInfo.value;
            if (selectedSymbol) {
                selectedTokenDetails.classList.remove('hidden');
                let token;
                if (selectedSymbol === 'GOV') {
                    // Special handling for GOV token info
                    token = {
                        symbol: 'GOV',
                        name: 'Governance Token',
                        totalSupply: 10000000, // Fixed total supply for GOV
                        currentPrice: state.exchangeRates['GOV/USDC'],
                        marketCap: 10000000 * state.exchangeRates['GOV/USDC'],
                        liquidity: (state.liquidityPools['GOV-USDC'] ? state.liquidityPools['GOV-USDC'].tvl : 0) + (state.liquidityPools['ETH-GOV'] ? state.liquidityPools['ETH-GOV'].tvl : 0), // Sum of liquidity in GOV pairs
                        devHoldings: 1000000, // Example dev holdings for GOV
                        top10HoldersShare: 60, // Example top 10 holders for GOV
                        buyVolume: state.launchedTokens['GOV'] ? state.launchedTokens['GOV'].buyVolume : 0,
                        sellVolume: state.launchedTokens['GOV'] ? state.launchedTokens['GOV'].sellVolume : 0,
                        priceHistory: state.launchedTokens['GOV'] ? state.launchedTokens['GOV'].priceHistory : [state.exchangeRates['GOV/USDC']]
                    };
                    // Ensure GOV is in launchedTokens for volume/history tracking
                    if (!state.launchedTokens['GOV']) {
                        state.launchedTokens['GOV'] = {
                            symbol: 'GOV', name: 'Governance Token', totalSupply: 10000000, currentPrice: state.exchangeRates['GOV/USDC'],
                            marketCap: 10000000 * state.exchangeRates['GOV/USDC'], liquidity: 0, devHoldings: 1000000, top10HoldersShare: 60,
                            buyVolume: 0, sellVolume: 0, priceHistory: [state.exchangeRates['GOV/USDC']]
                        };
                    }

                } else {
                    token = state.launchedTokens[selectedSymbol];
                }

                tokenSymbolDisplay.textContent = token.symbol;
                tokenNameDisplay.textContent = token.name;
                tokenPriceDisplay.textContent = `$${token.currentPrice.toFixed(6)}`;
                tokenMarketCapDisplay.textContent = `$${token.marketCap.toFixed(2)}`;
                tokenSupplyDisplay.textContent = `${token.totalSupply.toFixed(2)}`;
                tokenLiquidityDisplay.textContent = `$${token.liquidity.toFixed(2)}`;
                tokenDevHoldingsDisplay.textContent = `${token.devHoldings.toFixed(2)} (${(token.devHoldings / token.totalSupply * 100).toFixed(2)}%)`;
                tokenTopHoldersDisplay.textContent = `${token.top10HoldersShare.toFixed(2)}%`;
                tokenBuyVolumeDisplay.textContent = `$${token.buyVolume.toFixed(2)}`;
                tokenSellVolumeDisplay.textContent = `$${token.sellVolume.toFixed(2)}`;

                renderTokenChart(token.priceHistory);
            } else {
                selectedTokenDetails.classList.add('hidden');
            }
        }

        function renderTokenChart(priceHistory) {
            tokenChartSVG.innerHTML = ''; // Clear previous chart
            if (priceHistory.length < 2) {
                tokenChartSVG.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#9ca3af" font-size="8">Not enough data for chart</text>';
                return;
            }

            const minPrice = Math.min(...priceHistory);
            const maxPrice = Math.max(...priceHistory);
            const priceRange = maxPrice - minPrice;

            // Adjust for zero price range to prevent division by zero
            const effectivePriceRange = priceRange === 0 ? 0.000001 : priceRange;


            const points = priceHistory.map((price, index) => {
                const x = (index / (priceHistory.length - 1)) * 100;
                const y = 100 - ((price - minPrice) / effectivePriceRange) * 100; // Invert Y for SVG coordinates
                return `${x},${y}`;
            }).join(' ');

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            path.setAttribute('points', points);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', '#8b5cf6');
            path.setAttribute('stroke-width', '2');
            tokenChartSVG.appendChild(path);

            // Add gradient fill below the line
            const gradientPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = `M${points.split(' ')[0]} L${points} L100,100 L0,100 Z`; // Close path to bottom
            gradientPath.setAttribute('d', d);
            gradientPath.setAttribute('fill', 'url(#chartGradient)');
            tokenChartSVG.appendChild(gradientPath);

            // Define gradient (ensure it's only added once or cleared)
            let defs = tokenChartSVG.querySelector('defs');
            if (!defs) {
                defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                tokenChartSVG.appendChild(defs);
            } else {
                defs.innerHTML = ''; // Clear existing defs
            }

            const linearGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            linearGradient.setAttribute('id', 'chartGradient');
            linearGradient.setAttribute('x1', '0%');
            linearGradient.setAttribute('y1', '0%');
            linearGradient.setAttribute('x2', '0%');
            linearGradient.setAttribute('y2', '100%');

            const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('stop-color', 'rgba(99, 102, 241, 0.5)');
            linearGradient.appendChild(stop1);

            const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop2.setAttribute('offset', '100%');
            stop2.setAttribute('stop-color', 'rgba(99, 102, 241, 0)');
            linearGradient.appendChild(stop2);

            defs.appendChild(linearGradient);
        }

        function renderStakingPoolsUI() {
            stakingPoolsList.innerHTML = '';
            const activeStakingPools = Object.values(state.stakingPools).filter(pool => pool.status === 'active' || pool.userStakedAmount > 0 || pool.userEarnedRewards > 0);

            if (activeStakingPools.length === 0) {
                stakingPoolsList.innerHTML = '<p class="text-sm text-gray-500 text-center">No active staking pools.</p>';
                return;
            }

            activeStakingPools.forEach(pool => {
                const canStake = state.isConnected && pool.status === 'active' && state.balances[pool.tokenSymbol] > 0;
                const canUnstakeClaim = state.isConnected && (pool.userStakedAmount > 0 || pool.userEarnedRewards > 0);

                const totalStakedValue = pool.stakedAmount * (state.exchangeRates[`${pool.tokenSymbol}/USDC`] || 0);
                const totalRewardValue = pool.totalRewardsDistributed * (state.exchangeRates[`${pool.tokenSymbol}/USDC`] || 0);
                const aprDisplay = totalStakedValue > 0 ? ((pool.totalRewardsDistributed / totalStakedValue) * 365 * 100).toFixed(2) : '0.00'; // Simplified APR based on total rewards vs. TVL

                const stakingItem = document.createElement('div');
                stakingItem.className = 'staking-pool-item bg-gray-800 p-5 rounded-lg border border-gray-700';
                stakingItem.innerHTML = `
                    <h3 class="text-xl font-semibold text-white">${pool.tokenSymbol} Staking Pool</h3>
                    <p class="text-sm text-gray-400">Status: <span class="${pool.status === 'active' ? 'text-green-400' : 'text-red-400'}">${pool.status.toUpperCase()}</span></p>
                    <p class="text-sm text-gray-400">APR: <span class="text-green-400 font-bold">${aprDisplay}%</span></p>
                    <p class="text-sm text-gray-400">Total Staked: <span class="text-white">${pool.stakedAmount.toFixed(2)} ${pool.tokenSymbol}</span></p>
                    <p class="text-sm text-gray-400">Your Staked: <span class="text-white">${pool.userStakedAmount.toFixed(2)} ${pool.tokenSymbol}</span></p>
                    <p class="text-sm text-gray-400">Your Earned: <span class="text-yellow-300">${pool.userEarnedRewards.toFixed(4)} ${pool.tokenSymbol}</span></p>
                    <p class="text-sm text-gray-400">% Supply Staked: <span class="text-white">${state.launchedTokens[pool.tokenSymbol] ? ((pool.stakedAmount / state.launchedTokens[pool.tokenSymbol].totalSupply) * 100).toFixed(2) : '0.00'}%</span></p>
                    <div class="flex justify-end w-full gap-3 mt-4">
                        <input type="number" placeholder="Amt" class="w-24 p-2 rounded-md bg-gray-700 text-white text-sm" id="stake-token-amount-${pool.tokenSymbol}" ${!canStake ? 'disabled' : ''}>
                        <button class="max-button" data-input-id="stake-token-amount-${pool.tokenSymbol}" data-balance-token="${pool.tokenSymbol}" data-action-type="stakeToken" data-token-symbol="${pool.tokenSymbol}" ${!canStake ? 'disabled' : ''}>Max</button>
                        <button class="action-button px-4 py-2 text-sm ${!canStake ? 'opacity-50 cursor-not-allowed' : ''}" data-id="${pool.tokenSymbol}" data-action="stakeToken" ${!canStake ? 'disabled' : ''}>Stake ${pool.tokenSymbol}</button>
                        <button class="action-button px-4 py-2 text-sm ${!canUnstakeClaim ? 'opacity-50 cursor-not-allowed' : ''}" data-id="${pool.tokenSymbol}" data-action="unstakeToken" ${!canUnstakeClaim ? 'disabled' : ''}>Unstake & Claim</button>
                    </div>
                `;
                stakingPoolsList.appendChild(stakingItem);
            });

            stakingPoolsList.querySelectorAll('button[data-action="stakeToken"]').forEach(button => {
                button.addEventListener('click', handleStakeToken);
            });
            stakingPoolsList.querySelectorAll('button[data-action="unstakeToken"]').forEach(button => {
                button.addEventListener('click', handleUnstakeClaimStakingReward);
            });
            document.querySelectorAll('.max-button').forEach(button => {
                button.addEventListener('click', handleMaxButtonClick);
            });
        }

        let shortItChartInterval;
        function updateShortItGameArea() {
            const selectedTokenSymbol = shortItTokenSelect.value;
            if (!selectedTokenSymbol || !state.launchedTokens[selectedTokenSymbol]) {
                shortItGameArea.classList.add('hidden');
                shortItTimerDisplay.textContent = '';
                clearInterval(shortItChartInterval);
                return;
            }

            shortItGameArea.classList.remove('hidden');
            const token = state.launchedTokens[selectedTokenSymbol];
            const shortItPool = state.shortItPools[selectedTokenSymbol] || { balance: 0, history: [] };
            state.shortItPools[selectedTokenSymbol] = shortItPool; // Ensure pool exists

            shortItCurrentPrice.textContent = `$${token.currentPrice.toFixed(6)}`;
            shortItPoolBalance.textContent = `${shortItPool.balance.toFixed(2)} ${selectedTokenSymbol}`;

            renderShortItChart(token.priceHistory);
            renderShortItHistory();

            // Clear previous interval if switching tokens
            clearInterval(shortItChartInterval);
            // Start interval to update chart for active token
            shortItChartInterval = setInterval(() => {
                renderShortItChart(state.launchedTokens[selectedTokenSymbol].priceHistory);
            }, 100); // Update chart more frequently for short-it
        }

        function renderShortItChart(priceHistory) {
            shortItChartContainer.innerHTML = ''; // Clear previous bars
            if (priceHistory.length < 2) return;

            const minPrice = Math.min(...priceHistory);
            const maxPrice = Math.max(...priceHistory);
            const priceRange = maxPrice - minPrice;
            const effectivePriceRange = priceRange === 0 ? 0.000001 : priceRange;

            const chartHeight = shortItChartContainer.clientHeight;

            priceHistory.forEach((price, index) => {
                const prevPrice = index > 0 ? priceHistory[index - 1] : price;
                const barHeight = ((price - minPrice) / effectivePriceRange) * chartHeight;
                const bar = document.createElement('div');
                bar.className = 'short-it-chart-bar';
                bar.style.height = `${Math.max(1, barHeight)}px`; // Ensure min height
                if (price > prevPrice) {
                    bar.classList.add('up');
                } else if (price < prevPrice) {
                    bar.classList.add('down');
                }
                shortItChartContainer.appendChild(bar);
            });
        }

        function renderShortItHistory() {
            shortItHistoryDiv.innerHTML = '';
            const userHistory = state.shortItHistory.filter(h => h.isUser);
            if (userHistory.length === 0) {
                shortItHistoryDiv.innerHTML = '<p class="text-sm text-gray-500 text-center">No bets yet.</p>';
                return;
            }

            userHistory.forEach(bet => {
                const historyItem = document.createElement('div');
                historyItem.className = `p-2 rounded-lg text-sm ${bet.result === 'WIN' ? 'bg-green-900/30 border-green-700' : bet.result === 'LOSS' ? 'bg-red-900/30 border-red-700' : 'bg-gray-700/30 border-gray-600'} border`;
                historyItem.innerHTML = `
                    <p class="font-semibold text-white">Bet ${bet.betAmount.toFixed(4)} ${bet.tokenSymbol} ${bet.direction.toUpperCase()} for ${bet.time}s</p>
                    <p class="text-xs text-gray-400">Result: <span class="${bet.result === 'WIN' ? 'text-green-300' : bet.result === 'LOSS' ? 'text-red-300' : 'text-yellow-300'}">${bet.result}</span></p>
                    <p class="text-xs text-gray-500">Gain/Loss: ${bet.wonAmount.toFixed(4)} ${bet.tokenSymbol}</p>
                `;
                shortItHistoryDiv.appendChild(historyItem);
            });
        }

        function renderNFTUI() {
            if (state.myNFTCollection) {
                nftLaunchSection.classList.add('hidden');
                nftCollectionInfo.classList.remove('hidden');

                const collection = state.myNFTCollection;
                myNftCollectionNameDisplay.textContent = collection.name;
                myNftFloorPriceDisplay.textContent = `$${collection.floorPrice.toFixed(2)}`;
                myNftTotalMintedDisplay.textContent = collection.totalMinted;
                myNftOwnedDisplay.textContent = state.myNFTs.filter(nft => nft.owner === 'user').length;
                myNftClaimableFeesDisplay.textContent = collection.userClaimableFees.toFixed(4);
                myNftTokenSymbolDisplay.textContent = collection.tokenSymbol;

                // Populate NFT staking reward token options
                nftStakingSupplyTokenSelect.innerHTML = '';
                Object.keys(state.balances).forEach(token => {
                    const option = document.createElement('option');
                    option.value = token;
                    option.textContent = token;
                    nftStakingSupplyTokenSelect.appendChild(option);
                });
                nftStakingSupplyTokenSelect.value = collection.tokenSymbol; // Default to collection token

                // NFT Staking Pool Info
                if (state.nftStakingPool) {
                    const stakingPool = state.nftStakingPool;
                    nftStakingTotalStakedDisplay.textContent = stakingPool.totalStakedNFTs;
                    nftStakingUserStakedDisplay.textContent = stakingPool.userStakedNFTs.length;
                    nftStakingUserEarnedDisplay.textContent = stakingPool.userEarnedRewards.toFixed(4);
                    nftStakingRewardTokenDisplay.textContent = stakingPool.rewardToken;
                    nftStakingDevSuppliedRewardsDisplay.textContent = stakingPool.devSuppliedRewards.toFixed(4);
                    nftStakingRewardTokenDevDisplay.textContent = stakingPool.rewardToken;
                } else {
                    nftStakingTotalStakedDisplay.textContent = '0';
                    nftStakingUserStakedDisplay.textContent = '0';
                    nftStakingUserEarnedDisplay.textContent = '0.00';
                    nftStakingRewardTokenDisplay.textContent = 'N/A';
                    nftStakingDevSuppliedRewardsDisplay.textContent = '0.00';
                    nftStakingRewardTokenDevDisplay.textContent = 'N/A';
                }


                renderNFTMarketplace();
                renderMyStakedNFTs();

            } else {
                nftLaunchSection.classList.remove('hidden');
                nftCollectionInfo.classList.add('hidden');
            }
        }

        function renderNFTMarketplace() {
            nftMarketplaceList.innerHTML = '';
            const listedNFTs = state.nftMarketplaceListings.filter(nft => nft.isListed);

            if (listedNFTs.length === 0) {
                nftMarketplaceList.innerHTML = '<p class="text-sm text-gray-500 text-center col-span-full">No NFTs listed for sale.</p>';
                return;
            }

            listedNFTs.forEach(nft => {
                const nftCard = document.createElement('div');
                nftCard.className = 'nft-card bg-gray-700 p-3 rounded-lg border border-gray-600';
                const canBuy = state.isConnected && state.balances[state.myNFTCollection.tokenSymbol] >= nft.price;

                nftCard.innerHTML = `
                    <img src="${nft.imageUrl}" alt="${nft.name}" onerror="this.onerror=null;this.src='https://placehold.co/100x100/3d5a80/e0e0e0?text=NFT'">
                    <p class="font-semibold text-white">${nft.name}</p>
                    <p class="nft-trait">${nft.trait}</p>
                    <p class="text-gray-400">${nft.price.toFixed(2)} ${state.myNFTCollection.tokenSymbol}</p>
                    <button class="action-button px-3 py-1 text-xs mt-2 ${!canBuy ? 'opacity-50 cursor-not-allowed' : ''}" data-id="${nft.id}" data-action="buyNFT" ${!canBuy ? 'disabled' : ''}>Buy</button>
                `;
                nftMarketplaceList.appendChild(nftCard);
            });

            nftMarketplaceList.querySelectorAll('button[data-action="buyNFT"]').forEach(button => {
                button.addEventListener('click', handleBuyNFT);
            });
        }

        function renderMyStakedNFTs() {
            myStakedNftsList.innerHTML = '';
            const userStakedNFTs = state.myNFTs.filter(nft => nft.owner === 'user' && nft.isStaked);

            if (userStakedNFTs.length === 0) {
                myStakedNftsList.innerHTML = '<p class="text-sm text-gray-500 text-center col-span-full">No NFTs staked.</p>';
                return;
            }

            userStakedNFTs.forEach(nft => {
                const nftCard = document.createElement('div');
                nftCard.className = 'nft-card bg-gray-700 p-3 rounded-lg border border-gray-600';
                nftCard.innerHTML = `
                    <img src="${nft.imageUrl}" alt="${nft.name}" onerror="this.onerror=null;this.src='https://placehold.co/100x100/3d5a80/e0e0e0?text=NFT'">
                    <p class="font-semibold text-white">${nft.name}</p>
                    <p class="nft-trait">${nft.trait}</p>
                `;
                myStakedNftsList.appendChild(nftCard);
            });
        }


        function renderDashboardUI() {
            let totalTVL = 0;
            let totalAPR = 0;
            let activePoolCount = 0;

            for (const poolName in state.liquidityPools) {
                const pool = state.liquidityPools[poolName];
                totalTVL += pool.tvl;
                if (pool.tvl > 0) { // Only count pools with liquidity for average APR
                    totalAPR += pool.apr;
                    activePoolCount++;
                }
            }

            state.totalPlatformTVL = totalTVL;
            // state.totalPlatformRevenue is updated directly in transaction handlers
            // state.totalTradingVolume is updated directly in transaction handlers
            state.totalLaunchedTokensCount = Object.keys(state.launchedTokens).length;
            state.averagePoolAPR = activePoolCount > 0 ? totalAPR / activePoolCount : 0;

            dashboardTVL.textContent = `$${state.totalPlatformTVL.toFixed(2)}`;
            dashboardRevenue.textContent = `$${state.totalPlatformRevenue.toFixed(2)}`;
            dashboardVolume.textContent = `$${state.totalTradingVolume.toFixed(2)}`;
            dashboardLaunchedTokens.textContent = state.totalLaunchedTokensCount;
            dashboardAvgAPR.textContent = `${(state.averagePoolAPR * 100).toFixed(2)}%`;
        }


        // --- Core Logic ---

        function calculateSwapOutput() {
            const from = fromTokenSwap.value;
            const to = toTokenSwap.value;
            const amount = parseFloat(fromAmountSwap.value);

            if (isNaN(amount) || amount <= 0) {
                toAmountSwap.value = '0.0';
                return;
            }

            const rateKey = `${from}/${to}`;
            let rate = state.exchangeRates[rateKey];

            if (!rate) {
                toAmountSwap.value = 'N/A';
                console.error(`No exchange rate found for ${from}/${to}`);
                return;
            }

            let estimatedOutput = amount * rate;

            // Simulate price impact for user swaps on launched tokens
            if (state.launchedTokens[from] || state.launchedTokens[to]) {
                const liquidityPool = state.liquidityPools[`${from}-USDC`] || state.liquidityPools[`${to}-USDC`]; // Simplified to USDC pair
                if (liquidityPool && liquidityPool.tvl > 0) {
                    const priceImpactFactor = amount / liquidityPool.tvl; // Simple impact based on swap size vs. TVL
                    if (from === liquidityPool.tokenA) { // Selling tokenA for tokenB (USDC)
                        rate *= (1 - priceImpactFactor * 0.1); // Price goes down
                    } else if (from === liquidityPool.tokenB) { // Selling tokenB (USDC) for tokenA
                        rate *= (1 + priceImpactFactor * 0.1); // Price goes up
                    }
                    estimatedOutput = amount * rate;
                }
            }


            // Apply slippage (randomly reduce output by up to slippagePercentage)
            const actualSlippage = Math.random() * state.slippagePercentage / 100;
            estimatedOutput *= (1 - actualSlippage);

            toAmountSwap.value = estimatedOutput.toFixed(4);
            gasFeeSwapDisplay.textContent = `${state.gasFeeEth.toFixed(4)} ETH`;
        }

        function calculateBridgeOutput() {
            const from = fromTokenBridge.value;
            const to = toTokenBridge.value;
            const amount = parseFloat(fromAmountBridge.value);
            const fromChain = fromChainBridge.value;
            const toChain = toChainBridge.value;

            if (isNaN(amount) || amount <= 0) {
                toAmountBridge.value = '0.0';
                return;
            }

            // For simplicity, assume 1:1 bridge for same token, minus fee
            let estimatedOutput = amount;

            // Simulate bridge fee deduction (always in ETH for simplicity, convert if needed)
            const feeInFromToken = state.bridgeFeeEth; // Simplified: assume 1 ETH = 1 unit of token for fee calculation
            estimatedOutput -= feeInFromToken;

            if (estimatedOutput < 0) estimatedOutput = 0; // Cannot receive negative

            toAmountBridge.value = estimatedOutput.toFixed(4);
            bridgeFeeDisplay.textContent = `${state.bridgeFeeEth.toFixed(4)} ETH`;
            bridgeTimeDisplay.textContent = `~${state.bridgeTimeMinutes} mins`;
        }

        function calculateAddLiquidityOutput() {
            const poolName = addLiquidityPoolSelect.value;
            if (!poolName || !state.liquidityPools[poolName]) {
                addLiquidityAmountB.value = '0.0';
                addLiquidityTokenADisplay.textContent = 'Token A';
                addLiquidityTokenBDisplay.textContent = 'Token B';
                return;
            }

            const pool = state.liquidityPools[poolName];
            const amountA = parseFloat(addLiquidityAmountA.value);

            addLiquidityTokenADisplay.textContent = pool.tokenA;
            addLiquidityTokenBDisplay.textContent = pool.tokenB;

            if (isNaN(amountA) || amountA <= 0) {
                addLiquidityAmountB.value = '0.0';
                return;
            }

            // Get exchange rate for the pair
            const rateKey = `${pool.tokenA}/${pool.tokenB}`;
            const rate = state.exchangeRates[rateKey];

            if (!rate) {
                addLiquidityAmountB.value = 'N/A';
                console.warn(`No exchange rate found for ${rateKey}. Cannot estimate Token B amount.`);
                return;
            }
            const estimatedAmountB = amountA * rate;

            addLiquidityAmountB.value = estimatedAmountB.toFixed(4);
        }

        async function handleSwap() {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet first.', 'error');
                return;
            }

            const fromToken = fromTokenSwap.value;
            const toToken = toTokenSwap.value;
            const amount = parseFloat(fromAmountSwap.value);
            const gasFee = state.gasFeeEth;

            if (isNaN(amount) || amount <= 0) {
                updateTransactionStatus('Please enter a valid amount to swap.', 'error');
                return;
            }
            if (fromToken === toToken) {
                updateTransactionStatus('Cannot swap a token for itself. Please select different tokens.', 'error');
                return;
            }
            if (!state.balances[fromToken] || state.balances[fromToken] < amount) {
                updateTransactionStatus(`Insufficient ${fromToken} balance.`, 'error');
                return;
            }
            if (state.balances.ETH < gasFee) { // Check ETH for gas
                updateTransactionStatus('Insufficient ETH for gas fee.', 'error');
                return;
            }

            // Recalculate output right before transaction to include latest price impact
            calculateSwapOutput();
            const receivedAmount = parseFloat(toAmountSwap.value);
            if (isNaN(receivedAmount) || receivedAmount <= 0) {
                 updateTransactionStatus('Unable to calculate received amount. Please check token selection or amount.', 'error');
                 return;
            }


            updateTransactionStatus('Swapping tokens... Pending confirmation.', 'pending');
            swapBtn.disabled = true;
            swapBtn.innerHTML = '<div class="spinner"></div> Swapping...';

            // Simulate network delay
            await new Promise(resolve => setTimeout(resolve, 3000));

            const success = Math.random() > 0.1; // 90% chance of success

            if (success) {
                state.balances[fromToken] -= amount;
                state.balances['ETH'] -= gasFee; // Always deduct gas from ETH for simplicity
                state.balances[toToken] = (state.balances[toToken] || 0) + receivedAmount; // Ensure token exists

                // Simulate platform revenue and volume
                const swapValueUSDC = amount * (state.exchangeRates[`${fromToken}/USDC`] || 1);
                state.totalTradingVolume += swapValueUSDC;
                state.totalPlatformRevenue += swapValueUSDC * 0.0005; // 0.05% swap fee

                // Update buy/sell volume for relevant token
                if (state.launchedTokens[fromToken]) {
                    state.launchedTokens[fromToken].sellVolume += swapValueUSDC;
                }
                if (state.launchedTokens[toToken]) {
                    state.launchedTokens[toToken].buyVolume += swapValueUSDC;
                }

                updateBalancesUI();
                updatePortfolioTrackerUI();
                updateTransactionStatus(`Swap successful! Received ${receivedAmount.toFixed(4)} ${toToken}.`, 'success');
                addTransactionToHistory({
                    type: 'swap',
                    fromToken,
                    toToken,
                    fromAmount: amount,
                    toAmount: receivedAmount,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect(); // Visual burst on success
            } else {
                updateTransactionStatus('Swap failed! Please try again.', 'error');
                addTransactionToHistory({
                    type: 'swap',
                    fromToken,
                    toToken,
                    fromAmount: amount,
                    toAmount: receivedAmount,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }

            swapBtn.disabled = false;
            swapBtn.innerHTML = 'Swap';
            fromAmountSwap.value = ''; // Clear input
            toAmountSwap.value = '0.0';
        }

        async function handleBridge() {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet first.', 'error');
                return;
            }

            const fromChain = fromChainBridge.value;
            const toChain = toChainBridge.value;
            const fromToken = fromTokenBridge.value;
            const toToken = toTokenBridge.value;
            const amount = parseFloat(fromAmountBridge.value);
            const receivedAmount = parseFloat(toAmountBridge.value);
            const bridgeFee = state.gasFeeEth; // Using gasFeeEth as bridge fee for simplicity

            if (isNaN(amount) || amount <= 0) {
                updateTransactionStatus('Please enter a valid amount to bridge.', 'error');
                return;
            }
            if (fromChain === toChain) {
                updateTransactionStatus('Cannot bridge to the same chain. Please select different chains.', 'error');
                return;
            }
            if (!state.balances[fromToken] || state.balances[fromToken] < amount) {
                updateTransactionStatus(`Insufficient ${fromToken} balance on ${fromChain}.`, 'error');
                return;
            }
            if (state.balances.ETH < bridgeFee) { // Check ETH for bridge fee
                updateTransactionStatus('Insufficient ETH for bridge fee.', 'error');
                return;
            }


            updateTransactionStatus(`Bridging ${amount.toFixed(2)} ${fromToken} from ${fromChain} to ${toChain}... Est. ${state.bridgeTimeMinutes} mins.`, 'pending');
            bridgeBtn.disabled = true;
            bridgeBtn.innerHTML = '<div class="spinner"></div> Bridging...';

            // Simulate network delay for bridge
            await new Promise(resolve => setTimeout(resolve, state.bridgeTimeMinutes * 1000 * 0.5)); // Half time for pending

            const success = Math.random() > 0.15; // 85% chance of success

            if (success) {
                state.balances[fromToken] -= amount;
                state.balances['ETH'] -= bridgeFee; // Always deduct fee from ETH for simplicity
                // Simulate receiving token on target chain (just add to balance)
                state.balances[toToken] = (state.balances[toToken] || 0) + receivedAmount;

                // Simulate platform revenue and volume
                const bridgeValueUSDC = amount * (state.exchangeRates[`${fromToken}/USDC`] || 1);
                state.totalTradingVolume += bridgeValueUSDC;
                state.totalPlatformRevenue += bridgeValueUSDC * 0.0005; // 0.05% bridge fee

                updateBalancesUI();
                updatePortfolioTrackerUI();
                updateTransactionStatus(`Bridge successful! Received ${receivedAmount.toFixed(4)} ${toToken} on ${toChain}.`, 'success');
                addTransactionToHistory({
                    type: 'bridge',
                    fromChain,
                    toChain,
                    fromToken,
                    toToken,
                    fromAmount: amount,
                    toAmount: receivedAmount,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect(); // Visual burst on success
            } else {
                updateTransactionStatus('Bridge failed! Please try again.', 'error');
                addTransactionToHistory({
                    type: 'bridge',
                    fromChain,
                    toChain,
                    fromToken,
                    toToken,
                    fromAmount: amount,
                    toAmount: receivedAmount,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }

            bridgeBtn.disabled = false;
            bridgeBtn.innerHTML = 'Bridge';
            fromAmountBridge.value = ''; // Clear input
            toAmountBridge.value = '0.0';
        }

        async function handleAddLiquidity() {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet first.', 'error');
                return;
            }

            const poolName = addLiquidityPoolSelect.value;
            const pool = state.liquidityPools[poolName];
            const amountA = parseFloat(addLiquidityAmountA.value);
            const amountB = parseFloat(addLiquidityAmountB.value); // This is estimated, we'll use it for simulation

            if (isNaN(amountA) || amountA <= 0 || isNaN(amountB) || amountB <= 0) {
                updateTransactionStatus('Please enter valid amounts for liquidity.', 'error');
                return;
            }
            if (!state.balances[pool.tokenA] || state.balances[pool.tokenA] < amountA || !state.balances[pool.tokenB] || state.balances[pool.tokenB] < amountB) {
                updateTransactionStatus(`Insufficient balance for ${pool.tokenA} or ${pool.tokenB}.`, 'error');
                return;
            }

            updateTransactionStatus(`Adding liquidity to ${poolName} pool...`, 'pending');
            addLiquidityBtn.disabled = true;
            addLiquidityBtn.innerHTML = '<div class="spinner"></div> Adding...';

            await new Promise(resolve => setTimeout(resolve, 3000));

            const success = Math.random() > 0.1; // 90% chance of success

            if (success) {
                state.balances[pool.tokenA] -= amountA;
                state.balances[pool.tokenB] -= amountB;

                // Simulate receiving LP tokens (simple 1 LP token per $1000 TVL added)
                const lpTokensReceived = (amountA * (state.exchangeRates[`${pool.tokenA}/USDC`] || 1) + amountB * (state.exchangeRates[`${pool.tokenB}/USDC`] || 1)) / 1000;
                pool.userLiquidityLP += lpTokensReceived;
                pool.totalLP += lpTokensReceived; // Update total LP tokens in pool
                pool.tvl += (amountA * (state.exchangeRates[`${pool.tokenA}/USDC`] || 1) + amountB * (state.exchangeRates[`${pool.tokenB}/USDC`] || 1));

                // Platform revenue from adding liquidity
                const addLiquidityValueUSDC = amountA * (state.exchangeRates[`${pool.tokenA}/USDC`] || 1) + amountB * (state.exchangeRates[`${pool.tokenB}/USDC`] || 1);
                state.totalPlatformRevenue += addLiquidityValueUSDC * 0.0005; // 0.05% fee on liquidity adds

                updateBalancesUI();
                renderLiquidityPoolsUI();
                updatePortfolioTrackerUI();
                updateTransactionStatus(`Successfully added liquidity to ${poolName}. Received ${lpTokensReceived.toFixed(4)} LP tokens.`, 'success');
                addTransactionToHistory({
                    type: 'addLiquidity',
                    fromToken: `${pool.tokenA} & ${pool.tokenB}`,
                    fromAmount: `${amountA.toFixed(2)} & ${amountB.toFixed(2)}`,
                    toToken: 'LP',
                    toAmount: lpTokensReceived,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus('Failed to add liquidity. Please try again.', 'error');
                addTransactionToHistory({
                    type: 'addLiquidity',
                    fromToken: `${pool.tokenA} & ${pool.tokenB}`,
                    fromAmount: `${amountA.toFixed(2)} & ${amountB.toFixed(2)}`,
                    toToken: 'LP',
                    toAmount: 0,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            addLiquidityBtn.disabled = false;
            addLiquidityBtn.innerHTML = 'Add Liquidity';
            addLiquidityAmountA.value = '';
            addLiquidityAmountB.value = '0.0';
        }

        async function handleRemoveLiquidity() {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet first.', 'error');
                return;
            }

            const poolName = removeLiquidityPoolSelect.value;
            const pool = state.liquidityPools[poolName];
            const lpAmount = parseFloat(removeLiquidityAmountLP.value);

            if (!poolName || !pool) {
                updateTransactionStatus('Please select a pool to remove liquidity from.', 'error');
                return;
            }
            if (isNaN(lpAmount) || lpAmount <= 0) {
                updateTransactionStatus('Please enter a valid amount of LP tokens to remove.', 'error');
                return;
            }
            if (pool.userLiquidityLP < lpAmount) {
                updateTransactionStatus(`Insufficient LP tokens in ${poolName} pool.`, 'error');
                return;
            }

            updateTransactionStatus(`Removing ${lpAmount.toFixed(4)} LP from ${poolName} pool...`, 'pending');
            removeLiquidityBtn.disabled = true;
            removeLiquidityBtn.innerHTML = '<div class="spinner"></div> Removing...';

            await new Promise(resolve => setTimeout(resolve, 3000));

            const success = Math.random() > 0.1; // 90% chance of success

            if (success) {
                const userShare = lpAmount / pool.userLiquidityLP; // Share of user's current LP
                const tokenAReceived = (pool.tvl / 2) * userShare / (state.exchangeRates[`${pool.tokenA}/USDC`] || 1); // Simplified
                const tokenBReceived = (pool.tvl / 2) * userShare / (state.exchangeRates[`${pool.tokenB}/USDC`] || 1); // Simplified

                state.balances[pool.tokenA] = (state.balances[pool.tokenA] || 0) + tokenAReceived;
                state.balances[pool.tokenB] = (state.balances[pool.tokenB] || 0) + tokenBReceived;
                pool.userLiquidityLP -= lpAmount;
                pool.totalLP -= lpAmount;
                pool.tvl -= (tokenAReceived * (state.exchangeRates[`${pool.tokenA}/USDC`] || 1) + tokenBReceived * (state.exchangeRates[`${pool.tokenB}/USDC`] || 1));

                // Platform revenue from removing liquidity
                const removeLiquidityValueUSDC = tokenAReceived * (state.exchangeRates[`${pool.tokenA}/USDC`] || 1) + tokenBReceived * (state.exchangeRates[`${pool.tokenB}/USDC`] || 1);
                state.totalPlatformRevenue += removeLiquidityValueUSDC * 0.0005; // 0.05% fee on liquidity removes


                updateBalancesUI();
                renderLiquidityPoolsUI();
                updatePortfolioTrackerUI();
                updateTransactionStatus(`Successfully removed liquidity from ${poolName}. Received ${tokenAReceived.toFixed(4)} ${pool.tokenA} and ${tokenBReceived.toFixed(4)} ${pool.tokenB}.`, 'success');
                addTransactionToHistory({
                    type: 'removeLiquidity',
                    fromToken: 'LP',
                    fromAmount: lpAmount,
                    toToken: `${pool.tokenA} & ${pool.tokenB}`,
                    toAmount: `${tokenAReceived.toFixed(2)} & ${tokenBReceived.toFixed(2)}`,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus('Failed to remove liquidity. Please try again.', 'error');
                addTransactionToHistory({
                    type: 'removeLiquidity',
                    fromToken: 'LP',
                    fromAmount: lpAmount,
                    toToken: '',
                    toAmount: 0,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            removeLiquidityBtn.disabled = false;
            removeLiquidityBtn.innerHTML = 'Remove Liquidity';
            removeLiquidityAmountLP.value = '';
        }

        async function handleClaimFees() {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet first.', 'error');
                return;
            }

            const poolName = claimFeesPoolSelect.value;
            const pool = state.liquidityPools[poolName];

            if (!poolName || !pool) {
                updateTransactionStatus('Please select a pool to claim fees from.', 'error');
                return;
            }
            if (pool.userFees <= 0 && pool.devRewards <= 0) {
                updateTransactionStatus('No claimable fees or dev rewards for this pool.', 'error');
                return;
            }

            updateTransactionStatus(`Claiming fees and rewards from ${poolName} pool...`, 'pending');
            claimFeesBtn.disabled = true;
            claimFeesBtn.innerHTML = '<div class="spinner"></div> Claiming...';

            await new Promise(resolve => setTimeout(resolve, 2000));

            const success = Math.random() > 0.05; // 95% chance of success

            if (success) {
                const claimedFeesUSDC = pool.userFees;
                const claimedDevRewards = pool.devRewards;
                const tokenSymbol = pool.tokenA === 'USDC' ? pool.tokenB : pool.tokenA; // The non-USDC token

                state.balances['USDC'] += claimedFeesUSDC; // Assume fees are claimed in USDC for simplicity
                state.balances[tokenSymbol] = (state.balances[tokenSymbol] || 0) + claimedDevRewards; // Claim dev rewards in the token itself

                state.totalEarnedFees += claimedFeesUSDC; // Only USDC fees count towards general earned fees
                state.totalPlatformRevenue += claimedFeesUSDC; // Add claimed fees to platform revenue

                pool.userFees = 0; // Reset fees for the user in this pool
                pool.devRewards = 0; // Reset dev rewards for the user in this pool

                updateBalancesUI();
                renderLiquidityPoolsUI();
                updatePortfolioTrackerUI();
                updateTransactionStatus(`Successfully claimed $${claimedFeesUSDC.toFixed(4)} (Fees) and ${claimedDevRewards.toFixed(4)} ${tokenSymbol} (Dev Rewards) from ${poolName}.`, 'success');
                addTransactionToHistory({
                    type: 'claimFees',
                    fromToken: poolName,
                    fromAmount: 0,
                    toToken: `USDC & ${tokenSymbol}`,
                    toAmount: `${claimedFeesUSDC.toFixed(2)} & ${claimedDevRewards.toFixed(2)}`,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus('Failed to claim fees. Please try again.', 'error');
                addTransactionToHistory({
                    type: 'claimFees',
                    fromToken: poolName,
                    fromAmount: 0,
                    toToken: 'USDC',
                    toAmount: 0,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            claimFeesBtn.disabled = false;
            claimFeesBtn.innerHTML = 'Claim Fees';
        }

        async function handleContributeGenesis(event) {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet to contribute.', 'error');
                return;
            }
            const tokenSymbol = event.target.dataset.id;
            const inputElement = document.getElementById(`contribute-usdc-amount-${tokenSymbol}`);
            const amount = parseFloat(inputElement.value);
            const genesisPool = state.genesisPools.find(p => p.tokenSymbol === tokenSymbol);

            if (isNaN(amount) || amount <= 0) {
                updateTransactionStatus('Please enter a valid amount to contribute.', 'error');
                return;
            }
            if (!genesisPool || genesisPool.status !== 'genesis') {
                updateTransactionStatus('This genesis pool is not active for contributions.', 'error');
                return;
            }
            if (state.balances.USDC < amount) {
                updateTransactionStatus('Insufficient USDC balance.', 'error');
                return;
            }

            updateTransactionStatus(`Contributing ${amount.toFixed(2)} USDC to ${tokenSymbol} Genesis Pool...`, 'pending');
            event.target.disabled = true;
            event.target.innerHTML = '<div class="spinner"></div> Contributing...';

            await new Promise(resolve => setTimeout(resolve, 2000));

            const success = Math.random() > 0.1;

            if (success) {
                state.balances.USDC -= amount;
                genesisPool.userContribution += amount;
                genesisPool.liquidityContributed += amount; // User contribution adds to total liquidity

                updateBalancesUI();
                renderLaunchpadUI();
                updatePortfolioTrackerUI();
                updateTransactionStatus(`Successfully contributed ${amount.toFixed(2)} USDC to ${tokenSymbol} Genesis Pool.`, 'success');
                addTransactionToHistory({
                    type: 'contributeGenesis',
                    tokenSymbol: tokenSymbol,
                    fromAmount: amount,
                    fromToken: 'USDC',
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus(`Failed to contribute to ${tokenSymbol} Genesis Pool.`, 'error');
                addTransactionToHistory({
                    type: 'contributeGenesis',
                    tokenSymbol: tokenSymbol,
                    fromAmount: amount,
                    fromToken: 'USDC',
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            event.target.disabled = false;
            event.target.innerHTML = 'Contribute USDC';
            inputElement.value = '';
        }

        async function handleClaimGenesisTokens(event) {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet to claim tokens.', 'error');
                return;
            }
            const tokenSymbol = event.target.dataset.id;
            const genesisPool = state.genesisPools.find(p => p.tokenSymbol === tokenSymbol);

            if (!genesisPool || genesisPool.status !== 'launched' || genesisPool.userClaimableTokens <= 0) {
                updateTransactionStatus('No tokens to claim from this Genesis Pool, or it\'s not launched.', 'error');
                return;
            }

            updateTransactionStatus(`Claiming ${genesisPool.userClaimableTokens.toFixed(4)} ${tokenSymbol} from Genesis Pool...`, 'pending');
            event.target.disabled = true;
            event.target.innerHTML = '<div class="spinner"></div> Claiming...';

            await new Promise(resolve => setTimeout(resolve, 2000));

            const success = Math.random() > 0.05;

            if (success) {
                state.balances[tokenSymbol] = (state.balances[tokenSymbol] || 0) + genesisPool.userClaimableTokens;
                const claimedAmount = genesisPool.userClaimableTokens;
                genesisPool.userClaimableTokens = 0; // Reset after claiming

                updateBalancesUI();
                renderLaunchpadUI();
                updatePortfolioTrackerUI();
                updateTransactionStatus(`Successfully claimed ${claimedAmount.toFixed(4)} ${tokenSymbol}.`, 'success');
                addTransactionToHistory({
                    type: 'claimGenesisTokens',
                    tokenSymbol: tokenSymbol,
                    fromAmount: 0,
                    toAmount: claimedAmount,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus(`Failed to claim ${tokenSymbol} from Genesis Pool.`, 'error');
                addTransactionToHistory({
                    type: 'claimGenesisTokens',
                    tokenSymbol: tokenSymbol,
                    fromAmount: 0,
                    toAmount: 0,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            event.target.disabled = false;
            event.target.innerHTML = `Claim ${tokenSymbol}`;
        }


        async function handleStakeGOV(event) {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet to stake GOV.', 'error');
                return;
            }
            const tokenSymbol = event.target.dataset.id;
            const inputElement = document.getElementById(`stake-gov-amount-${tokenSymbol}`);
            const amount = parseFloat(inputElement.value);
            const launchPool = state.launchPools.find(p => p.tokenSymbol === tokenSymbol);

            if (isNaN(amount) || amount <= 0) {
                updateTransactionStatus('Please enter a valid amount to stake.', 'error');
                return;
            }
            if (!launchPool || launchPool.status !== 'active') {
                updateTransactionStatus('This launch pool is not active for staking.', 'error');
                return;
            }
            if (state.balances.GOV < amount) {
                updateTransactionStatus('Insufficient GOV balance.', 'error');
                return;
            }

            updateTransactionStatus(`Staking ${amount.toFixed(2)} GOV in ${tokenSymbol} Launch Pool...`, 'pending');
            event.target.disabled = true;
            event.target.innerHTML = '<div class="spinner"></div> Staking...';

            await new Promise(resolve => setTimeout(resolve, 2000));

            const success = Math.random() > 0.1;

            if (success) {
                state.balances.GOV -= amount;
                launchPool.userStakedGOV += amount;
                launchPool.stakedGOV += amount; // Update total staked in pool

                updateBalancesUI();
                updatePortfolioTrackerUI();
                renderLaunchpadUI();
                updateTransactionStatus(`Successfully staked ${amount.toFixed(2)} GOV in ${tokenSymbol} Launch Pool.`, 'success');
                addTransactionToHistory({
                    type: 'stakeGOV',
                    poolName: tokenSymbol,
                    fromAmount: amount,
                    fromToken: 'GOV',
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus(`Failed to stake GOV in ${tokenSymbol} Launch Pool.`, 'error');
                addTransactionToHistory({
                    type: 'stakeGOV',
                    poolName: tokenSymbol,
                    fromAmount: amount,
                    fromToken: 'GOV',
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            event.target.disabled = false;
            event.target.innerHTML = 'Stake GOV';
            inputElement.value = '';
        }

        async function handleUnstakeClaimLaunchReward(event) {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet.', 'error');
                return;
            }
            const tokenSymbol = event.target.dataset.id;
            const launchPool = state.launchPools.find(p => p.tokenSymbol === tokenSymbol);

            if (!launchPool || launchPool.status !== 'closed') {
                updateTransactionStatus('This launch pool is not yet closed for unstaking/claiming.', 'error');
                return;
            }
            if (launchPool.userStakedGOV <= 0 && launchPool.userEarnedTokens <= 0) {
                updateTransactionStatus('Nothing to unstake or claim from this pool.', 'error');
                return;
            }

            updateTransactionStatus(`Unstaking GOV and claiming rewards from ${tokenSymbol} Launch Pool...`, 'pending');
            event.target.disabled = true;
            event.target.innerHTML = '<div class="spinner"></div> Processing...';

            await new Promise(resolve => setTimeout(resolve, 3000));

            const success = Math.random() > 0.05;

            if (success) {
                // Return staked GOV
                state.balances.GOV += launchPool.userStakedGOV;
                const unstakedGOV = launchPool.userStakedGOV;
                launchPool.userStakedGOV = 0;

                // Claim earned tokens
                state.balances[tokenSymbol] = (state.balances[tokenSymbol] || 0) + launchPool.userEarnedTokens;
                const claimedTokens = launchPool.userEarnedTokens;
                launchPool.userEarnedTokens = 0;

                // Remove the launch pool from active list (or mark as fully claimed)
                state.launchPools = state.launchPools.filter(p => p.tokenSymbol !== tokenSymbol);

                updateBalancesUI();
                updatePortfolioTrackerUI();
                renderLaunchpadUI();
                updateTransactionStatus(`Successfully unstaked ${unstakedGOV.toFixed(2)} GOV and claimed ${claimedTokens.toFixed(4)} ${tokenSymbol} from ${tokenSymbol} Launch Pool.`, 'success');
                addTransactionToHistory({
                    type: 'claimLaunchReward',
                    poolName: tokenSymbol,
                    fromAmount: unstakedGOV,
                    fromToken: 'GOV',
                    toAmount: claimedTokens,
                    toToken: tokenSymbol,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus(`Failed to unstake/claim from ${tokenSymbol} Launch Pool.`, 'error');
                addTransactionToHistory({
                    type: 'claimLaunchReward',
                    poolName: tokenSymbol,
                    fromAmount: 0,
                    fromToken: 'GOV',
                    toAmount: 0,
                    toToken: tokenSymbol,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            event.target.disabled = false;
            event.target.innerHTML = 'Unstake & Claim';
        }

        async function handleStakeToken(event) {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet to stake tokens.', 'error');
                return;
            }
            const tokenSymbol = event.target.dataset.id;
            const inputElement = document.getElementById(`stake-token-amount-${tokenSymbol}`);
            const amount = parseFloat(inputElement.value);
            const stakingPool = state.stakingPools[tokenSymbol];

            if (isNaN(amount) || amount <= 0) {
                updateTransactionStatus('Please enter a valid amount to stake.', 'error');
                return;
            }
            if (!stakingPool || stakingPool.status !== 'active') {
                updateTransactionStatus('This staking pool is not active.', 'error');
                return;
            }
            if (!state.balances[tokenSymbol] || state.balances[tokenSymbol] < amount) {
                updateTransactionStatus(`Insufficient ${tokenSymbol} balance.`, 'error');
                return;
            }

            updateTransactionStatus(`Staking ${amount.toFixed(2)} ${tokenSymbol} in Staking Pool...`, 'pending');
            event.target.disabled = true;
            event.target.innerHTML = '<div class="spinner"></div> Staking...';

            await new Promise(resolve => setTimeout(resolve, 2000));

            const success = Math.random() > 0.1;

            if (success) {
                state.balances[tokenSymbol] -= amount;
                stakingPool.userStakedAmount += amount;
                stakingPool.stakedAmount += amount; // Update total staked in pool

                updateBalancesUI();
                updatePortfolioTrackerUI();
                renderStakingPoolsUI();
                updateTransactionStatus(`Successfully staked ${amount.toFixed(2)} ${tokenSymbol}.`, 'success');
                addTransactionToHistory({
                    type: 'stakeToken',
                    tokenSymbol: tokenSymbol,
                    fromAmount: amount,
                    fromToken: tokenSymbol,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus(`Failed to stake ${tokenSymbol}.`, 'error');
                addTransactionToHistory({
                    type: 'stakeToken',
                    tokenSymbol: tokenSymbol,
                    fromAmount: amount,
                    fromToken: tokenSymbol,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            event.target.disabled = false;
            event.target.innerHTML = `Stake ${tokenSymbol}`;
            inputElement.value = '';
        }

        async function handleUnstakeClaimStakingReward(event) {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet.', 'error');
                return;
            }
            const tokenSymbol = event.target.dataset.id;
            const stakingPool = state.stakingPools[tokenSymbol];

            if (!stakingPool || (stakingPool.userStakedAmount <= 0 && stakingPool.userEarnedRewards <= 0)) {
                updateTransactionStatus('Nothing to unstake or claim from this pool.', 'error');
                return;
            }

            updateTransactionStatus(`Unstaking and claiming rewards from ${tokenSymbol} Staking Pool...`, 'pending');
            event.target.disabled = true;
            event.target.innerHTML = '<div class="spinner"></div> Processing...';

            await new Promise(resolve => setTimeout(resolve, 3000));

            const success = Math.random() > 0.05;

            if (success) {
                // Return staked tokens
                state.balances[tokenSymbol] = (state.balances[tokenSymbol] || 0) + stakingPool.userStakedAmount;
                const unstakedAmount = stakingPool.userStakedAmount;
                stakingPool.userStakedAmount = 0;

                // Claim earned rewards
                state.balances[tokenSymbol] += stakingPool.userEarnedRewards;
                const claimedRewards = stakingPool.userEarnedRewards;
                stakingPool.userEarnedRewards = 0;

                // If pool is empty of user's stake and rewards, and not active, consider removing/marking
                if (stakingPool.stakedAmount <= 0 && stakingPool.status !== 'active') {
                    // delete state.stakingPools[tokenSymbol]; // Can remove if desired
                }

                updateBalancesUI();
                updatePortfolioTrackerUI();
                renderStakingPoolsUI();
                updateTransactionStatus(`Successfully unstaked ${unstakedAmount.toFixed(2)} ${tokenSymbol} and claimed ${claimedRewards.toFixed(4)} ${tokenSymbol}.`, 'success');
                addTransactionToHistory({
                    type: 'unstakeToken',
                    tokenSymbol: tokenSymbol,
                    fromAmount: unstakedAmount,
                    fromToken: tokenSymbol,
                    toAmount: claimedRewards,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus(`Failed to unstake/claim from ${tokenSymbol} Staking Pool.`, 'error');
                addTransactionToHistory({
                    type: 'unstakeToken',
                    tokenSymbol: tokenSymbol,
                    fromAmount: 0,
                    fromToken: tokenSymbol,
                    toAmount: 0,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            event.target.disabled = false;
            event.target.innerHTML = 'Unstake & Claim';
        }


        async function handleBetShortIt(direction) {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet to bet.', 'error');
                return;
            }
            const tokenSymbol = shortItTokenSelect.value;
            const betAmount = parseFloat(shortItAmountInput.value);
            const betTime = parseInt(shortItTimeSelect.value);

            if (!tokenSymbol || !state.launchedTokens[tokenSymbol]) {
                updateTransactionStatus('Please select a valid token.', 'error');
                return;
            }
            if (isNaN(betAmount) || betAmount <= 0) {
                updateTransactionStatus('Please enter a valid bet amount.', 'error');
                return;
            }
            if (!state.balances[tokenSymbol] || state.balances[tokenSymbol] < betAmount) {
                updateTransactionStatus(`Insufficient ${tokenSymbol} balance to place bet.`, 'error');
                return;
            }

            const shortItPool = state.shortItPools[tokenSymbol];
            const payoutMultiplier = betTime === 3 ? 2 : (betTime === 5 ? 3 : 4);
            const potentialPayout = betAmount * payoutMultiplier;

            if (shortItPool.balance < potentialPayout) {
                updateTransactionStatus(`Short It pool for ${tokenSymbol} has insufficient balance to cover potential payout.`, 'error');
                return;
            }

            updateTransactionStatus(`Placing ${direction.toUpperCase()} bet for ${betAmount.toFixed(4)} ${tokenSymbol} over ${betTime}s...`, 'pending');
            shortItBetUpBtn.disabled = true;
            shortItBetDownBtn.disabled = true;

            state.balances[tokenSymbol] -= betAmount; // Deduct bet amount immediately
            shortItPool.balance += betAmount; // Add bet to pool (will be deducted if user wins)

            updateBalancesUI();
            updateShortItGameArea(); // Update pool balance display

            const initialPrice = state.launchedTokens[tokenSymbol].currentPrice;
            let timer = betTime;
            shortItTimerDisplay.textContent = `Time left: ${timer}s`;

            const timerInterval = setInterval(() => {
                timer--;
                shortItTimerDisplay.textContent = `Time left: ${timer}s`;
                if (timer <= 0) {
                    clearInterval(timerInterval);
                    shortItTimerDisplay.textContent = 'Determining Result...';
                    setTimeout(() => {
                        const finalPrice = state.launchedTokens[tokenSymbol].currentPrice;
                        let result = '';
                        let wonAmount = -betAmount; // Default to loss
                        let status = 'failed';

                        if (direction === 'up' && finalPrice > initialPrice) {
                            result = 'WIN';
                            wonAmount = potentialPayout;
                            status = 'success';
                            state.balances[tokenSymbol] += wonAmount; // Add payout to balance
                            shortItPool.balance -= potentialPayout; // Deduct from pool
                        } else if (direction === 'down' && finalPrice < initialPrice) {
                            result = 'WIN';
                            wonAmount = potentialPayout;
                            status = 'success';
                            state.balances[tokenSymbol] += wonAmount; // Add payout to balance
                            shortItPool.balance -= potentialPayout; // Deduct from pool
                        } else {
                            result = 'LOSS';
                            // Amount already deducted
                        }

                        state.shortItHistory.unshift({
                            isUser: true,
                            tokenSymbol,
                            betAmount,
                            direction,
                            time: betTime,
                            initialPrice,
                            finalPrice,
                            result,
                            wonAmount,
                            timestamp: Date.now()
                        });

                        updateBalancesUI();
                        updatePortfolioTrackerUI();
                        updateShortItGameArea(); // Update pool balance and history
                        updateTransactionStatus(`Short It: ${tokenSymbol} - ${result}! ${wonAmount.toFixed(4)} ${tokenSymbol}`, status);
                        addTransactionToHistory({
                            type: 'shortItResult',
                            tokenSymbol,
                            result,
                            wonAmount,
                            status,
                            timestamp: Date.now()
                        });

                        shortItBetUpBtn.disabled = false;
                        shortItBetDownBtn.disabled = false;
                        shortItAmountInput.value = '';
                    }, 500); // Small delay for result display
                }
            }, 1000);
        }

        // --- NFT Launch & Marketplace Logic ---
        let nextNftId = 1;

        async function handleLaunchNFTCollection() {
            if (state.myNFTCollection) {
                updateTransactionStatus('You have already launched an NFT collection.', 'error');
                return;
            }
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet to launch NFTs.', 'error');
                return;
            }

            const collectionName = nftCollectionNameInput.value.trim();
            const baseMintPrice = parseFloat(nftBaseMintPriceInput.value);
            const commonCount = parseInt(nftCommonCountInput.value);
            const rareCount = parseInt(nftRareCountInput.value);
            const legendaryCount = parseInt(nftLegendaryCountInput.value);
            const commonImg = nftCommonImgInput.value.trim();
            const rareImg = nftRareImgInput.value.trim();
            const legendaryImg = nftLegendaryImgInput.value.trim();

            const lpPercent = parseFloat(nftTokenLpPercentInput.value);
            const lpRewardsPercent = parseFloat(nftTokenLpRewardsPercentInput.value);
            const stakingRewardsPercent = parseFloat(nftTokenStakingRewardsPercentInput.value);
            const devWalletPercent = parseFloat(nftTokenDevWalletPercentInput.value);

            if (!collectionName || isNaN(baseMintPrice) || baseMintPrice <= 0 ||
                isNaN(commonCount) || commonCount < 0 || isNaN(rareCount) || rareCount < 0 || isNaN(legendaryCount) || legendaryCount < 0 ||
                !commonImg || !rareImg || !legendaryImg ||
                isNaN(lpPercent) || isNaN(lpRewardsPercent) || isNaN(stakingRewardsPercent) || isNaN(devWalletPercent) ||
                (lpPercent + lpRewardsPercent + stakingRewardsPercent + devWalletPercent !== 100)) {
                updateTransactionStatus('Please fill all fields correctly and ensure token allocation percentages sum to 100%.', 'error');
                return;
            }
            if (commonCount + rareCount + legendaryCount === 0) {
                updateTransactionStatus('You must mint at least one NFT.', 'error');
                return;
            }

            updateTransactionStatus(`Launching NFT Collection "${collectionName}" and paired token...`, 'pending');
            launchNftCollectionBtn.disabled = true;
            launchNftCollectionBtn.innerHTML = '<div class="spinner"></div> Launching...';

            await new Promise(resolve => setTimeout(resolve, 5000)); // Simulate launch time

            const success = Math.random() > 0.05;

            if (success) {
                const nftTokenSymbol = generateRandomTokenSymbol();
                const nftTokenName = collectionName.replace(/\s/g, '') + 'Token';
                const totalNFTs = commonCount + rareCount + legendaryCount;
                const totalInitialUSDCFromMinting = totalNFTs * baseMintPrice;
                const initialTokenSupply = totalNFTs * 1000; // Example: 1000 tokens per NFT

                // Calculate token allocations
                const lpTokens = initialTokenSupply * (lpPercent / 100);
                const lpRewardsTokens = initialTokenSupply * (lpRewardsPercent / 100);
                const stakingRewardsTokens = initialTokenSupply * (stakingRewardsPercent / 100);
                const devWalletTokens = initialTokenSupply * (devWalletPercent / 100);

                // Update balances and exchange rates for the new token
                state.balances[nftTokenSymbol] = (state.balances[nftTokenSymbol] || 0) + devWalletTokens; // Add dev's share to balance
                state.exchangeRates[`${nftTokenSymbol}/USDC`] = totalInitialUSDCFromMinting / lpTokens; // Initial price based on LP
                state.exchangeRates[`USDC/${nftTokenSymbol}`] = 1 / state.exchangeRates[`${nftTokenSymbol}/USDC`];

                // Create the new liquidity pool for the NFT token
                const nftPoolName = `${nftTokenSymbol}-USDC`;
                state.liquidityPools[nftPoolName] = {
                    tokenA: nftTokenSymbol,
                    tokenB: 'USDC',
                    tvl: totalInitialUSDCFromMinting * 2, // Assuming 50/50 initial liquidity from minting
                    apr: (Math.random() * 1.5) + 0.5,
                    userLiquidityLP: 0,
                    userFees: 0,
                    totalLP: (totalInitialUSDCFromMinting * 2) / 1000,
                    totalFeesCollected: 0,
                    devRewards: lpRewardsTokens // Dev rewards supplied to LP pool
                };

                // Create the NFT staking pool
                state.nftStakingPool = {
                    collectionName: collectionName,
                    tokenSymbol: nftTokenSymbol,
                    totalStakedNFTs: 0,
                    userStakedNFTs: [],
                    userEarnedRewards: 0,
                    devSuppliedRewards: stakingRewardsTokens, // Dev rewards supplied to NFT staking pool
                    rewardToken: nftTokenSymbol, // Rewards are in the NFT's token
                    status: 'active'
                };

                // Create the NFT collection object
                state.myNFTCollection = {
                    name: collectionName,
                    tokenSymbol: nftTokenSymbol,
                    baseMintPrice: baseMintPrice,
                    floorPrice: baseMintPrice, // Initial floor price
                    totalMinted: 0,
                    common: { count: commonCount, img: commonImg, minted: 0 },
                    rare: { count: rareCount, img: rareImg, minted: 0 },
                    legendary: { count: legendaryCount, img: legendaryImg, minted: 0 },
                    userClaimableFees: 0, // Fees from marketplace sales
                    totalNFTs: totalNFTs,
                    isLaunched: true
                };

                state.launchedTokens[nftTokenSymbol] = {
                    symbol: nftTokenSymbol,
                    name: nftTokenName,
                    totalSupply: initialTokenSupply,
                    currentPrice: state.exchangeRates[`${nftTokenSymbol}/USDC`],
                    marketCap: initialTokenSupply * state.exchangeRates[`${nftTokenSymbol}/USDC`],
                    liquidity: state.liquidityPools[nftPoolName].tvl,
                    devHoldings: devWalletTokens,
                    top10HoldersShare: (Math.random() * 20) + 30,
                    priceHistory: [state.exchangeRates[`${nftTokenSymbol}/USDC`]],
                    buyVolume: 0,
                    sellVolume: 0
                };

                state.nftCollections[collectionName] = state.myNFTCollection; // Store in general collections

                updateBalancesUI();
                renderLiquidityPoolsUI();
                renderTokenInfoUI();
                renderNFTUI();
                updatePortfolioTrackerUI();
                updateTransactionStatus(`NFT Collection "${collectionName}" and token ${nftTokenSymbol} launched successfully!`, 'success');
                addTransactionToHistory({
                    type: 'launchNFT',
                    collectionName,
                    tokenSymbol: nftTokenSymbol,
                    status: 'success',
                    timestamp: Date.now()
                });

                // Start bot minting
                setTimeout(() => simulateBotMinting(collectionName), 5000);

            } else {
                updateTransactionStatus('Failed to launch NFT collection. Please try again.', 'error');
                addTransactionToHistory({
                    type: 'launchNFT',
                    collectionName,
                    tokenSymbol: 'N/A',
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            launchNftCollectionBtn.disabled = false;
            launchNftCollectionBtn.innerHTML = 'Launch Collection';
        }

        function simulateBotMinting(collectionName) {
            const collection = state.nftCollections[collectionName];
            if (!collection || collection.totalMinted >= collection.totalNFTs) return;

            const mintCount = Math.floor(Math.random() * 5) + 1; // Bots mint 1-5 NFTs at a time
            for (let i = 0; i < mintCount; i++) {
                if (collection.totalMinted >= collection.totalNFTs) break;

                let traitType = 'common';
                const rand = Math.random();
                if (rand < 0.05 && collection.legendary.minted < collection.legendary.count) {
                    traitType = 'legendary';
                } else if (rand < 0.25 && collection.rare.minted < collection.rare.count) {
                    traitType = 'rare';
                } else if (collection.common.minted >= collection.common.count) {
                    // Fallback if common are all minted, try rare/legendary even if odds are low
                    if (collection.rare.minted < collection.rare.count) traitType = 'rare';
                    else if (collection.legendary.minted < collection.legendary.count) traitType = 'legendary';
                    else continue; // No more NFTs to mint
                }

                if (collection[traitType].minted < collection[traitType].count) {
                    collection[traitType].minted++;
                    collection.totalMinted++;
                    const nftId = nextNftId++;
                    const nft = {
                        id: nftId,
                        collectionName: collectionName,
                        name: `${collection.name} #${nftId}`,
                        trait: traitType,
                        imageUrl: collection[traitType].img,
                        owner: 'bot',
                        isListed: false,
                        isStaked: false,
                        price: collection.baseMintPrice * (traitType === 'legendary' ? 1.5 : (traitType === 'rare' ? 1.2 : 1)) // Rarity price adjustment
                    };
                    state.myNFTs.push(nft); // Add to general NFT list

                    // Simulate bot buying from marketplace (if listed by other bots)
                    if (Math.random() < 0.5) { // 50% chance to list for sale
                        nft.isListed = true;
                        nft.price = nft.price * (1 + (Math.random() - 0.5) * 0.1); // Small price fluctuation
                        state.nftMarketplaceListings.push(nft);
                    }
                    // Simulate minting USDC going to LP
                    state.liquidityPools[`${collection.tokenSymbol}-USDC`].tvl += collection.baseMintPrice;
                    state.liquidityPools[`${collection.tokenSymbol}-USDC`].totalLP += collection.baseMintPrice / 1000; // Simplified LP token
                    state.totalPlatformRevenue += collection.baseMintPrice * 0.0005; // 0.05% fee on minting

                    updateTransactionStatus(`Bot minted ${nft.name} (${nft.trait}) from ${collection.name}.`, 'info');
                    addTransactionToHistory({
                        type: 'mintNFT',
                        nftName: nft.name,
                        trait: nft.trait,
                        price: collection.baseMintPrice,
                        status: 'success',
                        timestamp: Date.now()
                    });
                }
            }
            renderNFTUI();
            updateBalancesUI();
            updatePortfolioTrackerUI();
            renderLiquidityPoolsUI();
            renderTokenInfoUI(); // Update token info if the NFT token is selected
        }

        async function handleBuyNFT(event) {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet to buy NFTs.', 'error');
                return;
            }
            const nftId = parseInt(event.target.dataset.id);
            const nftToBuy = state.nftMarketplaceListings.find(nft => nft.id === nftId);
            const collection = state.myNFTCollection;

            if (!nftToBuy || !collection) {
                updateTransactionStatus('NFT not found or collection not launched.', 'error');
                return;
            }
            if (state.balances[collection.tokenSymbol] < nftToBuy.price) {
                updateTransactionStatus(`Insufficient ${collection.tokenSymbol} to buy this NFT.`, 'error');
                return;
            }

            updateTransactionStatus(`Buying NFT #${nftId} for ${nftToBuy.price.toFixed(2)} ${collection.tokenSymbol}...`, 'pending');
            event.target.disabled = true;
            event.target.innerHTML = '<div class="spinner"></div> Buying...';

            await new Promise(resolve => setTimeout(resolve, 2000));

            const success = Math.random() > 0.1;

            if (success) {
                state.balances[collection.tokenSymbol] -= nftToBuy.price; // Deduct price from user
                // Simulate payment to bot (no actual bot balance tracking, just removed from user)

                // Remove from marketplace listings
                state.nftMarketplaceListings = state.nftMarketplaceListings.filter(nft => nft.id !== nftId);

                // Update NFT owner to user
                const ownedNft = state.myNFTs.find(nft => nft.id === nftId);
                if (ownedNft) ownedNft.owner = 'user';

                // Update floor price (simple average of last few sales or just based on recent activity)
                collection.floorPrice = collection.floorPrice * (1 + (Math.random() * 0.05)); // Small increase on buy

                // Creator fee (0.1% of sale price)
                const creatorFee = nftToBuy.price * 0.001;
                collection.userClaimableFees += creatorFee;
                state.totalPlatformRevenue += creatorFee; // Add to platform revenue

                updateBalancesUI();
                renderNFTUI();
                updatePortfolioTrackerUI();
                updateTransactionStatus(`Successfully bought NFT #${nftId}.`, 'success');
                addTransactionToHistory({
                    type: 'buyNFT',
                    nftId: nftId,
                    price: nftToBuy.price,
                    tokenSymbol: collection.tokenSymbol,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus(`Failed to buy NFT #${nftId}.`, 'error');
                addTransactionToHistory({
                    type: 'buyNFT',
                    nftId: nftId,
                    price: nftToBuy.price,
                    tokenSymbol: collection.tokenSymbol,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            event.target.disabled = false;
            event.target.innerHTML = 'Buy';
        }

        async function handleClaimNFTFees() {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet.', 'error');
                return;
            }
            const collection = state.myNFTCollection;
            if (!collection || collection.userClaimableFees <= 0) {
                updateTransactionStatus('No NFT marketplace fees to claim.', 'error');
                return;
            }

            updateTransactionStatus(`Claiming NFT marketplace fees...`, 'pending');
            claimNftFeesBtn.disabled = true;
            claimNftFeesBtn.innerHTML = '<div class="spinner"></div> Claiming...';

            await new Promise(resolve => setTimeout(resolve, 2000));

            const success = Math.random() > 0.05;

            if (success) {
                state.balances[collection.tokenSymbol] = (state.balances[collection.tokenSymbol] || 0) + collection.userClaimableFees;
                const claimedAmount = collection.userClaimableFees;
                collection.userClaimableFees = 0;

                updateBalancesUI();
                renderNFTUI();
                updatePortfolioTrackerUI();
                updateTransactionStatus(`Successfully claimed ${claimedAmount.toFixed(4)} ${collection.tokenSymbol} NFT fees.`, 'success');
                addTransactionToHistory({
                    type: 'claimNFTFees',
                    tokenSymbol: collection.tokenSymbol,
                    toAmount: claimedAmount,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus('Failed to claim NFT fees.', 'error');
                addTransactionToHistory({
                    type: 'claimNFTFees',
                    tokenSymbol: collection.tokenSymbol,
                    toAmount: 0,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            claimNftFeesBtn.disabled = false;
            claimNftFeesBtn.innerHTML = 'Claim NFT Marketplace Fees';
        }

        async function handleSupplyNFTRewards() {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet.', 'error');
                return;
            }
            const amount = parseFloat(nftStakingSupplyAmountInput.value);
            const token = nftStakingSupplyTokenSelect.value;
            const stakingPool = state.nftStakingPool;

            if (isNaN(amount) || amount <= 0) {
                updateTransactionStatus('Please enter a valid amount to supply.', 'error');
                return;
            }
            if (!stakingPool) {
                updateTransactionStatus('NFT Staking Pool not found.', 'error');
                return;
            }
            if (!state.balances[token] || state.balances[token] < amount) {
                updateTransactionStatus(`Insufficient ${token} balance to supply rewards.`, 'error');
                return;
            }

            updateTransactionStatus(`Supplying ${amount.toFixed(2)} ${token} to NFT Staking Pool...`, 'pending');
            supplyNftStakingRewardsBtn.disabled = true;
            supplyNftStakingRewardsBtn.innerHTML = '<div class="spinner"></div> Supplying...';

            await new Promise(resolve => setTimeout(resolve, 2000));

            const success = Math.random() > 0.05;

            if (success) {
                state.balances[token] -= amount;
                stakingPool.devSuppliedRewards += amount;
                stakingPool.rewardToken = token; // Set reward token based on what's supplied

                updateBalancesUI();
                renderNFTUI();
                updatePortfolioTrackerUI();
                updateTransactionStatus(`Successfully supplied ${amount.toFixed(2)} ${token} to NFT Staking Pool.`, 'success');
                addTransactionToHistory({
                    type: 'supplyNFTRewards',
                    fromAmount: amount,
                    rewardToken: token,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus('Failed to supply NFT staking rewards.', 'error');
                addTransactionToHistory({
                    type: 'supplyNFTRewards',
                    fromAmount: amount,
                    rewardToken: token,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            supplyNftStakingRewardsBtn.disabled = false;
            supplyNftStakingRewardsBtn.innerHTML = 'Supply Rewards';
            nftStakingSupplyAmountInput.value = '';
        }

        async function handleStakeMyNFT() {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet.', 'error');
                return;
            }
            const unstakedNFTs = state.myNFTs.filter(nft => nft.owner === 'user' && !nft.isStaked);
            if (unstakedNFTs.length === 0) {
                updateTransactionStatus('You have no unstaked NFTs to stake.', 'error');
                return;
            }
            const nftToStake = unstakedNFTs[0]; // Just stake the first available

            updateTransactionStatus(`Staking NFT #${nftToStake.id} from ${nftToStake.collectionName}...`, 'pending');
            stakeMyNftBtn.disabled = true;
            stakeMyNftBtn.innerHTML = '<div class="spinner"></div> Staking...';

            await new Promise(resolve => setTimeout(resolve, 2000));

            const success = Math.random() > 0.1;

            if (success) {
                nftToStake.isStaked = true;
                state.nftStakingPool.userStakedNFTs.push(nftToStake);
                state.nftStakingPool.totalStakedNFTs++;

                updateBalancesUI(); // No balance change, but UI might need refresh
                renderNFTUI();
                updatePortfolioTrackerUI();
                updateTransactionStatus(`Successfully staked NFT #${nftToStake.id}.`, 'success');
                addTransactionToHistory({
                    type: 'stakeNFT',
                    nftId: nftToStake.id,
                    collectionName: nftToStake.collectionName,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus(`Failed to stake NFT #${nftToStake.id}.`, 'error');
                addTransactionToHistory({
                    type: 'stakeNFT',
                    nftId: nftToStake.id,
                    collectionName: nftToStake.collectionName,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            stakeMyNftBtn.disabled = false;
            stakeMyNftBtn.innerHTML = 'Stake My NFT';
        }

        async function handleUnstakeClaimNFTRewards() {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet.', 'error');
                return;
            }
            const stakingPool = state.nftStakingPool;
            if (!stakingPool || (stakingPool.userStakedNFTs.length === 0 && stakingPool.userEarnedRewards <= 0)) {
                updateTransactionStatus('No staked NFTs or rewards to claim.', 'error');
                return;
            }

            updateTransactionStatus(`Unstaking NFTs and claiming rewards...`, 'pending');
            unstakeClaimNftRewardsBtn.disabled = true;
            unstakeClaimNftRewardsBtn.innerHTML = '<div class="spinner"></div> Processing...';

            await new Promise(resolve => setTimeout(resolve, 3000));

            const success = Math.random() > 0.05;

            if (success) {
                // Unstake all user's NFTs
                stakingPool.userStakedNFTs.forEach(nft => {
                    nft.isStaked = false;
                    state.nftStakingPool.totalStakedNFTs--;
                });
                stakingPool.userStakedNFTs = [];

                // Claim rewards
                state.balances[stakingPool.rewardToken] = (state.balances[stakingPool.rewardToken] || 0) + stakingPool.userEarnedRewards;
                const claimedRewards = stakingPool.userEarnedRewards;
                stakingPool.userEarnedRewards = 0;

                updateBalancesUI();
                renderNFTUI();
                updatePortfolioTrackerUI();
                updateTransactionStatus(`Successfully unstaked NFTs and claimed ${claimedRewards.toFixed(4)} ${stakingPool.rewardToken}.`, 'success');
                addTransactionToHistory({
                    type: 'claimNFTReward',
                    rewardToken: stakingPool.rewardToken,
                    toAmount: claimedRewards,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus('Failed to unstake NFTs or claim rewards.', 'error');
                addTransactionToHistory({
                    type: 'claimNFTReward',
                    rewardToken: stakingPool.rewardToken,
                    toAmount: 0,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            unstakeClaimNftRewardsBtn.disabled = false;
            unstakeClaimNftRewardsBtn.innerHTML = 'Unstake & Claim';
        }


        async function handleVote(event) {
            if (!state.isConnected) {
                updateTransactionStatus('Please connect your wallet to vote.', 'error');
                return;
            }
            if (state.userVotingPower <= 0) {
                updateTransactionStatus('You need GOV tokens to vote. Acquire some via Swap.', 'error');
                return;
            }

            const proposalId = event.target.dataset.id;
            const voteType = event.target.dataset.type; // 'yes' or 'no'
            const proposal = state.proposals.find(p => p.id === proposalId);

            if (!proposal || proposal.hasVoted || proposal.status !== 'active') {
                updateTransactionStatus('Cannot vote on this proposal.', 'error');
                return;
            }

            const votingPowerUsed = Math.min(state.userVotingPower, state.balances.GOV); // Use all available GOV balance
            if (votingPowerUsed <= 0) {
                updateTransactionStatus('You have no GOV tokens to cast a vote.', 'error');
                return;
            }

            updateTransactionStatus(`Casting vote "${voteType}" on "${proposal.title}"...`, 'pending');
            // Disable all vote buttons temporarily
            proposalsList.querySelectorAll('.vote-buttons button').forEach(btn => btn.disabled = true);


            await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate network delay

            const success = Math.random() > 0.05; // 95% chance of success

            if (success) {
                if (voteType === 'yes') {
                    proposal.votesYes += votingPowerUsed;
                } else {
                    proposal.votesNo += votingPowerUsed;
                }
                proposal.totalVotingPower += votingPowerUsed;
                proposal.hasVoted = true; // Mark as voted for the current user

                // Deduct GOV tokens (can be simulated as "locked" for the vote duration)
                state.balances.GOV -= votingPowerUsed;
                state.userVotingPower -= votingPowerUsed; // Reduce available voting power

                updateBalancesUI();
                updatePortfolioTrackerUI();
                renderProposalsUI(); // Re-render to show updated vote counts and disabled buttons
                updateTransactionStatus(`Successfully voted ${voteType} on "${proposal.title}".`, 'success');
                addTransactionToHistory({
                    type: 'vote',
                    proposalTitle: proposal.title,
                    voteType: voteType.toUpperCase(),
                    fromToken: 'GOV',
                    fromAmount: votingPowerUsed,
                    status: 'success',
                    timestamp: Date.now()
                });
                triggerBurstEffect();
            } else {
                updateTransactionStatus(`Failed to cast vote on "${proposal.title}". Please try again.`, 'error');
                addTransactionToHistory({
                    type: 'vote',
                    proposalTitle: proposal.title,
                    voteType: voteType.toUpperCase(),
                    fromToken: 'GOV',
                    fromAmount: votingPowerUsed,
                    status: 'failed',
                    timestamp: Date.now()
                });
            }
            // Re-enable vote buttons (only those not voted on)
            renderProposalsUI(); // This will re-render and correctly enable/disable
        }


        function checkProposalStatus() {
            const now = Date.now();
            state.proposals.forEach(proposal => {
                if (proposal.status === 'active' && now >= proposal.endsAt) {
                    // Determine outcome
                    if (proposal.votesYes > proposal.votesNo) {
                        proposal.status = 'passed';
                        applyProposalEffect(proposal.effect);
                        updateTransactionStatus(`PROPOSAL PASSED: "${proposal.title}"`, 'success');
                    } else {
                        proposal.status = 'failed';
                        updateTransactionStatus(`PROPOSAL FAILED: "${proposal.title}"`, 'error');
                    }
                    renderProposalsUI(); // Update UI to reflect new status
                }
            });
        }

        function applyProposalEffect(effect) {
            if (!effect) return;

            switch (effect.type) {
                case 'adjustApr':
                    if (state.liquidityPools[effect.pool]) {
                        state.liquidityPools[effect.pool].apr = effect.newApr;
                        console.log(`APR for ${effect.pool} adjusted to ${effect.newApr * 100}%`);
                    }
                    break;
                case 'adjustSlippage':
                    state.slippagePercentage = effect.newSlippage;
                    slippageDisplay.textContent = `${effect.newSlippage}%`;
                    console.log(`Global slippage adjusted to ${effect.newSlippage}%`);
                    break;
                // Add more effects as needed
            }
            renderLiquidityPoolsUI(); // Update APR display if changed
            calculateSwapOutput(); // Update slippage display if changed
        }

        // --- New Token Launch Logic ---
        const tokenNames = ['Quantum', 'Nebula', 'Fusion', 'Aether', 'Zenith', 'Cosmos', 'Vortex', 'Pulsar', 'Chrono', 'Lumin'];
        let nextTokenIndex = 0;
        let proposalCounter = 3; // Start from 3 as 1 and 2 are initial proposals

        function generateRandomTokenSymbol() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            let result = '';
            for (let i = 0; i < 3; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function launchNewTokenGenesis() {
            if (state.genesisPools.length >= 3) { // Limit active genesis pools
                return;
            }

            const tokenSymbol = generateRandomTokenSymbol();
            const tokenName = tokenNames[nextTokenIndex % tokenNames.length] + 'Coin';
            nextTokenIndex++;

            // Ensure unique symbol
            if (state.balances[tokenSymbol] || Object.keys(state.launchedTokens).includes(tokenSymbol) || state.genesisPools.some(p => p.tokenSymbol === tokenSymbol)) {
                return launchNewTokenGenesis(); // Try again if symbol exists
            }

            const initialSupply = Math.floor(Math.random() * 1000000) + 500000; // 500k to 1.5M
            const genesisAllocationPercentage = 0.20 + Math.random() * 0.10; // 20-30% of total supply for genesis presale
            const devHoldings = initialSupply * (0.05 + Math.random() * 0.15); // 5-20% for dev
            const top10HoldersShare = (Math.random() * 20) + 30; // 30-50% for top 10
            const genesisDurationMinutes = Math.floor(Math.random() * 26) + 5; // 5 to 30 minutes

            const genesisPool = {
                id: `genesis-${tokenSymbol}`, // Unique ID for genesis pool
                tokenSymbol,
                tokenName,
                initialSupply,
                genesisAllocationPercentage,
                liquidityContributed: 0, // Bots and users will add this USDC
                userContribution: 0, // User's specific USDC contribution
                userClaimableTokens: 0, // Tokens user can claim after launch
                devHoldings,
                top10HoldersShare,
                launchTime: Date.now() + 60 * 1000 * genesisDurationMinutes, // Random genesis phase duration
                status: 'genesis',
                priceHistory: [], // Will be populated dynamically based on liquidity
                buyVolume: 0, // Initialize buy volume for token info
                sellVolume: 0 // Initialize sell volume for token info
            };
            state.genesisPools.push(genesisPool);

            // Create a corresponding launch pool (GOV staking for new token)
            state.launchPools.push({
                tokenSymbol,
                stakedGOV: 0,
                userStakedGOV: 0,
                userEarnedTokens: 0,
                status: 'active',
                totalTokensToDistribute: initialSupply * (0.05 + Math.random() * 0.10) // 5-15% of total supply for GOV staking rewards
            });

            console.log(`New token ${tokenSymbol} (${tokenName}) entered Genesis Pool!`);
            updateBalancesUI(); // Update token options
            renderLaunchpadUI();
        }

        function checkGenesisPoolsAndLaunch() {
            const now = Date.now();
            state.genesisPools.forEach(pool => {
                if (pool.status === 'genesis' && now >= pool.launchTime) {
                    finalizeTokenLaunch(pool);
                }
            });
            // Filter out fully launched and claimed genesis pools if desired, or keep them for history
            // For now, they remain but their status changes
            renderLaunchpadUI();
        }

        function finalizeTokenLaunch(genesisPool) {
            const { tokenSymbol, tokenName, initialSupply, genesisAllocationPercentage, liquidityContributed, userContribution, devHoldings, top10HoldersShare, priceHistory } = genesisPool;

            // Calculate total tokens allocated for genesis presale
            const totalTokensForGenesisPresale = initialSupply * genesisAllocationPercentage;

            // Calculate initial price based on total liquidity contributed and total tokens for presale
            // If no liquidity contributed, set a default very low price to avoid division by zero
            const initialPriceUSDC = liquidityContributed > 0 ? liquidityContributed / totalTokensForGenesisPresale : 0.000001;

            // Calculate user's claimable tokens from genesis pool
            if (liquidityContributed > 0 && userContribution > 0) {
                const userShareOfTotalContribution = userContribution / liquidityContributed;
                genesisPool.userClaimableTokens = totalTokensForGenesisPresale * userShareOfTotalContribution;
            } else {
                genesisPool.userClaimableTokens = 0;
            }
            genesisPool.status = 'launched'; // Mark genesis pool as launched

            // Add exchange rate for the new token
            state.exchangeRates[`${tokenSymbol}/USDC`] = initialPriceUSDC;
            state.exchangeRates[`USDC/${tokenSymbol}`] = 1 / initialPriceUSDC;

            // Create a new liquidity pool for the launched token (e.g., against USDC)
            const poolName = `${tokenSymbol}-USDC`;
            const initialLiquidityTokenAmount = totalTokensForGenesisPresale * 0.5; // 50% of presale tokens for initial LP
            const initialLiquidityUSDC = liquidityContributed * 0.5; // 50% of contributed USDC for initial LP

            state.liquidityPools[poolName] = {
                tokenA: tokenSymbol,
                tokenB: 'USDC',
                tvl: initialLiquidityUSDC * 2, // Total value of the LP pool
                apr: (Math.random() * 1.5) + 0.5, // High APR for new pools (50% to 200%)
                userLiquidityLP: 0,
                userFees: 0,
                totalLP: (initialLiquidityUSDC * 2) / 1000, // Simplified LP token calculation
                totalFeesCollected: 0,
                devRewards: 0 // Initialize dev rewards for this pool
            };

            // Add to launched tokens for info page
            state.launchedTokens[tokenSymbol] = {
                symbol: tokenSymbol,
                name: tokenName,
                totalSupply: initialSupply,
                currentPrice: initialPriceUSDC,
                marketCap: initialSupply * initialPriceUSDC,
                liquidity: initialLiquidityUSDC * 2, // Initial liquidity from genesis pool
                devHoldings: devHoldings,
                top10HoldersShare: top10HoldersShare,
                priceHistory: [initialPriceUSDC], // Initial price point
                buyVolume: 0, // Initialize buy volume
                sellVolume: 0 // Initialize sell volume
            };

            // Create a new staking pool for the launched token (token staking for token)
            state.stakingPools[tokenSymbol] = {
                tokenSymbol: tokenSymbol,
                stakedAmount: 0,
                userStakedAmount: 0,
                userEarnedRewards: 0,
                status: 'active',
                // Dev supplies 5-10% of total supply for staking rewards
                totalRewardsDistributed: initialSupply * (0.05 + Math.random() * 0.05)
            };

            // Create a Short It pool for the new token
            state.shortItPools[tokenSymbol] = {
                tokenSymbol: tokenSymbol,
                balance: initialSupply * 0.01, // 1% of total supply as initial pool balance
                history: []
            };


            // Close the corresponding launch pool (GOV staking) and distribute rewards
            const launchPool = state.launchPools.find(p => p.tokenSymbol === tokenSymbol);
            if (launchPool) {
                launchPool.status = 'closed';
                // Distribute rewards based on user's share of staked GOV
                if (launchPool.stakedGOV > 0) {
                    const userShare = launchPool.userStakedGOV / launchPool.stakedGOV;
                    launchPool.userEarnedTokens = launchPool.totalTokensToDistribute * userShare;
                }
            }

            console.log(`Token ${tokenSymbol} (${tokenName}) launched!`);
            updateBalancesUI();
            renderLiquidityPoolsUI();
            renderTokenInfoUI();
            renderLaunchpadUI(); // Update genesis pool status and claim button
            renderStakingPoolsUI(); // Show new staking pool
            updateShortItGameArea(); // Update short-it token select
            updatePortfolioTrackerUI();
            updateTransactionStatus(`${tokenName} (${tokenSymbol}) has launched!`, 'success');
        }


        // --- Bot Activity Simulation ---
        function simulateBotActivity() {
            // Simulate APR and TVL fluctuations for liquidity pools
            for (const poolName in state.liquidityPools) {
                const pool = state.liquidityPools[poolName];

                // Simulate significant APR fluctuation to keep it high and dynamic
                pool.apr = Math.max(0.50, pool.apr + (Math.random() - 0.5) * 0.10); // +/- 10%
                pool.apr = Math.min(2.00, pool.apr); // Cap APR at 200%

                // Simulate TVL fluctuation
                pool.tvl = Math.max(10000, pool.tvl + (Math.random() - 0.5) * 1000); // +/- $1000

                // Simulate fee accumulation for user's liquidity
                if (pool.userLiquidityLP > 0) {
                    const dailyFeeRate = pool.apr / 365;
                    const userShareOfTVL = (pool.userLiquidityLP / pool.totalLP) * pool.tvl;
                    const earned = userShareOfTVL * dailyFeeRate * (Math.random() * 0.1 + 0.05); // Simulate daily fee accumulation
                    pool.userFees += earned;
                    pool.totalFeesCollected += earned; // Track total fees for dashboard

                    // Simulate dev token rewards for LP providers
                    if (state.launchedTokens[pool.tokenA] && pool.tokenB === 'USDC') { // If tokenA is a launched token
                        const devRewardAmount = (state.launchedTokens[pool.tokenA].totalSupply * 0.00001) * userShareOfTVL / pool.tvl; // Small percentage of total supply
                        pool.devRewards += devRewardAmount;
                    } else if (state.launchedTokens[pool.tokenB] && pool.tokenA === 'USDC') { // If tokenB is a launched token
                        const devRewardAmount = (state.launchedTokens[pool.tokenB].totalSupply * 0.00001) * userShareOfTVL / pool.tvl;
                        pool.devRewards += devRewardAmount;
                    }
                }

                // Bots add/remove liquidity from all pools
                if (Math.random() < 0.1) { // 10% chance for bot LP activity
                    const lpAction = Math.random() > 0.5 ? 'add' : 'remove';
                    const amount = Math.random() * 1000; // Up to $1000 worth
                    if (lpAction === 'add') {
                        // Simplified bot adding liquidity
                        pool.tvl += amount;
                        pool.totalLP += amount / 1000;
                    } else if (pool.tvl > 1000) { // Only remove if enough TVL
                        // Simplified bot removing liquidity
                        pool.tvl -= amount;
                        pool.totalLP -= amount / 1000;
                        if (pool.tvl < 0) pool.tvl = 0;
                        if (pool.totalLP < 0) pool.totalLP = 0;
                    }
                }
            }
            renderLiquidityPoolsUI(); // Update display
            updatePortfolioTrackerUI(); // Update portfolio with new fee values

            // Simulate bot voting activity
            state.proposals.forEach(proposal => {
                if (proposal.status === 'active') {
                    // Bots randomly vote
                    const botVoteAmount = Math.floor(Math.random() * 50); // Bots vote with up to 50 GOV tokens
                    if (Math.random() > 0.5) {
                        proposal.votesYes += botVoteAmount;
                    } else {
                        proposal.votesNo += botVoteAmount;
                    }
                    proposal.totalVotingPower += botVoteAmount;
                }
            });
            renderProposalsUI(); // Update proposals display

            // Simulate bot activity in Genesis Pools
            state.genesisPools.forEach(pool => {
                if (pool.status === 'genesis') {
                    const botContribution = Math.random() * 500; // Bots add up to 500 USDC liquidity
                    pool.liquidityContributed += botContribution;
                }
            });
            // Simulate bot activity in Launch Pools (staking GOV)
            state.launchPools.forEach(pool => {
                if (pool.status === 'active') {
                    const botStakeAmount = Math.floor(Math.random() * 20); // Bots stake up to 20 GOV
                    pool.stakedGOV += botStakeAmount;
                }
            });
            renderLaunchpadUI(); // Update launchpad display

            // Simulate bot activity in new Staking Pools
            for (const tokenSymbol in state.stakingPools) {
                const pool = state.stakingPools[tokenSymbol];
                if (pool.status === 'active') {
                    const botStakeAmount = Math.floor(Math.random() * 100); // Bots stake up to 100 of the token
                    pool.stakedAmount += botStakeAmount;

                    // Simulate reward accumulation for all stakers (including user)
                    // This is a simplified emission model, not strictly APR based on TVL, but proportional to total rewards
                    if (pool.stakedAmount > 0) {
                        const dailyRewardRate = pool.totalRewardsDistributed / 365; // Total rewards distributed over a year
                        const rewardPerStakedUnit = dailyRewardRate / pool.stakedAmount; // Reward per unit staked per day
                        pool.userEarnedRewards += pool.userStakedAmount * rewardPerStakedUnit * (Math.random() * 0.1 + 0.05); // Daily accumulation
                    }
                }
            }
            renderStakingPoolsUI(); // Update staking pools display

            // Update launched token prices and charts, and simulate bot trading
            for (const symbol in state.launchedTokens) {
                const token = state.launchedTokens[symbol];
                // Simulate price fluctuation
                let priceChange = (Math.random() - 0.5) * 0.0005; // Small random change

                // Simulate bot trading activity (buy/sell volume and price impact)
                const botTradeAmountUSDC = Math.random() * 1000; // Bots trade up to $1000 worth
                const isBotBuy = Math.random() > 0.4; // 60% chance of buy (bias towards buys)

                if (isBotBuy) {
                    token.buyVolume += botTradeAmountUSDC;
                    priceChange += (botTradeAmountUSDC / token.liquidity) * 0.001; // Small positive price impact
                } else {
                    token.sellVolume += botTradeAmountUSDC;
                    priceChange -= (botTradeAmountUSDC / token.liquidity) * 0.001; // Small negative price impact
                }

                // Simulate "pump and dump" for a random token every now and then
                if (Math.random() < 0.01 && symbol !== 'GOV') { // 1% chance for a pump/dump cycle
                    console.log(`PUMP/DUMP cycle for ${symbol}`);
                    const pumpAmount = Math.random() * 5000 + 1000; // Large buy
                    token.buyVolume += pumpAmount;
                    priceChange += (pumpAmount / token.liquidity) * 0.01; // Significant positive impact
                    setTimeout(() => { // Simulate dump after a short period
                        const dumpAmount = pumpAmount * (0.8 + Math.random() * 0.2); // Sell most of it
                        token.sellVolume += dumpAmount;
                        priceChange -= (dumpAmount / token.liquidity) * 0.015; // Significant negative impact
                    }, 5000);
                }

                // Market Cap Threshold Pumps/Dumps
                if (token.marketCap > 1000000 && Math.random() < 0.02) { // 2% chance for large event at >$1M MC
                    const isMassivePump = Math.random() > 0.5;
                    const impactFactor = Math.random() * 0.1 + 0.05; // 5-15% impact
                    if (isMassivePump) {
                        priceChange += token.currentPrice * impactFactor; // Massive pump
                        console.log(`MASSIVE PUMP for ${symbol}!`);
                    } else {
                        priceChange -= token.currentPrice * impactFactor; // Massive dump
                        console.log(`MASSIVE DUMP for ${symbol}!`);
                    }
                }


                token.currentPrice = Math.max(0.0001, token.currentPrice + priceChange); // Apply price change
                token.marketCap = token.totalSupply * token.currentPrice;
                token.liquidity = state.liquidityPools[`${symbol}-USDC`] ? state.liquidityPools[`${symbol}-USDC`].tvl : 0; // Update liquidity from pool
                state.exchangeRates[`${symbol}/USDC`] = token.currentPrice;
                state.exchangeRates[`USDC/${symbol}`] = 1 / token.currentPrice;

                // Add to price history (keep history limited)
                token.priceHistory.push(token.currentPrice);
                if (token.priceHistory.length > 20) { // Keep last 20 price points for chart
                    token.priceHistory.shift();
                }
            }
            renderTokenInfoUI(); // Re-render token info if currently displayed
            renderDashboardUI(); // Update dashboard stats

            // Simulate bot activity in Short It pools
            const launchedTokenSymbols = Object.keys(state.launchedTokens).filter(s => s !== 'GOV'); // Bots don't short GOV
            if (launchedTokenSymbols.length > 0 && Math.random() < 0.2) { // 20% chance for a bot bet
                const randomToken = launchedTokenSymbols[Math.floor(Math.random() * launchedTokenSymbols.length)];
                const token = state.launchedTokens[randomToken];
                const shortItPool = state.shortItPools[randomToken];
                if (shortItPool && token.currentPrice > 0) {
                    const botBetAmount = Math.random() * 10; // Bots bet up to 10 tokens
                    const botBetDirection = Math.random() > 0.5 ? 'up' : 'down';
                    const botBetTime = [3, 5, 10][Math.floor(Math.random() * 3)];
                    const payoutMultiplier = botBetTime === 3 ? 2 : (botBetTime === 5 ? 3 : 4);
                    const potentialPayout = botBetAmount * payoutMultiplier;

                    if (shortItPool.balance >= potentialPayout) { // Only bet if pool can cover
                        shortItPool.balance += botBetAmount; // Add bet to pool
                        const initialPrice = token.currentPrice;
                        setTimeout(() => {
                            const finalPrice = token.currentPrice;
                            let result = '';
                            let wonAmount = -botBetAmount;

                            if (botBetDirection === 'up' && finalPrice > initialPrice) {
                                result = 'WIN';
                                wonAmount = potentialPayout;
                                shortItPool.balance -= potentialPayout; // Deduct from pool
                            } else if (botBetDirection === 'down' && finalPrice < initialPrice) {
                                result = 'WIN';
                                wonAmount = potentialPayout;
                                shortItPool.balance -= potentialPayout; // Deduct from pool
                            } else {
                                result = 'LOSS';
                            }
                            state.shortItHistory.unshift({
                                isUser: false,
                                tokenSymbol: randomToken,
                                betAmount: botBetAmount,
                                direction: botBetDirection,
                                time: botBetTime,
                                initialPrice,
                                finalPrice,
                                result,
                                wonAmount,
                                timestamp: Date.now()
                            });
                            updateShortItGameArea(); // Update pool balance and history
                        }, botBetTime * 1000);
                    }
                }
            }

            // Simulate bot NFT activity
            if (state.myNFTCollection && state.myNFTCollection.isLaunched) {
                // Bots minting
                if (Math.random() < 0.2) { // 20% chance to mint
                    simulateBotMinting(state.myNFTCollection.name);
                }

                // Bots buying/selling NFTs
                if (state.nftMarketplaceListings.length > 0 && Math.random() < 0.3) { // 30% chance to buy/sell
                    const action = Math.random() > 0.5 ? 'buy' : 'list';
                    if (action === 'buy') {
                        const nftToBuy = state.nftMarketplaceListings[Math.floor(Math.random() * state.nftMarketplaceListings.length)];
                        // Simulate bot buying (no actual balance check for bot)
                        state.nftMarketplaceListings = state.nftMarketplaceListings.filter(nft => nft.id !== nftToBuy.id);
                        const ownedNft = state.myNFTs.find(nft => nft.id === nftToBuy.id);
                        if (ownedNft) ownedNft.owner = 'bot'; // Transfer ownership to bot
                        state.myNFTCollection.floorPrice = state.myNFTCollection.floorPrice * (1 + (Math.random() * 0.02)); // Small increase on buy
                        const creatorFee = nftToBuy.price * 0.001;
                        state.myNFTCollection.userClaimableFees += creatorFee;
                        state.totalPlatformRevenue += creatorFee;
                        updateTransactionStatus(`Bot bought NFT #${nftToBuy.id}.`, 'info');
                    } else { // List for sale (if bot owns any)
                        const botOwnedNFTs = state.myNFTs.filter(nft => nft.owner === 'bot' && !nft.isListed);
                        if (botOwnedNFTs.length > 0) {
                            const nftToList = botOwnedNFTs[Math.floor(Math.random() * botOwnedNFTs.length)];
                            nftToList.isListed = true;
                            nftToList.price = nftToList.price * (1 + (Math.random() - 0.5) * 0.1); // Price fluctuation
                            state.nftMarketplaceListings.push(nftToList);
                            updateTransactionStatus(`Bot listed NFT #${nftToList.id} for sale.`, 'info');
                        }
                    }
                    renderNFTUI();
                }

                // Bots staking NFTs
                if (Math.random() < 0.1 && state.nftStakingPool) { // 10% chance to stake
                    const botOwnedUnstakedNFTs = state.myNFTs.filter(nft => nft.owner === 'bot' && !nft.isStaked);
                    if (botOwnedUnstakedNFTs.length > 0) {
                        const nftToStake = botOwnedUnstakedNFTs[Math.floor(Math.random() * botOwnedUnstakedNFTs.length)];
                        nftToStake.isStaked = true;
                        state.nftStakingPool.totalStakedNFTs++;
                        updateTransactionStatus(`Bot staked NFT #${nftToStake.id}.`, 'info');
                        renderNFTUI();
                    }
                }

                // Bots claiming NFT staking rewards
                if (Math.random() < 0.05 && state.nftStakingPool && state.nftStakingPool.totalStakedNFTs > 0) {
                    // Simulate bot claiming rewards (no actual balance tracking for bot)
                    // Just reset a small portion of dev supplied rewards as "claimed by bots"
                    const claimedByBots = state.nftStakingPool.devSuppliedRewards * 0.01; // 1% of dev rewards claimed by bots
                    state.nftStakingPool.devSuppliedRewards -= claimedByBots;
                    if (state.nftStakingPool.devSuppliedRewards < 0) state.nftStakingPool.devSuppliedRewards = 0;
                    updateTransactionStatus(`Bots claimed ${claimedByBots.toFixed(4)} ${state.nftStakingPool.rewardToken} from NFT staking.`, 'info');
                    renderNFTUI();
                }
            }
        }


        // --- Event Listeners ---
        window.onload = function() {
            initThreeJS();
            animateThreeJS();
            onWindowResize(); // Initial resize
            window.addEventListener('resize', onWindowResize);
            updateBalancesUI(); // Initial balance display
            renderTransactionHistory(); // Initial history display
            renderLiquidityPoolsUI(); // Initial liquidity pool display
            renderProposalsUI(); // Initial proposals display
            renderLaunchpadUI(); // Initial launchpad display
            renderTokenInfoUI(); // Initial token info display
            renderStakingPoolsUI(); // Initial staking pools display
            renderShortItHistory(); // Initial short-it history
            renderNFTUI(); // Initial NFT UI
            renderDashboardUI(); // Initial dashboard display
            updatePortfolioTrackerUI(); // Initial portfolio display

            // Start bot activity simulation
            setInterval(simulateBotActivity, 5000); // Update every 5 seconds
            // Check proposal status periodically
            setInterval(checkProposalStatus, 1000); // Check every second
            // Periodically launch new tokens
            setInterval(launchNewTokenGenesis, 60 * 1000 * 1); // Launch a new token every 1 minute
            // Check genesis pools for launch
            setInterval(checkGenesisPoolsAndLaunch, 1000); // Check every second
            // Periodically add new proposals
            setInterval(generateRandomProposal, 60 * 1000 * 5); // New proposal every 5 minutes
        };


        connectWalletBtn.addEventListener('click', () => {
            state.isConnected = !state.isConnected;
            if (state.isConnected) {
                connectWalletBtn.textContent = 'Wallet Connected';
                connectWalletBtn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                connectWalletBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                state.userVotingPower = state.balances.GOV; // Set user voting power to current GOV balance
                updateTransactionStatus('Wallet connected successfully!', 'info');
            } else {
                connectWalletBtn.textContent = 'Connect Wallet';
                connectWalletBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                connectWalletBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
                state.userVotingPower = 0; // Reset voting power
                updateTransactionStatus('Wallet disconnected.', 'info');
            }
            renderProposalsUI(); // Re-render proposals to update vote button states
            renderLaunchpadUI(); // Re-render launchpad to update stake button states
            renderStakingPoolsUI(); // Re-render staking pools to update stake button states
            updateShortItGameArea(); // Re-render short-it game area
            renderNFTUI(); // Re-render NFT UI
        });

        swapTabBtn.addEventListener('click', () => {
            swapTabBtn.classList.add('active');
            bridgeTabBtn.classList.remove('active');
            liquidityTabBtn.classList.remove('active');
            launchpadTabBtn.classList.remove('active');
            tokensTabBtn.classList.remove('active');
            stakingTabBtn.classList.remove('active');
            shortItTabBtn.classList.remove('active');
            nftTabBtn.classList.remove('active'); // New
            governanceTabBtn.classList.remove('active');
            dashboardTabBtn.classList.remove('active');
            swapInterface.classList.remove('hidden');
            bridgeInterface.classList.add('hidden');
            liquidityInterface.classList.add('hidden');
            launchpadInterface.classList.add('hidden');
            tokensInterface.classList.add('hidden');
            stakingInterface.classList.add('hidden');
            shortItInterface.classList.add('hidden');
            nftInterface.classList.add('hidden'); // New
            governanceInterface.classList.add('hidden');
            dashboardInterface.classList.add('hidden');
            updateTransactionStatus('No active transactions.', 'info'); // Clear status when switching tabs
            calculateSwapOutput(); // Recalculate output based on current tokens
        });

        bridgeTabBtn.addEventListener('click', () => {
            bridgeTabBtn.classList.add('active');
            swapTabBtn.classList.remove('active');
            liquidityTabBtn.classList.remove('active');
            launchpadTabBtn.classList.remove('active');
            tokensTabBtn.classList.remove('active');
            stakingTabBtn.classList.remove('active');
            shortItTabBtn.classList.remove('active');
            nftTabBtn.classList.remove('active'); // New
            governanceTabBtn.classList.remove('active');
            dashboardTabBtn.classList.remove('active');
            bridgeInterface.classList.remove('hidden');
            swapInterface.classList.add('hidden');
            liquidityInterface.classList.add('hidden');
            launchpadInterface.classList.add('hidden');
            tokensInterface.classList.add('hidden');
            stakingInterface.classList.add('hidden');
            shortItInterface.classList.add('hidden');
            nftInterface.classList.add('hidden'); // New
            governanceInterface.classList.add('hidden');
            dashboardInterface.classList.add('hidden');
            updateTransactionStatus('No active transactions.', 'info'); // Clear status when switching tabs
            calculateBridgeOutput(); // Recalculate output based on current tokens
        });

        liquidityTabBtn.addEventListener('click', () => {
            liquidityTabBtn.classList.add('active');
            swapTabBtn.classList.remove('active');
            bridgeTabBtn.classList.remove('active');
            launchpadTabBtn.classList.remove('active');
            tokensTabBtn.classList.remove('active');
            stakingTabBtn.classList.remove('active');
            shortItTabBtn.classList.remove('active');
            nftTabBtn.classList.remove('active'); // New
            governanceTabBtn.classList.remove('active');
            dashboardTabBtn.classList.remove('active');
            liquidityInterface.classList.remove('hidden');
            swapInterface.classList.add('hidden');
            bridgeInterface.classList.add('hidden');
            launchpadInterface.classList.add('hidden');
            tokensInterface.classList.add('hidden');
            stakingInterface.classList.add('hidden');
            shortItInterface.classList.add('hidden');
            nftInterface.classList.add('hidden'); // New
            governanceInterface.classList.add('hidden');
            dashboardInterface.classList.add('hidden');
            updateTransactionStatus('No active transactions.', 'info'); // Clear status when switching tabs
            renderLiquidityPoolsUI(); // Re-render pools when tab is active
            calculateAddLiquidityOutput(); // Recalculate for add liquidity
        });

        launchpadTabBtn.addEventListener('click', () => { // New
            launchpadTabBtn.classList.add('active');
            swapTabBtn.classList.remove('active');
            bridgeTabBtn.classList.remove('active');
            liquidityTabBtn.classList.remove('active');
            tokensTabBtn.classList.remove('active');
            stakingTabBtn.classList.remove('active');
            shortItTabBtn.classList.remove('active');
            nftTabBtn.classList.remove('active'); // New
            governanceTabBtn.classList.remove('active');
            dashboardTabBtn.classList.remove('active');
            launchpadInterface.classList.remove('hidden');
            swapInterface.classList.add('hidden');
            bridgeInterface.classList.add('hidden');
            liquidityInterface.classList.add('hidden');
            tokensInterface.classList.add('hidden');
            stakingInterface.classList.add('hidden');
            shortItInterface.classList.add('hidden');
            nftInterface.classList.add('hidden'); // New
            governanceInterface.classList.add('hidden');
            dashboardInterface.classList.add('hidden');
            updateTransactionStatus('No active transactions.', 'info');
            renderLaunchpadUI(); // Re-render launchpad pools
        });

        tokensTabBtn.addEventListener('click', () => { // New
            tokensTabBtn.classList.add('active');
            swapTabBtn.classList.remove('active');
            bridgeTabBtn.classList.remove('active');
            liquidityTabBtn.classList.remove('active');
            launchpadTabBtn.classList.remove('active');
            stakingTabBtn.classList.remove('active');
            shortItTabBtn.classList.remove('active');
            nftTabBtn.classList.remove('active'); // New
            governanceTabBtn.classList.remove('active');
            dashboardTabBtn.classList.remove('active');
            tokensInterface.classList.remove('hidden');
            swapInterface.classList.add('hidden');
            bridgeInterface.classList.add('hidden');
            liquidityInterface.classList.add('hidden');
            launchpadInterface.classList.add('hidden');
            stakingInterface.classList.add('hidden');
            shortItInterface.classList.add('hidden');
            nftInterface.classList.add('hidden'); // New
            governanceInterface.classList.add('hidden');
            dashboardInterface.classList.add('hidden');
            updateTransactionStatus('No active transactions.', 'info');
            renderTokenInfoUI(); // Re-render token info
        });

        stakingTabBtn.addEventListener('click', () => { // New
            stakingTabBtn.classList.add('active');
            swapTabBtn.classList.remove('active');
            bridgeTabBtn.classList.remove('active');
            liquidityTabBtn.classList.remove('active');
            launchpadTabBtn.classList.remove('active');
            tokensTabBtn.classList.remove('active');
            shortItTabBtn.classList.remove('active');
            nftTabBtn.classList.remove('active'); // New
            governanceTabBtn.classList.remove('active');
            dashboardTabBtn.classList.remove('active');
            stakingInterface.classList.remove('hidden');
            swapInterface.classList.add('hidden');
            bridgeInterface.classList.add('hidden');
            liquidityInterface.classList.add('hidden');
            launchpadInterface.classList.add('hidden');
            tokensInterface.classList.add('hidden');
            shortItInterface.classList.add('hidden');
            nftInterface.classList.add('hidden'); // New
            governanceInterface.classList.add('hidden');
            dashboardInterface.classList.add('hidden');
            updateTransactionStatus('No active transactions.', 'info');
            renderStakingPoolsUI(); // Re-render staking pools
        });

        shortItTabBtn.addEventListener('click', () => { // New
            shortItTabBtn.classList.add('active');
            swapTabBtn.classList.remove('active');
            bridgeTabBtn.classList.remove('active');
            liquidityTabBtn.classList.remove('active');
            launchpadTabBtn.classList.remove('active');
            tokensTabBtn.classList.remove('active');
            stakingTabBtn.classList.remove('active');
            nftTabBtn.classList.remove('active'); // New
            governanceTabBtn.classList.remove('active');
            dashboardTabBtn.classList.remove('active');
            shortItInterface.classList.remove('hidden');
            swapInterface.classList.add('hidden');
            bridgeInterface.classList.add('hidden');
            liquidityInterface.classList.add('hidden');
            launchpadInterface.classList.add('hidden');
            tokensInterface.classList.add('hidden');
            stakingInterface.classList.add('hidden');
            nftInterface.classList.add('hidden'); // New
            governanceInterface.classList.add('hidden');
            dashboardInterface.classList.add('hidden');
            updateTransactionStatus('No active transactions.', 'info');
            updateShortItGameArea(); // Render short-it game area
        });

        nftTabBtn.addEventListener('click', () => { // New
            nftTabBtn.classList.add('active');
            swapTabBtn.classList.remove('active');
            bridgeTabBtn.classList.remove('active');
            liquidityTabBtn.classList.remove('active');
            launchpadTabBtn.classList.remove('active');
            tokensTabBtn.classList.remove('active');
            stakingTabBtn.classList.remove('active');
            shortItTabBtn.classList.remove('active');
            governanceTabBtn.classList.remove('active');
            dashboardTabBtn.classList.remove('active');
            nftInterface.classList.remove('hidden');
            swapInterface.classList.add('hidden');
            bridgeInterface.classList.add('hidden');
            liquidityInterface.classList.add('hidden');
            launchpadInterface.classList.add('hidden');
            tokensInterface.classList.add('hidden');
            stakingInterface.classList.add('hidden');
            shortItInterface.classList.add('hidden');
            governanceInterface.classList.add('hidden');
            dashboardInterface.classList.add('hidden');
            updateTransactionStatus('No active transactions.', 'info');
            renderNFTUI(); // Render NFT UI
        });

        governanceTabBtn.addEventListener('click', () => {
            governanceTabBtn.classList.add('active');
            swapTabBtn.classList.remove('active');
            bridgeTabBtn.classList.remove('active');
            liquidityTabBtn.classList.remove('active');
            launchpadTabBtn.classList.remove('active');
            tokensTabBtn.classList.remove('active');
            stakingTabBtn.classList.remove('active');
            shortItTabBtn.classList.remove('active');
            nftTabBtn.classList.remove('active'); // New
            dashboardTabBtn.classList.remove('active');
            governanceInterface.classList.remove('hidden');
            swapInterface.classList.add('hidden');
            bridgeInterface.classList.add('hidden');
            liquidityInterface.classList.add('hidden');
            launchpadInterface.classList.add('hidden');
            tokensInterface.classList.add('hidden');
            stakingInterface.classList.add('hidden');
            shortItInterface.classList.add('hidden');
            nftInterface.classList.add('hidden'); // New
            dashboardInterface.classList.add('hidden');
            updateTransactionStatus('No active transactions.', 'info'); // Clear status when switching tabs
            renderProposalsUI(); // Re-render proposals when tab is active
        });

        dashboardTabBtn.addEventListener('click', () => { // New
            dashboardTabBtn.classList.add('active');
            swapTabBtn.classList.remove('active');
            bridgeTabBtn.classList.remove('active');
            liquidityTabBtn.classList.remove('active');
            launchpadTabBtn.classList.remove('active');
            tokensTabBtn.classList.remove('active');
            stakingTabBtn.classList.remove('active');
            shortItTabBtn.classList.remove('active');
            nftTabBtn.classList.remove('active'); // New
            governanceTabBtn.classList.remove('active');
            dashboardInterface.classList.remove('hidden');
            swapInterface.classList.add('hidden');
            bridgeInterface.classList.add('hidden');
            liquidityInterface.classList.add('hidden');
            launchpadInterface.classList.add('hidden');
            tokensInterface.classList.add('hidden');
            stakingInterface.classList.add('hidden');
            shortItInterface.classList.add('hidden');
            nftInterface.classList.add('hidden'); // New
            governanceInterface.classList.add('hidden');
            updateTransactionStatus('No active transactions.', 'info');
            renderDashboardUI(); // Re-render dashboard stats
        });


        // Swap input change listeners
        fromAmountSwap.addEventListener('input', calculateSwapOutput);
        fromTokenSwap.addEventListener('change', calculateSwapOutput);
        toTokenSwap.addEventListener('change', calculateSwapOutput);
        swapBtn.addEventListener('click', handleSwap);

        // Bridge input change listeners
        fromAmountBridge.addEventListener('input', calculateBridgeOutput);
        fromTokenBridge.addEventListener('change', calculateBridgeOutput);
        fromChainBridge.addEventListener('change', calculateBridgeOutput);
        toTokenBridge.addEventListener('change', calculateBridgeOutput);
        toChainBridge.addEventListener('change', calculateBridgeOutput);
        bridgeBtn.addEventListener('click', handleBridge);

        // Liquidity input change listeners
        addLiquidityPoolSelect.addEventListener('change', calculateAddLiquidityOutput);
        addLiquidityAmountA.addEventListener('input', calculateAddLiquidityOutput);
        addLiquidityBtn.addEventListener('click', handleAddLiquidity);

        removeLiquidityPoolSelect.addEventListener('change', () => {
            // No direct calculation needed here, just ensure the select is populated correctly
        });
        removeLiquidityBtn.addEventListener('click', handleRemoveLiquidity);

        claimFeesPoolSelect.addEventListener('change', updateClaimableFeesDisplay);
        claimFeesBtn.addEventListener('click', handleClaimFees);

        // Token Info select listener
        selectTokenInfo.addEventListener('change', renderTokenInfoUI);

        // Short It listeners
        shortItTokenSelect.addEventListener('change', updateShortItGameArea);
        shortItBetUpBtn.addEventListener('click', () => handleBetShortIt('up'));
        shortItBetDownBtn.addEventListener('click', () => handleBetShortIt('down'));

        // NFT Listeners
        launchNftCollectionBtn.addEventListener('click', handleLaunchNFTCollection);
        claimNftFeesBtn.addEventListener('click', handleClaimNFTFees);
        supplyNftStakingRewardsBtn.addEventListener('click', handleSupplyNFTRewards);
        stakeMyNftBtn.addEventListener('click', handleStakeMyNFT);
        unstakeClaimNftRewardsBtn.addEventListener('click', handleUnstakeClaimNFTRewards);


        // Max button handler
        function handleMaxButtonClick(event) {
            const inputId = event.target.dataset.inputId;
            const balanceToken = event.target.dataset.balanceToken;
            const inputElement = document.getElementById(inputId);

            let amountToSet = 0;
            if (balanceToken === 'selectedShortItToken') {
                const selectedToken = shortItTokenSelect.value;
                if (selectedToken && state.balances[selectedToken] !== undefined) {
                    amountToSet = state.balances[selectedToken];
                }
            } else if (state.balances[balanceToken] !== undefined) {
                amountToSet = state.balances[balanceToken];
            }

            if (inputElement) {
                inputElement.value = amountToSet.toFixed(2);
                // Trigger relevant calculation if applicable
                if (inputId.includes('add-liquidity-amount-a')) {
                    calculateAddLiquidityOutput();
                }
            }
        }

        function generateRandomProposal() {
            const proposalTypes = [
                {
                    title: 'Increase Liquidity Pool Fee to 0.5%',
                    description: 'This proposal aims to increase the trading fee on all liquidity pools to boost platform revenue.',
                    effect: { type: 'adjustSwapFee', newFee: 0.005 }
                },
                {
                    title: 'Reduce Bridge Fee to 0.005 ETH',
                    description: 'A proposal to reduce the bridge fee, making cross-chain transfers more affordable.',
                    effect: { type: 'adjustBridgeFee', newFee: 0.005 }
                },
                {
                    title: 'Increase GOV Staking Rewards by 10%',
                    description: 'This proposal seeks to increase the rewards for GOV stakers, encouraging more participation in governance.',
                    effect: { type: 'adjustGovStakingRewards', percentageIncrease: 0.10 }
                },
                {
                    title: 'Launch New Liquidity Mining Program',
                    description: 'A proposal to allocate additional GOV tokens for a new liquidity mining program in a selected pool.',
                    effect: { type: 'newLiquidityMining', pool: 'ETH-USDC', amount: 500 } // Example
                },
                {
                    title: 'Adjust Short It Payout Multiplier (x3 for 3s)',
                    description: 'A proposal to increase the payout for 3-second Short It predictions to attract more players.',
                    effect: { type: 'adjustShortItPayout', time: 3, newMultiplier: 3 }
                },
                {
                    title: 'Decrease Staking Pool APR by 5%',
                    description: 'A proposal to slightly reduce the APR on all token staking pools to manage token emissions.',
                    effect: { type: 'adjustAllStakingApr', percentageDecrease: 0.05 }
                }
            ];

            const randomProposal = proposalTypes[Math.floor(Math.random() * proposalTypes.length)];
            const newProposal = {
                id: `prop-${proposalCounter++}`,
                title: randomProposal.title,
                description: randomProposal.description,
                status: 'active',
                votesYes: Math.floor(Math.random() * 100) + 50, // Initial bot votes
                votesNo: Math.floor(Math.random() * 50) + 20,
                totalVotingPower: 0, // Will be sum of yes/no
                endsAt: Date.now() + 60 * 1000 * (Math.floor(Math.random() * 5) + 5), // Ends in 5-10 minutes
                effect: randomProposal.effect,
                hasVoted: false
            };
            newProposal.totalVotingPower = newProposal.votesYes + newProposal.votesNo;
            state.proposals.push(newProposal);
            renderProposalsUI();
            updateTransactionStatus(`New Governance Proposal: "${newProposal.title}"`, 'info');
        }


        // Initial calculations
        calculateSwapOutput();
        calculateBridgeOutput();
        calculateAddLiquidityOutput();

        // Ensure initial to-token for swap is different from from-token
        if (fromTokenSwap.value === toTokenSwap.value) {
            toTokenSwap.value = fromTokenSwap.options[1] ? fromTokenSwap.options[1].value : 'USDC';
            calculateSwapOutput();
        }
        // Ensure initial to-chain for bridge is different from from-chain
        if (fromChainBridge.value === toChainBridge.value) {
            toChainBridge.value = fromChainBridge.options[1] ? fromChainBridge.options[1].value : 'BSC';
            calculateBridgeOutput();
        }

    </script>
</body>
</html>
