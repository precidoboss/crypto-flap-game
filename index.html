<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PRECIDO DEX</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Recharts for Charts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.12.7/recharts.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            @apply bg-gray-900 text-gray-100;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        /* Custom scrollbar for dark mode */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            @apply bg-gray-800;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            @apply bg-cyan-700;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            @apply bg-cyan-600;
        }

        /* General Card Styling */
        .card {
            @apply bg-gray-800 rounded-xl shadow-lg p-6 transition-all duration-300 ease-in-out border border-gray-700;
        }

        /* Card Hover Effect */
        .card.interactive:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 255, 255, 0.2), 0 4px 8px rgba(0, 255, 255, 0.1);
            @apply border-cyan-500;
        }

        /* Card Data Change Glow Effect */
        .card.glow {
            animation: cardGlow 0.7s ease-out forwards;
        }

        @keyframes cardGlow {
            0% {
                box-shadow: 0 0 0px rgba(0, 255, 255, 0);
            }
            50% {
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), 0 0 40px rgba(0, 255, 255, 0.2);
            }
            100% {
                box-shadow: 0 0 0px rgba(0, 255, 255, 0);
            }
        }

        /* Button Click Effect */
        .btn-primary, .btn-secondary, .btn-danger {
            @apply rounded-lg px-4 py-2 font-semibold transition-all duration-150 ease-in-out;
        }

        .btn-primary {
            @apply bg-cyan-600 text-white hover:bg-cyan-700 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-opacity-75;
        }

        .btn-primary:active {
            transform: scale(0.98);
        }

        .btn-secondary {
            @apply bg-gray-700 text-gray-200 hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-75;
        }

        .btn-secondary:active {
            transform: scale(0.98);
        }

        .btn-danger {
            @apply bg-red-600 text-white hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75;
        }

        .btn-danger:active {
            transform: scale(0.98);
        }

        .btn-disabled {
            @apply opacity-50 cursor-not-allowed;
        }

        /* Page Transitions */
        .page-enter {
            opacity: 0;
            transform: translateX(10%);
        }

        .page-enter-active {
            opacity: 1;
            transform: translateX(0%);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

        .page-exit {
            opacity: 1;
            transform: translateX(0%);
        }

        .page-exit-active {
            opacity: 0;
            transform: translateX(-10%);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

        /* Loading Skeletons */
        .skeleton {
            @apply bg-gray-700 rounded-md animate-pulse;
        }

        .skeleton-text {
            height: 1em;
            margin-bottom: 0.5em;
        }

        .skeleton-line {
            height: 1.2em;
            margin-bottom: 0.8em;
        }

        /* Swap Route Animation */
        .swap-route {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-top: 1rem;
            overflow: hidden; /* Hide overflow of glowing line */
        }

        .swap-route .token-icon {
            @apply text-xl text-cyan-400;
        }

        .swap-route .arrow {
            @apply text-gray-400 text-xl mx-2;
        }

        .swap-route .glowing-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.8), transparent);
            width: 0%;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            animation: flowLight 2s forwards;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
        }

        @keyframes flowLight {
            0% {
                width: 0%;
                left: 0%;
            }
            50% {
                width: 100%;
                left: 0%;
            }
            100% {
                width: 0%;
                left: 100%;
            }
        }

        /* Confirmation Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            @apply bg-black bg-opacity-70 flex items-center justify-center z-50;
        }

        .modal-content {
            @apply bg-gray-800 p-8 rounded-xl shadow-2xl border border-gray-700 text-center;
            max-width: 400px;
            animation: modalFadeInScale 0.3s ease-out forwards;
        }

        @keyframes modalFadeInScale {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal-content.success {
            animation: modalFadeInScale 0.3s ease-out forwards, modalGlowGreen 0.5s ease-out forwards;
        }

        @keyframes modalGlowGreen {
            0% {
                box-shadow: 0 0 0px rgba(0, 255, 0, 0);
            }
            50% {
                box-shadow: 0 0 20px rgba(0, 255, 0, 0.4);
            }
            100% {
                box-shadow: 0 0 0px rgba(0, 255, 0, 0);
            }
        }


        /* Notification Pop-ups (Toast) */
        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .toast {
            @apply p-3 rounded-lg shadow-xl text-sm;
            animation: slideInFromRight 0.3s ease-out forwards, fadeOutToRight 0.3s ease-out 2.7s forwards;
        }

        .toast.success {
            @apply bg-green-700 text-white;
        }

        .toast.error {
            @apply bg-red-700 text-white;
        }

        .toast.info {
            @apply bg-blue-700 text-white;
        }

        @keyframes slideInFromRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOutToRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        /* Epoch Timer Colors */
        .epoch-timer.normal {
            @apply text-green-400;
        }

        .epoch-timer.warning {
            @apply text-yellow-400;
        }

        .epoch-timer.critical {
            @apply text-red-500 animate-pulse;
        }

        /* Sidebar */
        .sidebar {
            @apply bg-gray-800 w-64 fixed h-full transition-all duration-300 ease-in-out z-40;
        }
        .sidebar-collapsed {
            width: 0;
            overflow: hidden;
        }
        .content-area {
            margin-left: 16rem; /* Default for desktop */
            transition: margin-left 0.3s ease-in-out;
        }
        .content-area-expanded {
            margin-left: 0; /* When sidebar is collapsed */
        }

        @media (max-width: 768px) {
            .sidebar {
                left: -16rem; /* Hide by default on mobile */
            }
            .sidebar-expanded {
                left: 0;
            }
            .content-area {
                margin-left: 0;
            }
        }
    </style>
</head>
<body class="flex min-h-screen">

    <!-- Sidebar -->
    <div id="sidebar" class="sidebar flex flex-col p-4 border-r border-gray-700">
        <div class="text-2xl font-bold text-cyan-400 mb-8">PRECIDO DEX</div>
        <nav class="flex-1">
            <a href="#" onclick="showPage('dashboard')" class="flex items-center p-3 rounded-lg text-gray-300 hover:bg-gray-700 hover:text-cyan-400 mb-2 transition-colors duration-200">
                <i class="fas fa-home mr-3"></i> Home
            </a>
            <a href="#" onclick="showPage('liquidity')" class="flex items-center p-3 rounded-lg text-gray-300 hover:bg-gray-700 hover:text-cyan-400 mb-2 transition-colors duration-200">
                <i class="fas fa-water mr-3"></i> Liquidity
            </a>
            <a href="#" onclick="showPage('voting')" class="flex items-center p-3 rounded-lg text-gray-300 hover:bg-gray-700 hover:text-cyan-400 mb-2 transition-colors duration-200">
                <i class="fas fa-vote-yea mr-3"></i> Voting
            </a>
            <a href="#" onclick="showPage('emissions')" class="flex items-center p-3 rounded-lg text-gray-300 hover:bg-gray-700 hover:text-cyan-400 mb-2 transition-colors duration-200">
                <i class="fas fa-coins mr-3"></i> Emissions
            </a>
            <a href="#" onclick="showPage('portfolio')" class="flex items-center p-3 rounded-lg text-gray-300 hover:bg-gray-700 hover:text-cyan-400 mb-2 transition-colors duration-200">
                <i class="fas fa-wallet mr-3"></i> Portfolio
            </a>
            <a href="#" onclick="showPage('tokens')" class="flex items-center p-3 rounded-lg text-gray-300 hover:bg-gray-700 hover:text-cyan-400 mb-2 transition-colors duration-200">
                <i class="fas fa-boxes mr-3"></i> Tokens
            </a>
            <a href="#" onclick="showPage('admin')" class="flex items-center p-3 rounded-lg text-gray-300 hover:bg-gray-700 hover:text-cyan-400 mb-2 transition-colors duration-200">
                <i class="fas fa-cog mr-3"></i> Admin
            </a>
            <a href="#" onclick="showPage('leaderboard')" class="flex items-center p-3 rounded-lg text-gray-300 hover:bg-gray-700 hover:text-cyan-400 mb-2 transition-colors duration-200">
                <i class="fas fa-trophy mr-3"></i> Leaderboard
            </a>
        </nav>
    </div>

    <!-- Main Content Area -->
    <div id="contentArea" class="flex-1 p-8 content-area">
        <!-- Hamburger Menu for Mobile -->
        <button id="hamburgerMenu" class="md:hidden fixed top-4 left-4 z-50 text-gray-100 text-2xl bg-gray-800 p-2 rounded-md">
            <i class="fas fa-bars"></i>
        </button>

        <!-- Page Content will be rendered here -->
        <div id="pageContent" class="transition-all duration-300 ease-in-out"></div>
    </div>

    <!-- Modals and Notifications -->
    <div id="modalContainer"></div>
    <div id="toastContainer" class="toast-container"></div>

    <script>
        // --- Global Simulation State ---
        let simulationTime = 0; // In simulated minutes
        let simulationInterval;
        let simulationSpeedMultiplier = 1; // 1x default
        let epochPeriodSeconds = 7 * 24 * 60 * 60; // Default 7 days in seconds
        let currentEpoch = 1;
        let nextEpochTime = epochPeriodSeconds; // Countdown in seconds

        let totalPDEXSupply = 1_000_000_000;
        let totalPDEXBurned = 0;
        let totalPDEXLocked = 0;
        let circulatingPDEXSupply = 0; // Calculated dynamically
        let pdexPrice = 0.01; // Initial price

        let protocolOwnedVePDEX = 0; // From initial 50% burn
        let voterIncentivesPool = 0; // From initial 35% allocation, in platform wallet
        let feesWallet = {}; // Protocol treasury, holds various tokens
        let unvepdexSupply = 0;

        let baseAssetPrices = {
            USDT: 1, // Stable
            USDC: 1, // Stable
            BTC: 95000, // Volatile
            ETH: 3500,  // Volatile
            AVAX: 25,   // Volatile
            SOL: 150,   // Volatile
            BNB: 750,   // Volatile
            SUI: 4.5,   // Volatile
            TON: 4.5    // Volatile
        };

        // All liquidity pools, including PDEX/USDT and bot-launched ones
        let liquidityPools = []; // Structure: { id, tokenA, tokenB, reserveA, reserveB, lpSupply, tvl, initialBribe, currentBribes: [{token, amount, giver, vesting}], type: 'STABLE'/'VOLATILE' }

        let userWallet = {
            USDT: 5000,
            USDC: 5000,
            BTC: 5000 / baseAssetPrices.BTC,
            ETH: 5000 / baseAssetPrices.ETH,
            AVAX: 5000 / baseAssetPrices.AVAX,
            SOL: 5000 / baseAssetPrices.SOL,
            BNB: 5000 / baseAssetPrices.BNB,
            SUI: 5000 / baseAssetPrices.SUI,
            TON: 5000 / baseAssetPrices.TON,
            PDEX: 0, // User starts with 0 PDEX, must acquire
        };
        let userVePDEXLocks = []; // { id, pdexLocked, vePDEXAmount, lockDurationWeeks, unlockTime }
        let userUNVEPDEXBalance = 0;
        let userDailyUNVEPDEXSellCount = 0; // Resets daily
        let lastSimulatedDay = 0; // For daily reset of sell count

        let transactionHistory = []; // { type, description, timestamp }

        let bots = []; // Array of bot objects
        let botAggression = { // Sliders 0-100
            trading: 50,
            liquidity: 50,
            bribing: 50,
            pdexLocking: 50,
            voting: 50
        };
        let botProfiles = {}; // For scenario editor

        let leaderboardData = {
            topBurners: [],
            topVePDEXHolders: [],
            topEarners: [],
            mostVotedPools: []
        };

        let currentActivePage = 'dashboard';
        let sidebarExpanded = window.innerWidth > 768; // Default expanded on desktop

        // --- Utility Functions ---

        /**
         * Formats a number as a USD currency string.
         * @param {number} amount
         * @returns {string}
         */
        function formatCurrency(amount) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(amount);
        }

        /**
         * Formats a number as a percentage string.
         * @param {number} value
         * @returns {string}
         */
        function formatPercentage(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'percent',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(value);
        }

        /**
         * Formats a large number with K, M, B suffixes.
         * @param {number} num
         * @returns {string}
         */
        function formatLargeNumber(num) {
            if (num >= 1_000_000_000) return (num / 1_000_000_000).toFixed(2) + 'B';
            if (num >= 1_000_000) return (num / 1_000_000).toFixed(2) + 'M';
            if (num >= 1_000) return (num / 1_000).toFixed(2) + 'K';
            return num.toFixed(2);
        }

        /**
         * Generates a unique ID.
         * @returns {string}
         */
        function generateUniqueId() {
            return crypto.randomUUID();
        }

        /**
         * Shows a temporary toast notification.
         * @param {string} message - The message to display.
         * @param {'success'|'error'|'info'} type - Type of notification.
         */
        function showToast(message, type) {
            const toastContainer = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            toastContainer.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000); // Remove after 3 seconds
        }

        /**
         * Shows a confirmation modal.
         * @param {string} title
         * @param {string} message
         * @param {function} onConfirm
         * @param {function} onCancel
         */
        function showConfirmationModal(title, message, onConfirm, onCancel = () => {}) {
            const modalContainer = document.getElementById('modalContainer');
            modalContainer.innerHTML = `
                <div class="modal-overlay">
                    <div class="modal-content">
                        <h3 class="text-xl font-bold mb-4">${title}</h3>
                        <p class="text-gray-300 mb-6">${message}</p>
                        <div class="flex justify-center space-x-4">
                            <button id="modalConfirmBtn" class="btn-primary">OK</button>
                            <button id="modalCancelBtn" class="btn-secondary">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
            const modalConfirmBtn = document.getElementById('modalConfirmBtn');
            const modalCancelBtn = document.getElementById('modalCancelBtn');

            modalConfirmBtn.onclick = () => {
                onConfirm();
                modalContainer.innerHTML = '';
            };
            modalCancelBtn.onclick = () => {
                onCancel();
                modalContainer.innerHTML = '';
            };
        }

        /**
         * Shows a simple info modal.
         * @param {string} title
         * @param {string} message
         * @param {function} onClose
         */
        function showInfoModal(title, message, onClose = () => {}) {
            const modalContainer = document.getElementById('modalContainer');
            modalContainer.innerHTML = `
                <div class="modal-overlay">
                    <div class="modal-content">
                        <h3 class="text-xl font-bold mb-4">${title}</h3>
                        <p class="text-gray-300 mb-6">${message}</p>
                        <button id="modalCloseBtn" class="btn-primary">Close</button>
                    </div>
                </div>
            `;
            document.getElementById('modalCloseBtn').onclick = () => {
                onClose();
                modalContainer.innerHTML = '';
            };
        }

        /**
         * Adds a transaction to the history.
         * @param {string} type
         * @param {string} description
         */
        function addTransaction(type, description) {
            transactionHistory.unshift({
                type,
                description,
                timestamp: simulationTime
            });
            if (transactionHistory.length > 20) { // Keep history manageable
                transactionHistory.pop();
            }
        }

        /**
         * Applies a glow effect to a UI element.
         * @param {string} elementId
         */
        function applyGlow(elementId) {
            const element = document.getElementById(elementId);
            if (element) {
                element.classList.remove('glow'); // Reset animation
                void element.offsetWidth; // Trigger reflow
                element.classList.add('glow');
            }
        }

        /**
         * Simulates a sound effect.
         * @param {string} type - 'ding'
         */
        function playSound(type) {
            // In a real app, you'd load and play audio files.
            // For this simulation, we'll just log it.
            // console.log(`Playing sound: ${type}`);
        }

        // --- Core Simulation Logic ---

        /**
         * Initializes the simulation state.
         */
        function initializeSimulation() {
            // Reset all global variables to initial state
            simulationTime = 0;
            simulationSpeedMultiplier = 1;
            epochPeriodSeconds = 7 * 24 * 60 * 60; // Default 7 days
            currentEpoch = 1;
            nextEpochTime = epochPeriodSeconds;

            totalPDEXSupply = 1_000_000_000;
            totalPDEXBurned = 0;
            totalPDEXLocked = 0;
            circulatingPDEXSupply = 0;
            pdexPrice = 0.01;

            protocolOwnedVePDEX = 0;
            voterIncentivesPool = 350_000_000; // 35% of 1B PDEX
            feesWallet = {}; // Reset treasury
            unvepdexSupply = 0;

            baseAssetPrices = {
                USDT: 1,
                USDC: 1,
                BTC: 95000,
                ETH: 3500,
                AVAX: 25,
                SOL: 150,
                BNB: 750,
                SUI: 4.5,
                TON: 4.5
            };

            liquidityPools = [];
            userWallet = {
                USDT: 5000,
                USDC: 5000,
                BTC: 5000 / baseAssetPrices.BTC,
                ETH: 5000 / baseAssetPrices.ETH,
                AVAX: 5000 / baseAssetPrices.AVAX,
                SOL: 5000 / baseAssetPrices.SOL,
                BNB: 5000 / baseAssetPrices.BNB,
                SUI: 5000 / baseAssetPrices.SUI,
                TON: 5000 / baseAssetPrices.TON,
                PDEX: 0,
            };
            userVePDEXLocks = [];
            userUNVEPDEXBalance = 0;
            userDailyUNVEPDEXSellCount = 0;
            lastSimulatedDay = 0;

            transactionHistory = [];
            bots = [];
            botAggression = {
                trading: 50,
                liquidity: 50,
                bribing: 50,
                pdexLocking: 50,
                voting: 50
            };
            botProfiles = {}; // Clear saved profiles

            leaderboardData = {
                topBurners: [],
                topVePDEXHolders: [],
                topEarners: [],
                mostVotedPools: []
            };

            // Initial PDEX burn and protocol vePDEX mint
            const initialPDEXBurnAmount = totalPDEXSupply * 0.5;
            totalPDEXBurned += initialPDEXBurnAmount;
            totalPDEXSupply -= initialPDEXBurnAmount; // This reflects the reduced total supply
            protocolOwnedVePDEX = initialPDEXBurnAmount / (208 / 4); // Assuming 4-year lock equivalent for protocol vePDEX

            // Initial Community Airdrop (to user and some bots)
            const communityAirdropAmount = 50_000_000;
            const userAirdrop = communityAirdropAmount * 0.1; // 10% to user
            userWallet.PDEX += userAirdrop;
            totalPDEXSupply -= communityAirdropAmount; // Airdropped tokens are now circulating

            // Initialize Liquidity Pools
            // PDEX/USDT (main protocol LP) - Initial Bribe: $500,000 USDT
            createLiquidityPool('PDEX', 'USDT', 100_000_000, 1_000_000, 500_000, 'VOLATILE'); // 100M PDEX, 1M USDT for $0.01 PDEX
            // Other pre-existing pools
            createLiquidityPool('ETH', 'USDT', 2000, 7_000_000, 200_000, 'VOLATILE'); // 2000 ETH * 3500 = 7M USDT
            createLiquidityPool('BTC', 'USDT', 30, 2_850_000, 300_000, 'VOLATILE'); // 30 BTC * 95000 = 2.85M USDT
            createLiquidityPool('SOL', 'USDT', 10000, 1_500_000, 150_000, 'VOLATILE'); // 10000 SOL * 150 = 1.5M USDT
            createLiquidityPool('BNB', 'USDT', 1000, 750_000, 100_000, 'VOLATILE'); // 1000 BNB * 750 = 0.75M USDT
            createLiquidityPool('ETH', 'BTC', 2000, 30, 50_000, 'VOLATILE'); // 2000 ETH, 30 BTC
            createLiquidityPool('SOL', 'ETH', 10000, 2000, 50_000, 'VOLATILE'); // 10000 SOL, 2000 ETH
            createLiquidityPool('AVAX', 'USDT', 3000, 75_000, 75_000, 'VOLATILE'); // 3000 AVAX * 25 = 75k USDT
            createLiquidityPool('SUI', 'USDT', 10000, 45_000, 25_000, 'VOLATILE'); // 10000 SUI * 4.5 = 45k USDT
            createLiquidityPool('TON', 'USDT', 10000, 45_000, 25_000, 'VOLATILE'); // 10000 TON * 4.5 = 45k USDT
            createLiquidityPool('UNVEPDEX', 'USDT', 0, 100, 0, 'STABLE', true); // UNVEPDEX selling pool, seed USDT

            // Initialize Bots
            for (let i = 0; i < 5; i++) { // 5 initial bots
                bots.push(createBot(`Bot ${i+1}`));
            }

            // Initial bot token launches (first 30 simulated minutes)
            setTimeout(() => {
                bots.forEach(bot => {
                    if (Math.random() < 0.6) botLaunchToken(bot); // Some bots launch 1-3 tokens
                });
            }, 30 * 1000 / simulationSpeedMultiplier); // 30 simulated minutes

            updateCirculatingSupply();
            updateLeaderboard();
        }

        /**
         * Creates a new liquidity pool.
         * @param {string} tokenA
         * @param {string} tokenB
         * @param {number} initialReserveA
         * @param {number} initialReserveB
         * @param {number} initialBribeAmount
         * @param {'STABLE'|'VOLATILE'} type
         * @param {boolean} isUNVEPDEXPool - True if this is the special UNVEPDEX redemption pool
         */
        function createLiquidityPool(tokenA, tokenB, initialReserveA, initialReserveB, initialBribeAmount, type, isUNVEPDEXPool = false) {
            const poolId = generateUniqueId();
            const lpSupply = Math.sqrt(initialReserveA * initialReserveB); // Simple LP token minting
            const tvl = (initialReserveA * getPrice(tokenA)) + (initialReserveB * getPrice(tokenB));

            const newPool = {
                id: poolId,
                tokenA,
                tokenB,
                reserveA: initialReserveA,
                reserveB: initialReserveB,
                lpSupply,
                tvl,
                initialBribe: initialBribeAmount,
                currentBribes: [], // { token, amount, giverId, vesting }
                votes: 0, // Total vePDEX votes for this pool
                type,
                isUNVEPDEXPool
            };

            // Add initial bribe to the pool's currentBribes
            if (initialBribeAmount > 0) {
                newPool.currentBribes.push({
                    token: 'USDT',
                    amount: initialBribeAmount,
                    giverId: 'protocol', // Protocol provides initial bribes
                    vesting: 'immediate'
                });
            }

            liquidityPools.push(newPool);
            addTransaction('Pool Created', `New ${tokenA}/${tokenB} pool created with TVL ${formatCurrency(tvl)}.`);
            return newPool;
        }


        /**
         * Gets the current price of a token in USDT.
         * For volatile assets, uses baseAssetPrices. For PDEX, calculates from PDEX/USDT pool.
         * For other custom tokens, calculates from their USDT pair if available.
         * @param {string} tokenSymbol
         * @returns {number}
         */
        function getPrice(tokenSymbol) {
            if (baseAssetPrices[tokenSymbol]) {
                return baseAssetPrices[tokenSymbol];
            }
            if (tokenSymbol === 'PDEX') {
                return pdexPrice;
            }

            // Try to find a USDT pair for custom tokens
            const usdtPool = liquidityPools.find(p =>
                (p.tokenA === tokenSymbol && p.tokenB === 'USDT') ||
                (p.tokenB === tokenSymbol && p.tokenA === 'USDT')
            );

            if (usdtPool) {
                if (usdtPool.tokenA === tokenSymbol) {
                    return usdtPool.reserveB / usdtPool.reserveA;
                } else {
                    return usdtPool.reserveA / usdtPool.reserveB;
                }
            }
            return 0; // Fallback if price cannot be determined
        }

        /**
         * Updates the circulating supply of PDEX.
         */
        function updateCirculatingSupply() {
            circulatingPDEXSupply = totalPDEXSupply - totalPDEXBurned - totalPDEXLocked;
            if (circulatingPDEXSupply < 0) circulatingPDEXSupply = 0; // Should not happen with correct logic
        }

        /**
         * The main simulation loop.
         */
        function advanceTime() {
            simulationTime++; // Increment simulated minutes

            // Daily reset for UNVEPDEX selling
            const currentSimulatedDay = Math.floor(simulationTime / (24 * 60));
            if (currentSimulatedDay > lastSimulatedDay) {
                userDailyUNVEPDEXSellCount = 0;
                lastSimulatedDay = currentSimulatedDay;
            }

            // Update prices every 10 simulated minutes
            if (simulationTime % 10 === 0) {
                updateVolatileAssetPrices();
                updatePoolTVLs(); // TVL depends on prices
                applyGlow('pdexPriceCard'); // Signal price update
            }

            // Run bot actions every 2 simulated minutes
            if (simulationTime % 2 === 0) {
                runBotActions();
            }

            // Check for epoch end every second of real time (effectively every simulated second)
            nextEpochTime--;
            if (nextEpochTime <= 0) {
                if (voterIncentivesPool <= 0) {
                    showToast("Epoch frozen: Voter Incentives pool is empty!", 'error');
                    // Timer remains frozen until refilled
                    nextEpochTime = 0; // Ensure it stays at 0
                } else {
                    endEpoch();
                    nextEpochTime = epochPeriodSeconds; // Reset for next epoch
                }
            }

            updateUI(); // Update UI every simulated minute
        }

        /**
         * Updates volatile asset prices based on correlated random walk.
         */
        function updateVolatileAssetPrices() {
            const assets = ['BTC', 'ETH', 'AVAX', 'SOL', 'BNB', 'SUI', 'TON'];
            const changes = {};

            // Calculate base changes
            assets.forEach(asset => {
                const maxChange = baseAssetPrices[asset] * 0.05; // Up to +/- 5%
                changes[asset] = (Math.random() * 2 - 1) * maxChange; // Random change
            });

            // Apply correlations
            // BTC & ETH (Strong Correlation)
            const btcEthAvgChange = (changes.BTC + changes.ETH) / 2;
            changes.BTC = btcEthAvgChange * (Math.random() * 0.2 + 0.8); // 0.8-1.0 correlation
            changes.ETH = btcEthAvgChange * (Math.random() * 0.2 + 0.8);

            // SOL, AVAX, BNB (Medium Correlation)
            const solAvaxBnbAvgChange = (changes.SOL + changes.AVAX + changes.BNB) / 3;
            changes.SOL = solAvaxBnbAvgChange * (Math.random() * 0.4 + 0.6); // 0.6-1.0 correlation
            changes.AVAX = solAvaxBnbAvgChange * (Math.random() * 0.4 + 0.6);
            changes.BNB = solAvaxBnbAvgChange * (Math.random() * 0.4 + 0.6);

            // SUI & TON (Weak/No Correlation - mostly independent)
            // Their changes remain mostly random from initial calculation

            // Apply changes and enforce ranges
            const ranges = {
                BTC: { min: 90000, max: 100000 },
                ETH: { min: 3000, max: 4000 },
                AVAX: { min: 20, max: 30 },
                SOL: { min: 100, max: 200 },
                BNB: { min: 700, max: 800 },
                SUI: { min: 4, max: 5 },
                TON: { min: 4, max: 5 }
            };

            assets.forEach(asset => {
                let newPrice = baseAssetPrices[asset] + changes[asset];
                newPrice = Math.max(ranges[asset].min, Math.min(ranges[asset].max, newPrice));
                baseAssetPrices[asset] = newPrice;
            });

            // Update PDEX price based on its pool (assuming PDEX/USDT is the main driver)
            const pdexUsdtPool = liquidityPools.find(p => p.tokenA === 'PDEX' && p.tokenB === 'USDT');
            if (pdexUsdtPool) {
                pdexPrice = pdexUsdtPool.reserveB / pdexUsdtPool.reserveA;
            }
        }

        /**
         * Updates the TVL for all liquidity pools.
         */
        function updatePoolTVLs() {
            liquidityPools.forEach(pool => {
                pool.tvl = (pool.reserveA * getPrice(pool.tokenA)) + (pool.reserveB * getPrice(pool.tokenB));
            });
        }

        /**
         * Ends the current epoch and distributes emissions/bribes.
         */
        function endEpoch() {
            currentEpoch++;
            addTransaction('Epoch End', `Epoch ${currentEpoch - 1} ended. New Epoch ${currentEpoch} begins.`);

            // 1. Calculate weekly emission pool target (0.5% of total PDEX supply)
            const weeklyEmissionTarget = totalPDEXSupply * 0.005;

            // 2. Protocol-owned vePDEX votes for highest TVL pools and claims emissions
            const sortedPoolsByTVL = [...liquidityPools].sort((a, b) => b.tvl - a.tvl);
            const protocolVoteAllocation = {};
            if (sortedPoolsByTVL.length > 0) {
                // Protocol votes 100% for the highest TVL pool
                protocolVoteAllocation[sortedPoolsByTVL[0].id] = protocolOwnedVePDEX;
            }

            let protocolClaimedEmissions = 0;
            // Simulate protocol claiming emissions (simplified: assume it gets its share of target)
            // In a real system, this would be based on actual emissions *after* user votes.
            // For simulation, we'll make it simpler: if protocol had 50% of total vePDEX, it would get 50% of the target.
            // Here, protocolOwnedVePDEX is a fixed amount, so we'll calculate its theoretical share.
            const totalVePDEX = calculateTotalVePDEX();
            if (totalVePDEX > 0 && protocolOwnedVePDEX > 0) {
                const protocolShareOfVotes = protocolOwnedVePDEX / totalVePDEX;
                protocolClaimedEmissions = weeklyEmissionTarget * protocolShareOfVotes;
            }


            // 3. Dynamic Adjustment Logic (Voter Incentives Pool)
            let actualEmissionPoolForNextEpoch = 0;
            if (protocolClaimedEmissions < weeklyEmissionTarget) {
                const differenceNeeded = weeklyEmissionTarget - protocolClaimedEmissions;
                if (voterIncentivesPool >= differenceNeeded) {
                    voterIncentivesPool -= differenceNeeded;
                    actualEmissionPoolForNextEpoch = weeklyEmissionTarget;
                    addTransaction('Voter Incentives Adjustment', `Deducted ${formatLargeNumber(differenceNeeded)} PDEX from Voter Incentives pool to meet emission target.`);
                } else {
                    // Voter Incentives pool runs dry, epoch freezes
                    actualEmissionPoolForNextEpoch = voterIncentivesPool + protocolClaimedEmissions;
                    voterIncentivesPool = 0; // Empty the pool
                    showToast("Epoch frozen: Voter Incentives pool is empty! Admin intervention required.", 'error');
                    nextEpochTime = 0; // Freeze timer
                    return; // Stop epoch processing
                }
            } else {
                // Protocol claimed emissions meet or exceed target
                actualEmissionPoolForNextEpoch = protocolClaimedEmissions;
                addTransaction('Protocol Performance', `Protocol claimed ${formatLargeNumber(protocolClaimedEmissions)} PDEX, exceeding emission target. Full amount added to next epoch's pool.`);
            }

            // 4. Distribute Emissions to Voters
            distributeEmissions(actualEmissionPoolForNextEpoch);

            // 5. Distribute Bribes
            distributeBribes();

            // Reset votes for next epoch and clear old bribes
            liquidityPools.forEach(pool => {
                pool.votes = 0; // Reset votes for the new epoch
                pool.currentBribes = pool.currentBribes.filter(bribe => bribe.vesting !== 'immediate'); // Remove claimed bribes
                // Handle multi-epoch vesting bribes (not implemented in detail but placeholder)
            });

            // Reset daily UNVEPDEX sell count for all users (including bots)
            userDailyUNVEPDEXSellCount = 0; // For the human user
            bots.forEach(bot => bot.dailyUNVEPDEXSellCount = 0);

            updateLeaderboard();
            updateUI();
        }

        /**
         * Calculates total vePDEX across all users and bots.
         * @returns {number}
         */
        function calculateTotalVePDEX() {
            let total = protocolOwnedVePDEX; // Include protocol's vePDEX
            userVePDEXLocks.forEach(lock => total += lock.vePDEXAmount);
            bots.forEach(bot => bot.vePDEXLocks.forEach(lock => total += lock.vePDEXAmount));
            return total;
        }

        /**
         * Distributes PDEX emissions to voters based on their vePDEX votes.
         * @param {number} totalEmissionAmount - The total PDEX available for this epoch's emissions.
         */
        function distributeEmissions(totalEmissionAmount) {
            const poolVoteTotals = {}; // { poolId: totalVePDEXVotes }
            let grandTotalVePDEXVotes = 0;

            // Aggregate votes for each pool from users and bots
            liquidityPools.forEach(pool => {
                poolVoteTotals[pool.id] = 0;
            });

            userVePDEXLocks.forEach(lock => {
                if (lock.votedPoolId && poolVoteTotals[lock.votedPoolId] !== undefined) {
                    poolVoteTotals[lock.votedPoolId] += lock.vePDEXAmount;
                }
            });

            bots.forEach(bot => {
                bot.vePDEXLocks.forEach(lock => {
                    if (lock.votedPoolId && poolVoteTotals[lock.votedPoolId] !== undefined) {
                        poolVoteTotals[lock.votedPoolId] += lock.vePDEXAmount;
                    }
                });
            });

            // Calculate grand total votes
            for (const poolId in poolVoteTotals) {
                grandTotalVePDEXVotes += poolVoteTotals[poolId];
            }

            if (grandTotalVePDEXVotes === 0) {
                addTransaction('Emissions', 'No votes cast this epoch, no PDEX emissions distributed.');
                return;
            }

            // Distribute emissions proportionally
            liquidityPools.forEach(pool => {
                const poolVotes = poolVoteTotals[pool.id] || 0;
                if (poolVotes > 0) {
                    const poolEmissionShare = (poolVotes / grandTotalVePDEXVotes) * totalEmissionAmount;

                    // Distribute to individual voters for this pool
                    userVePDEXLocks.forEach(lock => {
                        if (lock.votedPoolId === pool.id) {
                            const userShare = (lock.vePDEXAmount / poolVotes) * poolEmissionShare;
                            userWallet.PDEX += userShare;
                            addTransaction('Emissions Claimed', `User earned ${formatLargeNumber(userShare)} PDEX from ${pool.tokenA}/${pool.tokenB} emissions.`);
                        }
                    });

                    bots.forEach(bot => {
                        bot.vePDEXLocks.forEach(lock => {
                            if (lock.votedPoolId === pool.id) {
                                const botShare = (lock.vePDEXAmount / poolVotes) * poolEmissionShare;
                                bot.wallet.PDEX += botShare;
                                addTransaction('Emissions Claimed', `Bot ${bot.id} earned ${formatLargeNumber(botShare)} PDEX from ${pool.tokenA}/${pool.tokenB} emissions.`);
                            }
                        });
                    });
                }
            });
            addTransaction('Emissions', `Total ${formatLargeNumber(totalEmissionAmount)} PDEX distributed as emissions.`);
        }


        /**
         * Distributes bribes to voters based on their vePDEX votes for bribed pools.
         */
        function distributeBribes() {
            liquidityPools.forEach(pool => {
                if (pool.currentBribes.length > 0) {
                    const poolVoteTotalsForBribes = {}; // { voterId: vePDEXVotes }
                    let totalVotesForPool = 0;

                    // Aggregate votes for this specific pool
                    userVePDEXLocks.forEach(lock => {
                        if (lock.votedPoolId === pool.id) {
                            poolVoteTotalsForBribes['user'] = (poolVoteTotalsForBribes['user'] || 0) + lock.vePDEXAmount;
                            totalVotesForPool += lock.vePDEXAmount;
                        }
                    });
                    bots.forEach(bot => {
                        bot.vePDEXLocks.forEach(lock => {
                            if (lock.votedPoolId === pool.id) {
                                poolVoteTotalsForBribes[bot.id] = (poolVoteTotalsForBribes[bot.id] || 0) + lock.vePDEXAmount;
                                totalVotesForPool += lock.vePDEXAmount;
                            }
                        });
                    });

                    if (totalVotesForPool === 0) {
                        addTransaction('Bribes', `No votes for ${pool.tokenA}/${pool.tokenB} pool, bribes not distributed.`);
                        // Return bribes to givers or burn them if no voters
                        pool.currentBribes.forEach(bribe => {
                            if (bribe.giverId === 'user') {
                                userWallet[bribe.token] = (userWallet[bribe.token] || 0) + bribe.amount;
                                addTransaction('Bribe Refunded', `Your ${formatLargeNumber(bribe.amount)} ${bribe.token} bribe for ${pool.tokenA}/${pool.tokenB} was refunded due to no votes.`);
                            } else if (bribe.giverId.startsWith('Bot')) {
                                const bot = bots.find(b => b.id === bribe.giverId);
                                if (bot) {
                                    bot.wallet[bribe.token] = (bot.wallet[bribe.token] || 0) + bribe.amount;
                                    addTransaction('Bribe Refunded', `Bot ${bot.id}'s ${formatLargeNumber(bribe.amount)} ${bribe.token} bribe for ${pool.tokenA}/${pool.tokenB} was refunded due to no votes.`);
                                }
                            }
                            // Protocol bribes could be burned or returned to treasury
                        });
                        pool.currentBribes = []; // Clear bribes after processing
                        return;
                    }

                    pool.currentBribes.forEach(bribe => {
                        const bribeAmount = bribe.amount;
                        const bribeToken = bribe.token;

                        // Distribute this specific bribe
                        for (const voterId in poolVoteTotalsForBribes) {
                            const voterVotes = poolVoteTotalsForBribes[voterId];
                            const voterShare = (voterVotes / totalVotesForPool) * bribeAmount;

                            if (voterId === 'user') {
                                userWallet[bribeToken] = (userWallet[bribeToken] || 0) + voterShare;
                                addTransaction('Bribe Claimed', `User earned ${formatLargeNumber(voterShare)} ${bribeToken} from ${pool.tokenA}/${pool.tokenB} bribes.`);
                            } else if (voterId.startsWith('Bot')) {
                                const bot = bots.find(b => b.id === voterId);
                                if (bot) {
                                    bot.wallet[bribeToken] = (bot.wallet[bribeToken] || 0) + voterShare;
                                    addTransaction('Bribe Claimed', `Bot ${bot.id} earned ${formatLargeNumber(voterShare)} ${bribeToken} from ${pool.tokenA}/${pool.tokenB} bribes.`);
                                }
                            }
                        }
                    });
                    pool.currentBribes = []; // Clear bribes after processing
                }
            });
        }


        // --- Tokenomics & Financial Logic ---

        /**
         * Locks PDEX for vePDEX.
         * @param {number} amount - Amount of PDEX to lock.
         * @param {number} durationWeeks - Lock duration in weeks (max 208).
         * @param {string} lockerId - 'user' or bot.id
         */
        function lockPDEX(amount, durationWeeks, lockerId) {
            if (amount <= 0 || durationWeeks <= 0 || durationWeeks > 208) {
                showToast('Invalid lock amount or duration.', 'error');
                return false;
            }

            let wallet;
            if (lockerId === 'user') {
                wallet = userWallet;
            } else {
                wallet = bots.find(b => b.id === lockerId)?.wallet;
                if (!wallet) return false;
            }

            if (wallet.PDEX < amount) {
                showToast('Insufficient PDEX balance to lock.', 'error');
                return false;
            }

            // Burn PDEX
            wallet.PDEX -= amount;
            totalPDEXBurned += amount;
            totalPDEXLocked += amount; // Track locked amount for circulating supply

            // Calculate vePDEX
            const vePDEXAmount = amount * (durationWeeks / 208);
            const unlockTime = simulationTime + (durationWeeks * 7 * 24 * 60); // Convert weeks to simulated minutes

            const lockEntry = {
                id: generateUniqueId(),
                pdexLocked: amount,
                vePDEXAmount,
                lockDurationWeeks: durationWeeks,
                unlockTime,
                votedPoolId: null, // Track which pool this vePDEX voted for
                claimedEmissions: 0,
                claimedBribes: {} // { token: amount }
            };

            if (lockerId === 'user') {
                userVePDEXLocks.push(lockEntry);
                addTransaction('PDEX Locked', `User locked ${formatLargeNumber(amount)} PDEX for ${durationWeeks} weeks, gaining ${formatLargeNumber(vePDEXAmount)} vePDEX.`);
                showToast(`Successfully locked ${formatLargeNumber(amount)} PDEX!`, 'success');
            } else {
                const bot = bots.find(b => b.id === lockerId);
                if (bot) {
                    bot.vePDEXLocks.push(lockEntry);
                    addTransaction('PDEX Locked', `Bot ${bot.id} locked ${formatLargeNumber(amount)} PDEX for ${durationWeeks} weeks, gaining ${formatLargeNumber(vePDEXAmount)} vePDEX.`);
                }
            }
            updateCirculatingSupply();
            updateLeaderboard();
            updateUI();
            return true;
        }

        /**
         * Unlocks vePDEX and mints UNVEPDEX.
         * @param {string} lockId - ID of the vePDEX lock to unlock.
         */
        function unlockVePDEX(lockId) {
            const lockIndex = userVePDEXLocks.findIndex(lock => lock.id === lockId);
            if (lockIndex === -1) {
                showToast('VePDEX lock not found.', 'error');
                return false;
            }

            const lock = userVePDEXLocks[lockIndex];
            if (simulationTime < lock.unlockTime) {
                showToast('This vePDEX lock has not expired yet.', 'error');
                return false;
            }

            // Mint UNVEPDEX equivalent to original vePDEX amount
            userUNVEPDEXBalance += lock.vePDEXAmount;
            unvepdexSupply += lock.vePDEXAmount;

            totalPDEXLocked -= lock.pdexLocked; // Remove from locked PDEX count

            userVePDEXLocks.splice(lockIndex, 1); // Remove the lock

            addTransaction('VePDEX Unlocked', `User unlocked ${formatLargeNumber(lock.vePDEXAmount)} vePDEX, receiving ${formatLargeNumber(lock.vePDEXAmount)} UNVEPDEX.`);
            showToast(`Successfully unlocked vePDEX and received ${formatLargeNumber(lock.vePDEXAmount)} UNVEPDEX!`, 'success');
            updateCirculatingSupply();
            updateUI();
            return true;
        }

        /**
         * Sells UNVEPDEX for USDT at a fixed 1:1 rate.
         * @param {number} amount - Amount of UNVEPDEX to sell.
         * @param {string} sellerId - 'user' or bot.id
         */
        function sellUNVEPDEX(amount, sellerId) {
            if (amount <= 0) {
                showToast('Invalid UNVEPDEX amount.', 'error');
                return false;
            }

            let wallet;
            let isUser = false;
            if (sellerId === 'user') {
                wallet = userWallet;
                isUser = true;
                if (userDailyUNVEPDEXSellCount >= 1) {
                    showToast('User limited to selling 1 UNVEPDEX per simulated day.', 'error');
                    return false;
                }
                if (amount > 1) {
                    amount = 1; // Enforce user daily limit
                    showToast('Selling limited to 1 UNVEPDEX per day. Selling 1 UNVEPDEX.', 'info');
                }
            } else {
                wallet = bots.find(b => b.id === sellerId)?.wallet;
                if (!wallet) return false;
            }

            if (isUser && userUNVEPDEXBalance < amount) {
                showToast('Insufficient UNVEPDEX balance.', 'error');
                return false;
            } else if (!isUser && wallet.UNVEPDEX < amount) {
                // Bots have their own UNVEPDEX balance in their wallet object
                return false; // Bot cannot sell more than it has
            }

            const unvepdexPool = liquidityPools.find(p => p.isUNVEPDEXPool);
            if (!unvepdexPool) {
                showToast('UNVEPDEX selling pool not found.', 'error');
                return false;
            }

            const usdtReceived = amount * 1; // Fixed 1:1 rate

            if (unvepdexPool.reserveB < usdtReceived) { // reserveB is USDT
                showToast('Insufficient USDT liquidity in UNVEPDEX pool.', 'error');
                return false;
            }

            // Deduct UNVEPDEX from seller
            if (isUser) {
                userUNVEPDEXBalance -= amount;
                userDailyUNVEPDEXSellCount += amount;
            } else {
                wallet.UNVEPDEX -= amount;
            }

            // Burn UNVEPDEX
            unvepdexSupply -= amount;

            // Transfer USDT from pool to seller
            unvepdexPool.reserveB -= usdtReceived;
            wallet.USDT = (wallet.USDT || 0) + usdtReceived;

            addTransaction('UNVEPDEX Sold', `${isUser ? 'User' : sellerId} sold ${formatLargeNumber(amount)} UNVEPDEX for ${formatCurrency(usdtReceived)} USDT.`);
            if (isUser) showToast(`Successfully sold ${formatLargeNumber(amount)} UNVEPDEX for ${formatCurrency(usdtReceived)} USDT!`, 'success');
            updateUI();
            return true;
        }


        /**
         * Performs a token swap in a liquidity pool.
         * @param {string} poolId
         * @param {string} inputToken
         * @param {number} inputAmount
         * @param {string} outputToken
         * @param {string} senderId - 'user' or bot.id
         * @returns {object|null} - { outputAmount, lpFee, platformFee } on success, null on failure
         */
        function swapTokens(poolId, inputToken, inputAmount, outputToken, senderId) {
            const pool = liquidityPools.find(p => p.id === poolId);
            if (!pool) {
                showToast('Liquidity pool not found.', 'error');
                return null;
            }

            let wallet;
            let isUser = false;
            if (senderId === 'user') {
                wallet = userWallet;
                isUser = true;
            } else {
                wallet = bots.find(b => b.id === senderId)?.wallet;
                if (!wallet) return null;
            }

            if ((wallet[inputToken] || 0) < inputAmount) {
                if (isUser) showToast(`Insufficient ${inputToken} balance.`, 'error');
                return null;
            }

            const lpFeeRate = 0.003; // 0.3%
            const platformFeeRate = 0.01; // 1%

            const effectiveInputAmount = inputAmount / (1 + lpFeeRate + platformFeeRate); // Amount actually entering the x*y=k calculation

            let reserveIn, reserveOut;
            if (pool.tokenA === inputToken && pool.tokenB === outputToken) {
                reserveIn = pool.reserveA;
                reserveOut = pool.reserveB;
            } else if (pool.tokenB === inputToken && pool.tokenA === outputToken) {
                reserveIn = pool.reserveB;
                reserveOut = pool.reserveA;
            } else {
                if (isUser) showToast('Invalid token pair for this pool.', 'error');
                return null;
            }

            const outputAmount = (reserveOut * effectiveInputAmount) / (reserveIn + effectiveInputAmount);

            if (outputAmount <= 0 || outputAmount >= reserveOut) { // Prevent draining pool
                if (isUser) showToast('Slippage too high or insufficient liquidity.', 'error');
                return null;
            }

            // Calculate fees based on original inputAmount
            const lpFee = inputAmount * lpFeeRate;
            const platformFee = inputAmount * platformFeeRate;
            const platformFeeToUNVEPDEX = platformFee * 0.5;
            const platformFeeToTreasury = platformFee * 0.5;

            // Deduct from sender's wallet
            wallet[inputToken] -= inputAmount;

            // Add LP fee back to pool
            if (pool.tokenA === inputToken) {
                pool.reserveA += lpFee;
            } else {
                pool.reserveB += lpFee;
            }

            // Distribute platform fee
            const platformFeeToUNVEPDEX_USDT = platformFeeToUNVEPDEX * getPrice(inputToken); // Convert to USDT
            const unvepdexPool = liquidityPools.find(p => p.isUNVEPDEXPool);
            if (unvepdexPool) {
                unvepdexPool.reserveB += platformFeeToUNVEPDEX_USDT; // Add to USDT side
            }

            // Add to FEES wallet (protocol treasury)
            feesWallet[inputToken] = (feesWallet[inputToken] || 0) + platformFeeToTreasury;

            // Update pool reserves and give output to sender
            if (pool.tokenA === inputToken) {
                pool.reserveA += effectiveInputAmount;
                pool.reserveB -= outputAmount;
            } else {
                pool.reserveB += effectiveInputAmount;
                pool.reserveA -= outputAmount;
            }
            wallet[outputToken] = (wallet[outputToken] || 0) + outputAmount;

            addTransaction('Swap', `${isUser ? 'User' : senderId} swapped ${formatLargeNumber(inputAmount)} ${inputToken} for ${formatLargeNumber(outputAmount)} ${outputToken} in ${pool.tokenA}/${pool.tokenB} pool.`);
            if (isUser) showToast(`Swap successful! Received ${formatLargeNumber(outputAmount)} ${outputToken}.`, 'success');
            updatePoolTVLs();
            updateUI();
            return { outputAmount, lpFee, platformFee };
        }

        /**
         * Adds liquidity to a pool.
         * @param {string} poolId
         * @param {number} amountA
         * @param {number} amountB
         * @param {string} providerId - 'user' or bot.id
         */
        function addLiquidity(poolId, amountA, amountB, providerId) {
            const pool = liquidityPools.find(p => p.id === poolId);
            if (!pool) {
                showToast('Liquidity pool not found.', 'error');
                return false;
            }

            let wallet;
            let isUser = false;
            if (providerId === 'user') {
                wallet = userWallet;
                isUser = true;
            } else {
                wallet = bots.find(b => b.id === providerId)?.wallet;
                if (!wallet) return false;
            }

            if ((wallet[pool.tokenA] || 0) < amountA || (wallet[pool.tokenB] || 0) < amountB) {
                if (isUser) showToast('Insufficient token balance(s) to add liquidity.', 'error');
                return false;
            }

            const feeRate = 0.005; // 0.5%
            const feeToUNVEPDEXRate = 0.0025; // 0.25%
            const feeToTreasuryRate = 0.0025; // 0.25%

            // Calculate fees for each token
            const feeA = amountA * feeRate;
            const feeB = amountB * feeRate;

            const netAmountA = amountA - feeA;
            const netAmountB = amountB - feeB;

            // Deduct from sender's wallet
            wallet[pool.tokenA] -= amountA;
            wallet[pool.tokenB] -= amountB;

            // Distribute fees
            const unvepdexPool = liquidityPools.find(p => p.isUNVEPDEXPool);
            if (unvepdexPool) {
                unvepdexPool.reserveB += (amountA * feeToUNVEPDEXRate * getPrice(pool.tokenA)); // Convert to USDT
                unvepdexPool.reserveB += (amountB * feeToUNVEPDEXRate * getPrice(pool.tokenB)); // Convert to USDT
            }
            feesWallet[pool.tokenA] = (feesWallet[pool.tokenA] || 0) + (amountA * feeToTreasuryRate);
            feesWallet[pool.tokenB] = (feesWallet[pool.tokenB] || 0) + (amountB * feeToTreasuryRate);

            // Calculate LP tokens to mint
            let lpTokensMinted;
            if (pool.lpSupply === 0) {
                lpTokensMinted = Math.sqrt(netAmountA * netAmountB);
            } else {
                const lpShareA = netAmountA / pool.reserveA;
                const lpShareB = netAmountB / pool.reserveB;
                lpTokensMinted = Math.min(lpShareA, lpShareB) * pool.lpSupply;
            }

            if (lpTokensMinted <= 0) {
                if (isUser) showToast('Failed to mint LP tokens. Check amounts or pool state.', 'error');
                // Refund tokens if LP tokens can't be minted
                wallet[pool.tokenA] += amountA;
                wallet[pool.tokenB] += amountB;
                return false;
            }

            // Update pool reserves and LP supply
            pool.reserveA += netAmountA;
            pool.reserveB += netAmountB;
            pool.lpSupply += lpTokensMinted;

            // Give LP tokens to provider
            wallet[`LP_${pool.id}`] = (wallet[`LP_${pool.id}`] || 0) + lpTokensMinted;

            addTransaction('Add Liquidity', `${isUser ? 'User' : providerId} added ${formatLargeNumber(amountA)} ${pool.tokenA} and ${formatLargeNumber(amountB)} ${pool.tokenB} to ${pool.tokenA}/${pool.tokenB} pool.`);
            if (isUser) showToast(`Successfully added liquidity to ${pool.tokenA}/${pool.tokenB} pool!`, 'success');
            updatePoolTVLs();
            updateUI();
            return true;
        }

        /**
         * Removes liquidity from a pool.
         * @param {string} poolId
         * @param {number} lpTokensToRemove
         * @param {string} providerId - 'user' or bot.id
         */
        function removeLiquidity(poolId, lpTokensToRemove, providerId) {
            const pool = liquidityPools.find(p => p.id === poolId);
            if (!pool) {
                showToast('Liquidity pool not found.', 'error');
                return false;
            }

            let wallet;
            let isUser = false;
            if (providerId === 'user') {
                wallet = userWallet;
                isUser = true;
            } else {
                wallet = bots.find(b => b.id === providerId)?.wallet;
                if (!wallet) return false;
            }

            if ((wallet[`LP_${pool.id}`] || 0) < lpTokensToRemove) {
                if (isUser) showToast('Insufficient LP tokens.', 'error');
                return false;
            }

            if (pool.lpSupply === 0) {
                if (isUser) showToast('Pool has no LP supply.', 'error');
                return false;
            }

            const share = lpTokensToRemove / pool.lpSupply;
            const amountAToReceive = pool.reserveA * share;
            const amountBToReceive = pool.reserveB * share;

            const feeRate = 0.005; // 0.5%
            const feeToUNVEPDEXRate = 0.0025; // 0.25%
            const feeToTreasuryRate = 0.0025; // 0.25%

            // Calculate fees for each token
            const feeA = amountAToReceive * feeRate;
            const feeB = amountBToReceive * feeRate;

            const netAmountA = amountAToReceive - feeA;
            const netAmountB = amountBToReceive - feeB;

            // Deduct LP tokens from provider
            wallet[`LP_${pool.id}`] -= lpTokensToRemove;

            // Update pool reserves and LP supply
            pool.reserveA -= amountAToReceive;
            pool.reserveB -= amountBToReceive;
            pool.lpSupply -= lpTokensToRemove;

            // Distribute fees
            const unvepdexPool = liquidityPools.find(p => p.isUNVEPDEXPool);
            if (unvepdexPool) {
                unvepdexPool.reserveB += (amountAToReceive * feeToUNVEPDEXRate * getPrice(pool.tokenA)); // Convert to USDT
                unvepdexPool.reserveB += (amountBToReceive * feeToUNVEPDEXRate * getPrice(pool.tokenB)); // Convert to USDT
            }
            feesWallet[pool.tokenA] = (feesWallet[pool.tokenA] || 0) + (amountAToReceive * feeToTreasuryRate);
            feesWallet[pool.tokenB] = (feesWallet[pool.tokenB] || 0) + (amountBToReceive * feeToTreasuryRate);

            // Give tokens to provider
            wallet[pool.tokenA] = (wallet[pool.tokenA] || 0) + netAmountA;
            wallet[pool.tokenB] = (wallet[pool.tokenB] || 0) + netAmountB;

            addTransaction('Remove Liquidity', `${isUser ? 'User' : providerId} removed liquidity from ${pool.tokenA}/${pool.tokenB} pool, receiving ${formatLargeNumber(netAmountA)} ${pool.tokenA} and ${formatLargeNumber(netAmountB)} ${pool.tokenB}.`);
            if (isUser) showToast(`Successfully removed liquidity from ${pool.tokenA}/${pool.tokenB} pool!`, 'success');
            updatePoolTVLs();
            updateUI();
            return true;
        }

        /**
         * Transfers tokens from the FEES wallet to the user's main wallet.
         * @param {string} tokenSymbol
         * @param {number} amount
         */
        function transferFeesToMainWallet(tokenSymbol, amount) {
            if (!feesWallet[tokenSymbol] || feesWallet[tokenSymbol] < amount) {
                showToast(`Insufficient ${tokenSymbol} in FEES wallet.`, 'error');
                return false;
            }
            if (amount <= 0) {
                showToast('Invalid amount to transfer.', 'error');
                return false;
            }

            feesWallet[tokenSymbol] -= amount;
            userWallet[tokenSymbol] = (userWallet[tokenSymbol] || 0) + amount;

            addTransaction('Fee Transfer', `Transferred ${formatLargeNumber(amount)} ${tokenSymbol} from FEES wallet to main wallet.`);
            showToast(`Successfully transferred ${formatLargeNumber(amount)} ${tokenSymbol} from FEES wallet!`, 'success');
            updateUI();
            return true;
        }

        /**
         * Creates a new bribe offer.
         * @param {string} poolId - The ID of the pool to bribe.
         * @param {string} bribeToken - The token symbol of the bribe.
         * @param {number} bribeAmount - The amount of the bribe token.
         * @param {string} giverId - 'user' or bot.id
         * @param {string} vesting - 'immediate' or 'multi-epoch' (placeholder for future)
         */
        function createBribeOffer(poolId, bribeToken, bribeAmount, giverId, vesting = 'immediate') {
            const pool = liquidityPools.find(p => p.id === poolId);
            if (!pool) {
                showToast('Pool not found for bribe.', 'error');
                return false;
            }

            let wallet;
            let isUser = false;
            if (giverId === 'user') {
                wallet = userWallet;
                isUser = true;
            } else {
                wallet = bots.find(b => b.id === giverId)?.wallet;
                if (!wallet) return false;
            }

            if ((wallet[bribeToken] || 0) < bribeAmount) {
                if (isUser) showToast(`Insufficient ${bribeToken} balance to offer bribe.`, 'error');
                return false;
            }
            if (bribeAmount <= 0) {
                if (isUser) showToast('Bribe amount must be positive.', 'error');
                return false;
            }

            wallet[bribeToken] -= bribeAmount; // Deduct bribe from giver immediately

            pool.currentBribes.push({
                id: generateUniqueId(),
                token: bribeToken,
                amount: bribeAmount,
                giverId,
                vesting,
                epochCreated: currentEpoch // Track creation epoch
            });

            addTransaction('Bribe Offer', `${isUser ? 'User' : giverId} created a ${formatLargeNumber(bribeAmount)} ${bribeToken} bribe for ${pool.tokenA}/${pool.tokenB} pool.`);
            if (isUser) showToast(`Successfully created ${formatLargeNumber(bribeAmount)} ${bribeToken} bribe for ${pool.tokenA}/${pool.tokenB}!`, 'success');
            updateUI();
            return true;
        }


        // --- Bot Logic ---
        let botCounter = 0;
        function createBot(name) {
            botCounter++;
            const botId = `Bot ${botCounter}`;
            const botWallet = {
                USDT: 5000,
                USDC: 5000,
                BTC: 5000 / baseAssetPrices.BTC,
                ETH: 5000 / baseAssetPrices.ETH,
                AVAX: 5000 / baseAssetPrices.AVAX,
                SOL: 5000 / baseAssetPrices.SOL,
                BNB: 5000 / baseAssetPrices.BNB,
                SUI: 5000 / baseAssetPrices.SUI,
                TON: 5000 / baseAssetPrices.TON,
                PDEX: 0,
                UNVEPDEX: 0, // Bots can also hold UNVEPDEX
            };
            // Distribute initial airdrop to bots (remaining from 50M after user gets 10%)
            const remainingAirdrop = 50_000_000 * 0.9;
            botWallet.PDEX += remainingAirdrop / bots.length; // Distribute evenly for now

            return {
                id: botId,
                name,
                wallet: botWallet,
                vePDEXLocks: [],
                dailyUNVEPDEXSellCount: 0,
                launchedTokens: [], // Track tokens launched by this bot
                lastTradingTime: 0,
                lastLiquidityTime: 0,
                lastBribeTime: 0,
                lastLockingTime: 0,
                lastVoteTime: 0,
                lastTokenLaunchTime: 0,
            };
        }

        /**
         * Runs actions for all bots based on their aggression levels.
         */
        function runBotActions() {
            bots.forEach(bot => {
                // Adjust frequency/magnitude based on aggression (0-100)
                // Higher aggression = more frequent / larger actions

                // Trading (every 2-10 simulated minutes based on aggression)
                const tradingFrequency = 12 - Math.floor(botAggression.trading / 10); // 2-12 minutes
                if (simulationTime - bot.lastTradingTime >= tradingFrequency) {
                    botTrade(bot);
                    bot.lastTradingTime = simulationTime;
                }

                // Liquidity Adding/Removing (every 5-20 simulated minutes)
                const liquidityFrequency = 25 - Math.floor(botAggression.liquidity / 5); // 5-25 minutes
                if (simulationTime - bot.lastLiquidityTime >= liquidityFrequency) {
                    botAddRemoveLiquidity(bot);
                    bot.lastLiquidityTime = simulationTime;
                }

                // Adding Bribes (more often closer to epoch end, influenced by aggression)
                const bribeFrequency = 30 - Math.floor(botAggression.bribing / 3); // 0-30 minutes
                const timeToEpochEnd = nextEpochTime / 60; // In simulated minutes
                if (timeToEpochEnd <= 6 * 60 || Math.random() < (botAggression.bribing / 1000)) { // More likely closer to end or based on aggression
                    if (simulationTime - bot.lastBribeTime >= bribeFrequency) {
                        botAddBribe(bot);
                        bot.lastBribeTime = simulationTime;
                    }
                }

                // Buying PDEX and Locking (every 10-40 simulated minutes)
                const lockingFrequency = 50 - Math.floor(botAggression.pdexLocking / 2); // 10-50 minutes
                if (simulationTime - bot.lastLockingTime >= lockingFrequency) {
                    botBuyPDEXAndLock(bot);
                    bot.lastLockingTime = simulationTime;
                }

                // Voting in Pools (every 5-20 simulated minutes, or closer to epoch end)
                const votingFrequency = 25 - Math.floor(botAggression.voting / 5); // 5-25 minutes
                if (timeToEpochEnd <= 1 * 60 || Math.random() < (botAggression.voting / 500)) { // More likely closer to end or based on aggression
                     if (simulationTime - bot.lastVoteTime >= votingFrequency) {
                        botVote(bot);
                        bot.lastVoteTime = simulationTime;
                    }
                }

                // Bot Token Launch (randomly every simulated day, influenced by aggression)
                const launchChance = (botAggression.trading + botAggression.liquidity) / 20000; // Small chance
                if (Math.random() < launchChance && simulationTime - bot.lastTokenLaunchTime >= (24 * 60) * (100 / botAggression.trading)) { // At least once a day, more frequent with higher trading aggression
                    botLaunchToken(bot);
                    bot.lastTokenLaunchTime = simulationTime;
                }

                // Bots selling UNVEPDEX (if they have any)
                if (bot.wallet.UNVEPDEX > 0 && Math.random() < 0.1 * (botAggression.trading / 100)) { // More likely to sell if trading aggressive
                    const amountToSell = Math.min(bot.wallet.UNVEPDEX, Math.random() * 5); // Sell up to 5 UNVEPDEX
                    if (amountToSell > 0) {
                        sellUNVEPDEX(amountToSell, bot.id);
                    }
                }
            });
        }

        /**
         * Bot trading logic.
         * @param {object} bot
         */
        function botTrade(bot) {
            const availableTokens = Object.keys(bot.wallet).filter(token => bot.wallet[token] > 0.01 && token !== 'UNVEPDEX' && !token.startsWith('LP_'));
            if (availableTokens.length === 0) return;

            const inputToken = availableTokens[Math.floor(Math.random() * availableTokens.length)];
            const inputAmountUSD = (Math.random() * 4900 + 100) * (botAggression.trading / 100); // $100-$5000 based on aggression
            const inputAmount = inputAmountUSD / getPrice(inputToken);

            if (inputAmount <= 0 || bot.wallet[inputToken] < inputAmount) return;

            const targetPools = liquidityPools.filter(p =>
                (p.tokenA === inputToken || p.tokenB === inputToken) && !p.isUNVEPDEXPool
            );
            if (targetPools.length === 0) return;

            const pool = targetPools[Math.floor(Math.random() * targetPools.length)];
            const outputToken = pool.tokenA === inputToken ? pool.tokenB : pool.tokenA;

            swapTokens(pool.id, inputToken, inputAmount, outputToken, bot.id);
        }

        /**
         * Bot add/remove liquidity logic.
         * @param {object} bot
         */
        function botAddRemoveLiquidity(bot) {
            if (Math.random() < 0.5 * (botAggression.liquidity / 100)) { // Add liquidity
                const targetPools = liquidityPools.filter(p => !p.isUNVEPDEXPool && p.tokenA !== 'PDEX' && p.tokenB !== 'PDEX'); // Avoid PDEX pools for simplicity
                if (targetPools.length === 0) return;
                const pool = targetPools[Math.floor(Math.random() * targetPools.length)];

                const usdAmount = (Math.random() * 1000 + 100) * (botAggression.liquidity / 100); // $100-$1100
                const amountA = usdAmount / getPrice(pool.tokenA);
                const amountB = usdAmount / getPrice(pool.tokenB);

                if (bot.wallet[pool.tokenA] >= amountA && bot.wallet[pool.tokenB] >= amountB) {
                    addLiquidity(pool.id, amountA, amountB, bot.id);
                }
            } else { // Remove liquidity
                const botLPTokens = Object.keys(bot.wallet).filter(key => key.startsWith('LP_') && bot.wallet[key] > 0.01);
                if (botLPTokens.length === 0) return;

                const lpTokenKey = botLPTokens[Math.floor(Math.random() * botLPTokens.length)];
                const poolId = lpTokenKey.substring(3); // Extract pool ID
                const lpTokensToRemove = bot.wallet[lpTokenKey] * (Math.random() * 0.5 + 0.1) * (botAggression.liquidity / 100); // 10-60% of LP tokens

                if (lpTokensToRemove > 0) {
                    removeLiquidity(poolId, lpTokensToRemove, bot.id);
                }
            }
        }

        /**
         * Bot bribe logic.
         * @param {object} bot
         */
        function botAddBribe(bot) {
            const bribablePools = liquidityPools.filter(p => !p.isUNVEPDEXPool);
            if (bribablePools.length === 0) return;

            const pool = bribablePools[Math.floor(Math.random() * bribablePools.length)];
            const bribeAmount = (Math.random() * 5000 + 100) * (botAggression.bribing / 100); // $100-$5100
            const bribeToken = 'USDT'; // Bots primarily bribe with USDT

            if (bot.wallet.USDT >= bribeAmount) {
                createBribeOffer(pool.id, bribeToken, bribeAmount, bot.id);
            }
        }

        /**
         * Bot PDEX buying and locking logic.
         * @param {object} bot
         */
        function botBuyPDEXAndLock(bot) {
            const pdexUsdtPool = liquidityPools.find(p => p.tokenA === 'PDEX' && p.tokenB === 'USDT');
            if (!pdexUsdtPool || bot.wallet.USDT < 100) return; // Need some USDT to buy PDEX

            const usdtToSpend = (Math.random() * 500 + 50) * (botAggression.pdexLocking / 100); // $50-$550
            if (usdtToSpend > bot.wallet.USDT) return;

            const swapResult = swapTokens(pdexUsdtPool.id, 'USDT', usdtToSpend, 'PDEX', bot.id);
            if (swapResult) {
                const pdexAcquired = swapResult.outputAmount;
                if (pdexAcquired > 10) { // Only lock if a reasonable amount acquired
                    const lockDurationWeeks = Math.floor(Math.random() * 200) + 8; // 8-208 weeks
                    const amountToLock = pdexAcquired * (Math.random() * 0.5 + 0.5); // Lock 50-100% of acquired PDEX
                    lockPDEX(amountToLock, lockDurationWeeks, bot.id);
                }
            }
        }

        /**
         * Bot voting logic.
         * Bots consistently vote for the highest TVL pools.
         * @param {object} bot
         */
        function botVote(bot) {
            const sortedPoolsByTVL = [...liquidityPools].sort((a, b) => b.tvl - a.tvl);
            if (sortedPoolsByTVL.length === 0) return;

            const totalBotVePDEX = bot.vePDEXLocks.reduce((sum, lock) => sum + lock.vePDEXAmount, 0);
            if (totalBotVePDEX === 0) return;

            // Bots vote for the top N pools based on aggression
            const numPoolsToVote = Math.min(sortedPoolsByTVL.length, Math.ceil(botAggression.voting / 20)); // 1-5 pools
            let remainingVePDEX = totalBotVePDEX;

            // Clear previous votes
            bot.vePDEXLocks.forEach(lock => lock.votedPoolId = null);

            for (let i = 0; i < numPoolsToVote && remainingVePDEX > 0; i++) {
                const pool = sortedPoolsByTVL[i];
                const voteAmount = remainingVePDEX * (Math.random() * 0.5 + 0.5); // Allocate 50-100% of remaining to current pool
                
                // Distribute vote amount among bot's vePDEX locks
                let allocated = 0;
                for (const lock of bot.vePDEXLocks) {
                    if (!lock.votedPoolId && allocated < voteAmount) {
                        lock.votedPoolId = pool.id;
                        allocated += lock.vePDEXAmount;
                        remainingVePDEX -= lock.vePDEXAmount;
                    }
                }
                pool.votes = (pool.votes || 0) + allocated; // Update pool's total votes
                addTransaction('Bot Vote', `Bot ${bot.id} voted for ${pool.tokenA}/${pool.tokenB} pool.`);
            }
        }

        /**
         * Bot token launch logic.
         * @param {object} bot
         */
        function botLaunchToken(bot) {
            const newBotTokenName = `BotCoin${Math.floor(Math.random() * 1000)}`;
            const newBotTokenTicker = `BCT${Math.floor(Math.random() * 99)}`;
            const totalBotTokenSupply = Math.floor(Math.random() * 100_000_000) + 10_000_000; // 10M - 110M
            const stableTokenPair = 'USDT'; // Bots always pair with USDT

            const initialLiquidityUSD = (Math.random() * 50000 + 50000); // $50k-$100k
            const initialStableTokenAmount = initialLiquidityUSD / 2; // Half in USDT

            const percentForLiquidity = Math.floor(Math.random() * 30) + 30; // 30-60%
            const percentForPlatformWallet = Math.floor(Math.random() * 5) + 0.5; // 0.5-5%
            const percentForAirdrop = Math.floor(Math.random() * 10) + 5; // 5-15%
            const percentForBotAirdrop = 100 - percentForLiquidity - percentForPlatformWallet - percentForAirdrop;

            if (percentForBotAirdrop < 0) return; // Ensure percentages don't go negative

            // Simulate the token creation and pool setup
            const initialNewTokenAmount = (totalBotTokenSupply * percentForLiquidity) / 100;
            const initialNewTokenPrice = initialStableTokenAmount / initialNewTokenAmount;

            // Add the new token to baseAssetPrices (for price lookup)
            baseAssetPrices[newBotTokenTicker] = initialNewTokenPrice;

            const newPool = createLiquidityPool(
                newBotTokenTicker,
                stableTokenPair,
                initialNewTokenAmount,
                initialStableTokenAmount,
                0, // Bribe added separately
                'VOLATILE'
            );

            // Add initial bribe for the new pool (from bot's wallet)
            const bribeAmount = (Math.random() * 50000 + 50000); // $50k-$100k
            if (bot.wallet.USDT >= bribeAmount) {
                createBribeOffer(newPool.id, 'USDT', bribeAmount, bot.id);
            }

            // Distribute token allocations
            const platformWalletAmount = (totalBotTokenSupply * percentForPlatformWallet) / 100;
            const userAirdropAmount = (totalBotTokenSupply * percentForAirdrop) / 100;
            const botAirdropAmount = (totalBotTokenSupply * percentForBotAirdrop) / 100;

            feesWallet[newBotTokenTicker] = (feesWallet[newBotTokenTicker] || 0) + platformWalletAmount;
            userWallet[newBotTokenTicker] = (userWallet[newBotTokenTicker] || 0) + userAirdropAmount;
            bot.wallet[newBotTokenTicker] = (bot.wallet[newBotTokenTicker] || 0) + botAirdropAmount; // Bot keeps its share

            bot.launchedTokens.push(newBotTokenTicker);
            addTransaction('Token Launch', `Bot ${bot.id} launched new token ${newBotTokenTicker} with initial liquidity of ${formatCurrency(initialLiquidityUSD)} USDT.`);
            showToast(`Bot ${bot.id} launched ${newBotTokenTicker}!`, 'info');
            updateUI();
        }

        // --- UI Rendering Functions ---

        /**
         * Renders the current page content.
         * @param {string} pageName
         */
        function showPage(pageName) {
            const pageContentDiv = document.getElementById('pageContent');
            const oldPageContent = pageContentDiv.innerHTML;
            currentActivePage = pageName;

            // Apply page exit animation
            if (oldPageContent) {
                pageContentDiv.classList.remove('page-enter-active');
                pageContentDiv.classList.add('page-exit-active');
                setTimeout(() => {
                    renderPage(pageName);
                    pageContentDiv.classList.remove('page-exit-active');
                    pageContentDiv.classList.add('page-enter-active');
                }, 300); // Match transition duration
            } else {
                renderPage(pageName);
                pageContentDiv.classList.add('page-enter-active');
            }

            // Collapse sidebar on mobile if expanded
            if (window.innerWidth <= 768 && sidebarExpanded) {
                toggleSidebar();
            }
        }

        function renderPage(pageName) {
            const pageContentDiv = document.getElementById('pageContent');
            pageContentDiv.innerHTML = ''; // Clear previous content

            let html = '';
            switch (pageName) {
                case 'dashboard':
                    html = renderDashboard();
                    break;
                case 'liquidity':
                    html = renderLiquidity();
                    break;
                case 'voting':
                    html = renderVoting();
                    break;
                case 'emissions':
                    html = renderEmissions();
                    break;
                case 'portfolio':
                    html = renderPortfolio();
                    break;
                case 'tokens':
                    html = renderTokens();
                    break;
                case 'admin':
                    html = renderAdmin();
                    break;
                case 'leaderboard':
                    html = renderLeaderboard();
                    break;
                default:
                    html = `<div class="text-center text-gray-500">Page not found.</div>`;
            }
            pageContentDiv.innerHTML = html;
            attachPageListeners(pageName); // Attach event listeners for the new content
            updateUI(); // Initial UI update for the new page
        }

        /**
         * Attaches event listeners for the currently rendered page.
         * @param {string} pageName
         */
        function attachPageListeners(pageName) {
            if (pageName === 'liquidity') {
                document.getElementById('poolSelect').onchange = updateLiquidityPoolDetails;
                document.getElementById('swapInputAmount').oninput = updateSwapPreview;
                document.getElementById('swapInputToken').onchange = updateSwapPreview;
                document.getElementById('swapBtn').onclick = handleSwap;
                document.getElementById('addLiquidityTokenAAmount').oninput = updateAddLiquidityPreview;
                document.getElementById('addLiquidityBtn').onclick = handleAddLiquidity;
                document.getElementById('removeLiquidityLPTokenAmount').oninput = updateRemoveLiquidityPreview;
                document.getElementById('removeLiquidityBtn').onclick = handleRemoveLiquidity;
            } else if (pageName === 'voting') {
                document.getElementById('votePoolSelect').onchange = updateVoteImpactPreview;
                document.getElementById('voteAmount').oninput = updateVoteImpactPreview;
                document.getElementById('submitVoteBtn').onclick = handleSubmitVote;
                document.getElementById('createBribeBtn').onclick = showCreateBribeModal;
            } else if (pageName === 'emissions') {
                document.getElementById('claimAllRewardsBtn').onclick = handleClaimAllRewards;
            } else if (pageName === 'portfolio') {
                document.getElementById('lockPDEXBtn').onclick = showLockPDEXModal;
                document.getElementById('sellUNVEPDEXBtn').onclick = handleSellUNVEPDEX;
                document.getElementById('transferFeesBtn').onclick = showTransferFeesModal;
                document.querySelectorAll('.unlock-vepdex-btn').forEach(btn => {
                    btn.onclick = (e) => handleUnlockVePDEX(e.target.dataset.lockId);
                });
            } else if (pageName === 'admin') {
                document.getElementById('simSpeedSlider').oninput = (e) => {
                    simulationSpeedMultiplier = parseFloat(e.target.value);
                    document.getElementById('simSpeedValue').textContent = `${simulationSpeedMultiplier}x`;
                    clearInterval(simulationInterval);
                    simulationInterval = setInterval(advanceTime, 1000 / simulationSpeedMultiplier);
                };
                document.getElementById('epochPeriodValue').onchange = (e) => {
                    const value = parseInt(document.getElementById('epochPeriodInput').value);
                    const unit = e.target.value;
                    let newPeriodSeconds;
                    if (unit === 'seconds') newPeriodSeconds = value;
                    else if (unit === 'minutes') newPeriodSeconds = value * 60;
                    else if (unit === 'hours') newPeriodSeconds = value * 60 * 60;
                    else if (unit === 'days') newPeriodSeconds = value * 24 * 60 * 60;

                    if (isNaN(newPeriodSeconds) || newPeriodSeconds <= 0) {
                        showToast('Invalid epoch period.', 'error');
                        return;
                    }
                    epochPeriodSeconds = newPeriodSeconds;
                    showToast(`Next epoch period set to ${value} ${unit}.`, 'info');
                };
                document.getElementById('manualEndEpochBtn').onclick = handleManualEndEpoch;
                document.getElementById('refillVoterIncentivesBtn').onclick = handleRefillVoterIncentives;
                document.getElementById('resetSimulationBtn').onclick = handleResetSimulation;
                document.getElementById('manualTokenLaunchBtn').onclick = showManualTokenLaunchModal;
                document.getElementById('saveBotProfileBtn').onclick = handleSaveBotProfile;
                document.getElementById('loadBotProfileSelect').onchange = handleLoadBotProfile;
                document.getElementById('resetBotAggressionBtn').onclick = handleResetBotAggression;

                // Bot aggression sliders
                const aggressionSliders = ['trading', 'liquidity', 'bribing', 'pdexLocking', 'voting'];
                aggressionSliders.forEach(type => {
                    const slider = document.getElementById(`${type}AggressionSlider`);
                    const valueSpan = document.getElementById(`${type}AggressionValue`);
                    slider.oninput = (e) => {
                        botAggression[type] = parseInt(e.target.value);
                        valueSpan.textContent = e.target.value;
                    };
                });
            }
        }

        /**
         * Updates all UI elements based on current simulation state.
         */
        function updateUI() {
            // Update common elements
            const epochTimerElement = document.getElementById('epochTimer');
            if (epochTimerElement) {
                const totalSeconds = nextEpochTime;
                const days = Math.floor(totalSeconds / (24 * 60 * 60));
                const hours = Math.floor((totalSeconds % (24 * 60 * 60)) / (60 * 60));
                const minutes = Math.floor((totalSeconds % (60 * 60)) / 60);
                const seconds = Math.floor(totalSeconds % 60);

                epochTimerElement.textContent = `${days.toString().padStart(2, '0')}:${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                epochTimerElement.classList.remove('normal', 'warning', 'critical');
                if (totalSeconds <= 60 * 60) { // Last hour
                    epochTimerElement.classList.add('critical');
                } else if (totalSeconds <= 24 * 60 * 60) { // Last day
                    epochTimerElement.classList.add('warning');
                } else {
                    epochTimerElement.classList.add('normal');
                }
            }

            // Update page-specific elements
            if (currentActivePage === 'dashboard') {
                document.getElementById('pdexPriceDisplay').textContent = formatCurrency(pdexPrice);
                document.getElementById('totalBurnedDisplay').textContent = formatLargeNumber(totalPDEXBurned);
                document.getElementById('totalLockedVePDEXDisplay').textContent = formatLargeNumber(totalPDEXLocked);
                document.getElementById('marketCapDisplay').textContent = formatCurrency(pdexPrice * circulatingPDEXSupply);
                document.getElementById('protocolVePDEXDisplay').textContent = formatLargeNumber(protocolOwnedVePDEX);

                const topPoolsList = document.getElementById('topPoolsList');
                if (topPoolsList) {
                    const sortedPools = [...liquidityPools].sort((a, b) => b.tvl - a.tvl).slice(0, 3);
                    topPoolsList.innerHTML = sortedPools.map(pool => `
                        <li class="flex justify-between items-center py-2 border-b border-gray-700 last:border-b-0">
                            <span>${pool.tokenA}/${pool.tokenB}</span>
                            <span class="text-cyan-400">${formatCurrency(pool.tvl)} TVL</span>
                        </li>
                    `).join('');
                }

                const recentActivityList = document.getElementById('recentActivityList');
                if (recentActivityList) {
                    recentActivityList.innerHTML = transactionHistory.slice(0, 5).map(tx => `
                        <li class="py-2 border-b border-gray-700 last:border-b-0 text-sm text-gray-400">
                            [${Math.floor(tx.timestamp / 60)}m ago] ${tx.description}
                        </li>
                    `).join('');
                }
            } else if (currentActivePage === 'liquidity') {
                updateLiquidityPoolDetails();
                updateSwapPreview();
                updateAddLiquidityPreview();
                updateRemoveLiquidityPreview();
                renderUserLpPositions();
            } else if (currentActivePage === 'voting') {
                document.getElementById('myVePDEXBalanceDisplay').textContent = formatLargeNumber(userVePDEXLocks.reduce((sum, lock) => sum + lock.vePDEXAmount, 0));
                updateVoteImpactPreview();
                renderVotablePools();
                renderBribeOffers();
            } else if (currentActivePage === 'emissions') {
                renderClaimableRewards();
            } else if (currentActivePage === 'portfolio') {
                renderPortfolioBalances();
                renderLockedVePDEX();
                document.getElementById('userUNVEPDEXBalanceDisplay').textContent = formatLargeNumber(userUNVEPDEXBalance);
                document.getElementById('userDailyUNVEPDEXSellCountDisplay').textContent = userDailyUNVEPDEXSellCount;
                renderFeesWalletBalances();
            } else if (currentActivePage === 'tokens') {
                renderTokenList();
            } else if (currentActivePage === 'admin') {
                document.getElementById('simSpeedSlider').value = simulationSpeedMultiplier;
                document.getElementById('simSpeedValue').textContent = `${simulationSpeedMultiplier}x`;
                document.getElementById('epochPeriodInput').value = Math.floor(epochPeriodSeconds / (60 * 60 * 24)); // Display in days
                document.getElementById('epochPeriodValue').value = 'days'; // Set dropdown to days
                renderBotAggressionSliders();
                renderScenarioEditor();
            } else if (currentActivePage === 'leaderboard') {
                updateLeaderboard();
                renderLeaderboardTable();
            }
        }

        // --- Page Rendering Functions ---

        function renderDashboard() {
            return `
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                    <div id="pdexPriceCard" class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">PDEX Price</h2>
                        <p id="pdexPriceDisplay" class="text-4xl font-bold text-cyan-400">${formatCurrency(pdexPrice)}</p>
                    </div>
                    <div id="totalBurnedCard" class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">Total PDEX Burned</h2>
                        <p id="totalBurnedDisplay" class="text-4xl font-bold text-red-400">${formatLargeNumber(totalPDEXBurned)}</p>
                    </div>
                    <div id="totalLockedVePDEXCard" class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">Total vePDEX Locked</h2>
                        <p id="totalLockedVePDEXDisplay" class="text-4xl font-bold text-purple-400">${formatLargeNumber(totalPDEXLocked)}</p>
                    </div>
                    <div id="marketCapCard" class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">PDEX Market Cap</h2>
                        <p id="marketCapDisplay" class="text-4xl font-bold text-green-400">${formatCurrency(pdexPrice * circulatingPDEXSupply)}</p>
                    </div>
                    <div id="protocolVePDEXCard" class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">Protocol-Owned vePDEX</h2>
                        <p id="protocolVePDEXDisplay" class="text-4xl font-bold text-blue-400">${formatLargeNumber(protocolOwnedVePDEX)}</p>
                    </div>
                    <div id="epochTimerCard" class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">Next Epoch In</h2>
                        <p id="epochTimer" class="text-4xl font-bold epoch-timer normal">--:--:--:--</p>
                        <p class="text-sm text-gray-400 mt-2">Epoch ${currentEpoch} active</p>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="card">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Top Pools by TVL</h2>
                        <ul id="topPoolsList" class="divide-y divide-gray-700">
                            <!-- Top pools will be rendered here by updateUI -->
                        </ul>
                    </div>
                    <div class="card">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Recent Activity</h2>
                        <ul id="recentActivityList" class="divide-y divide-gray-700 max-h-64 overflow-y-auto">
                            <!-- Recent activity will be rendered here by updateUI -->
                        </ul>
                    </div>
                    <div class="lg:col-span-2 card">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Historical PDEX Price</h2>
                        <div id="pdexPriceChartContainer" class="h-64 w-full">
                            <!-- Recharts component will be rendered here -->
                        </div>
                    </div>
                </div>
            `;
        }

        function renderLiquidity() {
            const allTokens = Object.keys(userWallet).filter(t => t !== 'UNVEPDEX' && !t.startsWith('LP_'));
            const poolOptions = liquidityPools.map(pool => `<option value="${pool.id}">${pool.tokenA}/${pool.tokenB}</option>`).join('');

            return `
                <h1 class="text-3xl font-bold text-cyan-400 mb-6">Liquidity & Swap</h1>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Select Pool</h2>
                        <select id="poolSelect" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200 focus:ring-cyan-500 focus:border-cyan-500">
                            ${poolOptions}
                        </select>
                        <div id="selectedPoolDetails" class="mt-4 text-gray-300">
                            <!-- Pool details will be loaded here -->
                        </div>
                    </div>

                    <div class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Swap Tokens</h2>
                        <div class="mb-4">
                            <label for="swapInputAmount" class="block text-gray-400 text-sm mb-1">Amount to Swap</label>
                            <input type="number" id="swapInputAmount" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" placeholder="0.0" min="0">
                        </div>
                        <div class="mb-4">
                            <label for="swapInputToken" class="block text-gray-400 text-sm mb-1">From Token</label>
                            <select id="swapInputToken" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200">
                                ${allTokens.map(token => `<option value="${token}">${token}</option>`).join('')}
                            </select>
                        </div>
                        <div id="swapPreview" class="text-gray-300 mb-4">
                            <!-- Swap preview will be loaded here -->
                        </div>
                        <button id="swapBtn" class="btn-primary w-full">Swap</button>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Add Liquidity</h2>
                        <div class="mb-4">
                            <label for="addLiquidityTokenAAmount" class="block text-gray-400 text-sm mb-1">Amount of Token A</label>
                            <input type="number" id="addLiquidityTokenAAmount" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" placeholder="0.0" min="0">
                        </div>
                        <div id="addLiquidityPreview" class="text-gray-300 mb-4">
                            <!-- Add liquidity preview will be loaded here -->
                        </div>
                        <button id="addLiquidityBtn" class="btn-primary w-full">Add Liquidity</button>
                    </div>

                    <div class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Remove Liquidity</h2>
                        <div class="mb-4">
                            <label for="removeLiquidityLPTokenAmount" class="block text-gray-400 text-sm mb-1">LP Tokens to Remove</label>
                            <input type="number" id="removeLiquidityLPTokenAmount" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" placeholder="0.0" min="0">
                        </div>
                        <div id="removeLiquidityPreview" class="text-gray-300 mb-4">
                            <!-- Remove liquidity preview will be loaded here -->
                        </div>
                        <button id="removeLiquidityBtn" class="btn-primary w-full">Remove Liquidity</button>
                    </div>
                </div>

                <div class="card">
                    <h2 class="text-xl font-semibold text-gray-200 mb-4">Your LP Positions</h2>
                    <div id="userLpPositionsList" class="max-h-64 overflow-y-auto">
                        <!-- User LP positions will be rendered here -->
                    </div>
                </div>
            `;
        }

        function updateLiquidityPoolDetails() {
            const poolSelect = document.getElementById('poolSelect');
            const selectedPoolId = poolSelect.value;
            const pool = liquidityPools.find(p => p.id === selectedPoolId);
            const detailsDiv = document.getElementById('selectedPoolDetails');

            if (pool) {
                detailsDiv.innerHTML = `
                    <p><strong>Type:</strong> ${pool.type}</p>
                    <p><strong>Reserves:</strong> ${formatLargeNumber(pool.reserveA)} ${pool.tokenA} / ${formatLargeNumber(pool.reserveB)} ${pool.tokenB}</p>
                    <p><strong>TVL:</strong> ${formatCurrency(pool.tvl)}</p>
                    <p><strong>Current Price:</strong> 1 ${pool.tokenA} = ${formatLargeNumber(pool.reserveB / pool.reserveA)} ${pool.tokenB}</p>
                `;
                // Update swap/add/remove inputs to reflect selected pool's tokens
                const swapInputTokenSelect = document.getElementById('swapInputToken');
                const swapOutputTokenSpan = document.getElementById('swapOutputToken'); // Placeholder for output token display
                
                // Ensure swap input token options are available
                const currentTokensInPool = [pool.tokenA, pool.tokenB];
                const swapInputOptions = swapInputTokenSelect.options;
                for(let i = 0; i < swapInputOptions.length; i++) {
                    const option = swapInputOptions[i];
                    if (currentTokensInPool.includes(option.value)) {
                        option.style.display = '';
                    } else {
                        option.style.display = 'none';
                    }
                }
                // Set default selected swap input token to pool.tokenA
                swapInputTokenSelect.value = pool.tokenA;

            } else {
                detailsDiv.innerHTML = '<p class="text-gray-500">Select a pool to see details.</p>';
            }
            updateSwapPreview();
            updateAddLiquidityPreview();
            updateRemoveLiquidityPreview();
        }

        function updateSwapPreview() {
            const poolSelect = document.getElementById('poolSelect');
            const selectedPoolId = poolSelect.value;
            const pool = liquidityPools.find(p => p.id === selectedPoolId);
            const inputAmount = parseFloat(document.getElementById('swapInputAmount').value);
            const inputToken = document.getElementById('swapInputToken').value;
            const previewDiv = document.getElementById('swapPreview');

            if (!pool || isNaN(inputAmount) || inputAmount <= 0) {
                previewDiv.innerHTML = '<p class="text-gray-500">Enter amount to see preview.</p>';
                return;
            }

            const outputToken = pool.tokenA === inputToken ? pool.tokenB : pool.tokenA;
            if (inputToken === outputToken) { // Should not happen with correct select options
                previewDiv.innerHTML = '<p class="text-red-400">Cannot swap same tokens.</p>';
                return;
            }

            const lpFeeRate = 0.003;
            const platformFeeRate = 0.01;

            const effectiveInputAmount = inputAmount / (1 + lpFeeRate + platformFeeRate);
            const reserveIn = pool.tokenA === inputToken ? pool.reserveA : pool.reserveB;
            const reserveOut = pool.tokenA === outputToken ? pool.reserveA : pool.reserveB;

            const estimatedOutput = (reserveOut * effectiveInputAmount) / (reserveIn + effectiveInputAmount);
            const priceBefore = reserveOut / reserveIn;
            const priceAfter = (reserveOut - estimatedOutput) / (reserveIn + effectiveInputAmount);
            const slippage = ((priceBefore - priceAfter) / priceBefore) * 100;

            const lpFee = inputAmount * lpFeeRate;
            const platformFee = inputAmount * platformFeeRate;
            const platformFeeToUNVEPDEX_USDT = platformFee * 0.5 * getPrice(inputToken);
            const platformFeeToTreasury = platformFee * 0.5;

            previewDiv.innerHTML = `
                <p><strong>Estimated Output:</strong> ${formatLargeNumber(estimatedOutput)} ${outputToken}</p>
                <p><strong>Slippage:</strong> ${slippage.toFixed(2)}%</p>
                <p><strong>Fees:</strong></p>
                <ul class="list-disc list-inside ml-4 text-sm text-gray-400">
                    <li>LP Fee (0.3%): ${formatLargeNumber(lpFee)} ${inputToken} (added to pool)</li>
                    <li>Platform Fee (1%): ${formatLargeNumber(platformFee)} ${inputToken}</li>
                    <ul class="list-disc list-inside ml-8 text-xs text-gray-500">
                        <li>0.5% to UNVEPDEX Pool: ${formatCurrency(platformFeeToUNVEPDEX_USDT)} USDT</li>
                        <li>0.5% to FEES Wallet: ${formatLargeNumber(platformFeeToTreasury)} ${inputToken}</li>
                    </ul>
                </ul>
            `;
        }

        function handleSwap() {
            const poolSelect = document.getElementById('poolSelect');
            const selectedPoolId = poolSelect.value;
            const inputAmount = parseFloat(document.getElementById('swapInputAmount').value);
            const inputToken = document.getElementById('swapInputToken').value;
            const pool = liquidityPools.find(p => p.id === selectedPoolId);

            if (!pool || isNaN(inputAmount) || inputAmount <= 0) {
                showToast('Please enter a valid amount and select a pool.', 'error');
                return;
            }

            const outputToken = pool.tokenA === inputToken ? pool.tokenB : pool.tokenA;

            showConfirmationModal(
                'Confirm Swap',
                `Are you sure you want to swap ${formatLargeNumber(inputAmount)} ${inputToken} for ${outputToken}?`,
                () => {
                    const result = swapTokens(selectedPoolId, inputToken, inputAmount, outputToken, 'user');
                    if (result) {
                        // Animate swap route
                        const swapRouteDiv = document.createElement('div');
                        swapRouteDiv.className = 'swap-route';
                        swapRouteDiv.innerHTML = `
                            <span class="token-icon">${inputToken}</span>
                            <i class="fas fa-arrow-right arrow"></i>
                            <span class="token-icon">${outputToken}</span>
                            <div class="glowing-line"></div>
                        `;
                        const swapSection = document.querySelector('#pageContent .card:nth-child(2)'); // Target the swap card
                        if (swapSection) {
                            swapSection.appendChild(swapRouteDiv);
                            playSound('ding');
                            setTimeout(() => {
                                swapRouteDiv.remove();
                                showToast('Transaction Complete!', 'success');
                            }, 2000); // Match animation duration
                        }
                    }
                }
            );
        }

        function updateAddLiquidityPreview() {
            const poolSelect = document.getElementById('poolSelect');
            const selectedPoolId = poolSelect.value;
            const pool = liquidityPools.find(p => p.id === selectedPoolId);
            const amountAInput = parseFloat(document.getElementById('addLiquidityTokenAAmount').value);
            const previewDiv = document.getElementById('addLiquidityPreview');

            if (!pool || isNaN(amountAInput) || amountAInput <= 0) {
                previewDiv.innerHTML = '<p class="text-gray-500">Enter amount for Token A to see preview.</p>';
                return;
            }

            // Calculate equivalent value in USD for Token A
            const amountAUSDValue = amountAInput * getPrice(pool.tokenA);

            // Calculate required amount for Token B based on USD equivalent
            const requiredAmountB = amountAUSDValue / getPrice(pool.tokenB);

            const feeRate = 0.005; // 0.5%
            const feeToUNVEPDEXRate = 0.0025; // 0.25%
            const feeToTreasuryRate = 0.0025; // 0.25%

            const feeA = amountAInput * feeRate;
            const feeB = requiredAmountB * feeRate;

            const netAmountA = amountAInput - feeA;
            const netAmountB = requiredAmountB - feeB;

            const totalFeeUSD = (feeA * getPrice(pool.tokenA)) + (feeB * getPrice(pool.tokenB));
            const feeToUNVEPDEX_USDT = (amountAInput * feeToUNVEPDEXRate * getPrice(pool.tokenA)) + (requiredAmountB * feeToUNVEPDEXRate * getPrice(pool.tokenB));
            const feeToTreasuryUSD = (amountAInput * feeToTreasuryRate * getPrice(pool.tokenA)) + (requiredAmountB * feeToTreasuryRate * getPrice(pool.tokenB));


            previewDiv.innerHTML = `
                <p><strong>You will add:</strong> ${formatLargeNumber(amountAInput)} ${pool.tokenA} and ${formatLargeNumber(requiredAmountB)} ${pool.tokenB}</p>
                <p><strong>Equivalent USD Value:</strong> ${formatCurrency(amountAUSDValue * 2)}</p>
                <p><strong>Fees (0.5% each token):</strong></p>
                <ul class="list-disc list-inside ml-4 text-sm text-gray-400">
                    <li>Total Fee: ${formatCurrency(totalFeeUSD)} USD equivalent</li>
                    <ul class="list-disc list-inside ml-8 text-xs text-gray-500">
                        <li>0.25% to UNVEPDEX Pool: ${formatCurrency(feeToUNVEPDEX_USDT)} USDT</li>
                        <li>0.25% to FEES Wallet: ${formatCurrency(feeToTreasuryUSD)} USD equivalent</li>
                    </ul>
                </ul>
                <p class="text-sm text-gray-400 mt-2">After fees, net amounts: ${formatLargeNumber(netAmountA)} ${pool.tokenA} and ${formatLargeNumber(netAmountB)} ${pool.tokenB}</p>
            `;
        }

        function handleAddLiquidity() {
            const poolSelect = document.getElementById('poolSelect');
            const selectedPoolId = poolSelect.value;
            const pool = liquidityPools.find(p => p.id === selectedPoolId);
            const amountAInput = parseFloat(document.getElementById('addLiquidityTokenAAmount').value);

            if (!pool || isNaN(amountAInput) || amountAInput <= 0) {
                showToast('Please enter a valid amount for Token A and select a pool.', 'error');
                return;
            }

            const amountAUSDValue = amountAInput * getPrice(pool.tokenA);
            const requiredAmountB = amountAUSDValue / getPrice(pool.tokenB);

            showConfirmationModal(
                'Confirm Add Liquidity',
                `Are you sure you want to add ${formatLargeNumber(amountAInput)} ${pool.tokenA} and ${formatLargeNumber(requiredAmountB)} ${pool.tokenB} to ${pool.tokenA}/${pool.tokenB} pool?`,
                () => {
                    const success = addLiquidity(selectedPoolId, amountAInput, requiredAmountB, 'user');
                    if (success) {
                        showToast('Liquidity added successfully!', 'success');
                    }
                }
            );
        }

        function updateRemoveLiquidityPreview() {
            const poolSelect = document.getElementById('poolSelect');
            const selectedPoolId = poolSelect.value;
            const pool = liquidityPools.find(p => p.id === selectedPoolId);
            const lpTokensToRemove = parseFloat(document.getElementById('removeLiquidityLPTokenAmount').value);
            const previewDiv = document.getElementById('removeLiquidityPreview');

            if (!pool || isNaN(lpTokensToRemove) || lpTokensToRemove <= 0) {
                previewDiv.innerHTML = '<p class="text-gray-500">Enter LP tokens to remove to see preview.</p>';
                return;
            }

            if (pool.lpSupply === 0) {
                previewDiv.innerHTML = '<p class="text-red-400">Pool has no LP supply.</p>';
                return;
            }

            const share = lpTokensToRemove / pool.lpSupply;
            const estimatedAmountAToReceive = pool.reserveA * share;
            const estimatedAmountBToReceive = pool.reserveB * share;

            const feeRate = 0.005;
            const netAmountA = estimatedAmountAToReceive * (1 - feeRate);
            const netAmountB = estimatedAmountBToReceive * (1 - feeRate);

            const totalFeeUSD = (estimatedAmountAToReceive * feeRate * getPrice(pool.tokenA)) + (estimatedAmountBToReceive * feeRate * getPrice(pool.tokenB));
            const feeToUNVEPDEX_USDT = (estimatedAmountAToReceive * 0.0025 * getPrice(pool.tokenA)) + (estimatedAmountBToReceive * 0.0025 * getPrice(pool.tokenB));
            const feeToTreasuryUSD = (estimatedAmountAToReceive * 0.0025 * getPrice(pool.tokenA)) + (estimatedAmountBToReceive * 0.0025 * getPrice(pool.tokenB));

            previewDiv.innerHTML = `
                <p><strong>You will receive:</strong> ${formatLargeNumber(netAmountA)} ${pool.tokenA} and ${formatLargeNumber(netAmountB)} ${pool.tokenB}</p>
                <p><strong>Fees (0.5% each token):</strong></p>
                <ul class="list-disc list-inside ml-4 text-sm text-gray-400">
                    <li>Total Fee: ${formatCurrency(totalFeeUSD)} USD equivalent</li>
                    <ul class="list-disc list-inside ml-8 text-xs text-gray-500">
                        <li>0.25% to UNVEPDEX Pool: ${formatCurrency(feeToUNVEPDEX_USDT)} USDT</li>
                        <li>0.25% to FEES Wallet: ${formatCurrency(feeToTreasuryUSD)} USD equivalent</li>
                    </ul>
                </ul>
            `;
        }

        function handleRemoveLiquidity() {
            const poolSelect = document.getElementById('poolSelect');
            const selectedPoolId = poolSelect.value;
            const lpTokensToRemove = parseFloat(document.getElementById('removeLiquidityLPTokenAmount').value);

            if (!poolSelect.value || isNaN(lpTokensToRemove) || lpTokensToRemove <= 0) {
                showToast('Please enter a valid amount of LP tokens and select a pool.', 'error');
                return;
            }

            showConfirmationModal(
                'Confirm Remove Liquidity',
                `Are you sure you want to remove ${formatLargeNumber(lpTokensToRemove)} LP tokens from the selected pool?`,
                () => {
                    const success = removeLiquidity(selectedPoolId, lpTokensToRemove, 'user');
                    if (success) {
                        showToast('Liquidity removed successfully!', 'success');
                    }
                }
            );
        }

        function renderUserLpPositions() {
            const lpListDiv = document.getElementById('userLpPositionsList');
            let lpHtml = '';
            let hasLp = false;

            for (const key in userWallet) {
                if (key.startsWith('LP_') && userWallet[key] > 0.001) {
                    hasLp = true;
                    const poolId = key.substring(3);
                    const pool = liquidityPools.find(p => p.id === poolId);
                    if (pool) {
                        const lpShare = userWallet[key] / pool.lpSupply;
                        const userTVL = lpShare * pool.tvl;
                        lpHtml += `
                            <div class="p-3 border-b border-gray-700 last:border-b-0">
                                <p class="font-semibold text-gray-200">${pool.tokenA}/${pool.tokenB} Pool</p>
                                <p class="text-sm text-gray-400">Your LP Tokens: ${formatLargeNumber(userWallet[key])}</p>
                                <p class="text-sm text-gray-400">Your Share: ${formatPercentage(lpShare)}</p>
                                <p class="text-sm text-gray-400">Your TVL: ${formatCurrency(userTVL)}</p>
                            </div>
                        `;
                    }
                }
            }
            if (!hasLp) {
                lpHtml = '<p class="text-gray-500 text-center py-4">You have no active LP positions.</p>';
            }
            lpListDiv.innerHTML = lpHtml;
        }

        function renderVoting() {
            const poolOptions = liquidityPools.map(pool => `<option value="${pool.id}">${pool.tokenA}/${pool.tokenB}</option>`).join('');
            const totalUserVePDEX = userVePDEXLocks.reduce((sum, lock) => sum + lock.vePDEXAmount, 0);

            return `
                <h1 class="text-3xl font-bold text-cyan-400 mb-6">Voting & Bribes</h1>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">My vePDEX Balance</h2>
                        <p id="myVePDEXBalanceDisplay" class="text-4xl font-bold text-purple-400">${formatLargeNumber(totalUserVePDEX)}</p>
                        <p class="text-sm text-gray-400 mt-2">Influence emission distribution and earn bribes.</p>
                    </div>

                    <div class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Cast Vote</h2>
                        <div class="mb-4">
                            <label for="votePoolSelect" class="block text-gray-400 text-sm mb-1">Select Pool</label>
                            <select id="votePoolSelect" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200">
                                ${poolOptions}
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="voteAmount" class="block text-gray-400 text-sm mb-1">vePDEX to Allocate</label>
                            <input type="number" id="voteAmount" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" placeholder="0.0" min="0" max="${totalUserVePDEX}">
                        </div>
                        <div id="voteImpactPreview" class="text-gray-300 mb-4">
                            <!-- Vote impact preview will be loaded here -->
                        </div>
                        <button id="submitVoteBtn" class="btn-primary w-full">Submit Vote</button>
                        ${totalUserVePDEX >= 100000 ? `
                        <div class="mt-4">
                            <h3 class="text-lg font-semibold text-gray-200 mb-2">Supermassive veNFT Auto-Vote</h3>
                            <p class="text-sm text-gray-400 mb-2">Configure automatic voting strategy:</p>
                            <select id="autoVoteStrategy" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200">
                                <option value="none">None</option>
                                <option value="highestBribes">Highest Bribes</option>
                                <option value="highestTVL">Highest TVL Pools</option>
                            </select>
                            <button id="setAutoVoteBtn" class="btn-secondary w-full mt-2">Set Auto-Vote</button>
                        </div>
                        ` : `<p class="text-sm text-gray-500 mt-4">Lock 100,000+ PDEX for Supermassive veNFT auto-vote.</p>`}
                    </div>
                </div>

                <div class="card mb-8">
                    <h2 class="text-xl font-semibold text-gray-200 mb-4">Votable Pools & Bribes</h2>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-700">
                            <thead class="bg-gray-700">
                                <tr>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Pool</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Total Votes</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Projected Emissions Share</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Total Bribes</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="votablePoolsTableBody" class="divide-y divide-gray-800">
                                <!-- Votable pools will be rendered here -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="card">
                    <h2 class="text-xl font-semibold text-gray-200 mb-4">Active Bribe Offers</h2>
                    <button id="createBribeBtn" class="btn-primary mb-4"><i class="fas fa-plus mr-2"></i> Create New Bribe Offer</button>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-700">
                            <thead class="bg-gray-700">
                                <tr>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Bribe Giver</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Target Pool</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Bribe Amount</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Vesting</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Epoch Created</th>
                                </tr>
                            </thead>
                            <tbody id="activeBribeOffersTableBody" class="divide-y divide-gray-800">
                                <!-- Active bribe offers will be rendered here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        function updateVoteImpactPreview() {
            const votePoolSelect = document.getElementById('votePoolSelect');
            const selectedPoolId = votePoolSelect.value;
            const voteAmount = parseFloat(document.getElementById('voteAmount').value);
            const previewDiv = document.getElementById('voteImpactPreview');

            const pool = liquidityPools.find(p => p.id === selectedPoolId);
            const totalUserVePDEX = userVePDEXLocks.reduce((sum, lock) => sum + lock.vePDEXAmount, 0);

            if (!pool || isNaN(voteAmount) || voteAmount <= 0) {
                previewDiv.innerHTML = '<p class="text-gray-500">Enter vePDEX amount to see impact.</p>';
                return;
            }
            if (voteAmount > totalUserVePDEX) {
                previewDiv.innerHTML = '<p class="text-red-400">Insufficient vePDEX balance.</p>';
                return;
            }

            const currentPoolVotes = pool.votes;
            const totalNetworkVotes = liquidityPools.reduce((sum, p) => sum + p.votes, 0);

            const newTotalPoolVotes = currentPoolVotes + voteAmount;
            const newTotalNetworkVotes = totalNetworkVotes + voteAmount; // Assuming this vote is new

            const currentShare = totalNetworkVotes > 0 ? (currentPoolVotes / totalNetworkVotes) : 0;
            const projectedShare = newTotalNetworkVotes > 0 ? (newTotalPoolVotes / newTotalNetworkVotes) : 0;

            let totalBribesForPool = 0;
            pool.currentBribes.forEach(b => totalBribesForPool += b.amount * getPrice(b.token)); // Sum bribes in USD

            let estimatedBribeShare = 0;
            if (newTotalPoolVotes > 0 && totalBribesForPool > 0) {
                estimatedBribeShare = (voteAmount / newTotalPoolVotes) * totalBribesForPool;
            }


            previewDiv.innerHTML = `
                <p><strong>Current Share:</strong> ${formatPercentage(currentShare)}</p>
                <p><strong>Projected Share (with your vote):</strong> ${formatPercentage(projectedShare)}</p>
                <p><strong>Estimated Bribe Earnings:</strong> ${formatCurrency(estimatedBribeShare)} (based on current bribes)</p>
            `;
        }

        function handleSubmitVote() {
            const votePoolSelect = document.getElementById('votePoolSelect');
            const selectedPoolId = votePoolSelect.value;
            const voteAmount = parseFloat(document.getElementById('voteAmount').value);

            const totalUserVePDEX = userVePDEXLocks.reduce((sum, lock) => sum + lock.vePDEXAmount, 0);
            if (isNaN(voteAmount) || voteAmount <= 0 || voteAmount > totalUserVePDEX) {
                showToast('Invalid vePDEX amount or insufficient balance.', 'error');
                return;
            }

            const pool = liquidityPools.find(p => p.id === selectedPoolId);
            if (!pool) {
                showToast('Selected pool not found.', 'error');
                return;
            }

            showConfirmationModal(
                'Confirm Vote',
                `Are you sure you want to allocate ${formatLargeNumber(voteAmount)} vePDEX to ${pool.tokenA}/${pool.tokenB} pool?`,
                () => {
                    // Allocate vote amount among user's vePDEX locks
                    let allocated = 0;
                    for (const lock of userVePDEXLocks) {
                        if (allocated < voteAmount) {
                            lock.votedPoolId = pool.id; // Assign this vePDEX to vote for this pool
                            allocated += lock.vePDEXAmount;
                        } else {
                            lock.votedPoolId = null; // Clear vote if not allocated
                        }
                    }
                    pool.votes = (pool.votes || 0) + voteAmount; // Update pool's total votes
                    addTransaction('Vote Cast', `User allocated ${formatLargeNumber(voteAmount)} vePDEX to ${pool.tokenA}/${pool.tokenB} pool.`);
                    showToast('Vote cast successfully!', 'success');
                    updateUI();
                }
            );
        }

        function renderVotablePools() {
            const tableBody = document.getElementById('votablePoolsTableBody');
            if (!tableBody) return;

            tableBody.innerHTML = liquidityPools.map(pool => {
                const totalNetworkVotes = liquidityPools.reduce((sum, p) => sum + p.votes, 0);
                const projectedShare = totalNetworkVotes > 0 ? (pool.votes / totalNetworkVotes) : 0;
                
                let totalBribesForPool = 0;
                pool.currentBribes.forEach(b => totalBribesForPool += b.amount * getPrice(b.token)); // Sum bribes in USD

                return `
                    <tr class="hover:bg-gray-800">
                        <td class="px-4 py-2 whitespace-nowrap">${pool.tokenA}/${pool.tokenB}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${formatLargeNumber(pool.votes)}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${formatPercentage(projectedShare)}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${formatCurrency(totalBribesForPool)}</td>
                        <td class="px-4 py-2 whitespace-nowrap">
                            <button class="btn-secondary text-sm" onclick="document.getElementById('votePoolSelect').value='${pool.id}'; showPage('voting');">Vote</button>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function showCreateBribeModal() {
            const allTokens = Object.keys(userWallet).filter(t => userWallet[t] > 0.01 && !t.startsWith('LP_') && t !== 'UNVEPDEX');
            const poolOptions = liquidityPools.map(pool => `<option value="${pool.id}">${pool.tokenA}/${pool.tokenB}</option>`).join('');

            const modalHtml = `
                <div class="modal-overlay">
                    <div class="modal-content">
                        <h3 class="text-xl font-bold mb-4">Create New Bribe Offer</h3>
                        <div class="mb-4">
                            <label for="bribePoolSelect" class="block text-gray-400 text-sm mb-1">Target Pool</label>
                            <select id="bribePoolSelect" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200">
                                ${poolOptions}
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="bribeTokenSelect" class="block text-gray-400 text-sm mb-1">Bribe Token</label>
                            <select id="bribeTokenSelect" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200">
                                ${allTokens.map(token => `<option value="${token}">${token}</option>`).join('')}
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="bribeAmountInput" class="block text-gray-400 text-sm mb-1">Bribe Amount</label>
                            <input type="number" id="bribeAmountInput" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" placeholder="0.0" min="0">
                        </div>
                        <div class="mb-6">
                            <label for="bribeVestingSelect" class="block text-gray-400 text-sm mb-1">Vesting Schedule</label>
                            <select id="bribeVestingSelect" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200">
                                <option value="immediate">Immediate (Next Epoch End)</option>
                                <!-- <option value="multi-epoch">Multi-Epoch (Future)</option> -->
                            </select>
                        </div>
                        <div class="flex justify-center space-x-4">
                            <button id="confirmCreateBribeBtn" class="btn-primary">Create Bribe</button>
                            <button id="cancelCreateBribeBtn" class="btn-secondary">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('modalContainer').innerHTML = modalHtml;

            document.getElementById('confirmCreateBribeBtn').onclick = () => {
                const targetPoolId = document.getElementById('bribePoolSelect').value;
                const bribeToken = document.getElementById('bribeTokenSelect').value;
                const bribeAmount = parseFloat(document.getElementById('bribeAmountInput').value);
                const vesting = document.getElementById('bribeVestingSelect').value;

                if (createBribeOffer(targetPoolId, bribeToken, bribeAmount, 'user', vesting)) {
                    document.getElementById('modalContainer').innerHTML = '';
                }
            };
            document.getElementById('cancelCreateBribeBtn').onclick = () => {
                document.getElementById('modalContainer').innerHTML = '';
            };
        }

        function renderBribeOffers() {
            const tableBody = document.getElementById('activeBribeOffersTableBody');
            if (!tableBody) return;

            let bribeHtml = '';
            liquidityPools.forEach(pool => {
                pool.currentBribes.forEach(bribe => {
                    bribeHtml += `
                        <tr class="hover:bg-gray-800">
                            <td class="px-4 py-2 whitespace-nowrap">${bribe.giverId}</td>
                            <td class="px-4 py-2 whitespace-nowrap">${pool.tokenA}/${pool.tokenB}</td>
                            <td class="px-4 py-2 whitespace-nowrap">${formatLargeNumber(bribe.amount)} ${bribe.token}</td>
                            <td class="px-4 py-2 whitespace-nowrap">${bribe.vesting === 'immediate' ? 'Next Epoch' : bribe.vesting}</td>
                            <td class="px-4 py-2 whitespace-nowrap">Epoch ${bribe.epochCreated}</td>
                        </tr>
                    `;
                });
            });
            if (!bribeHtml) {
                bribeHtml = `<tr><td colspan="5" class="text-center text-gray-500 py-4">No active bribe offers.</td></tr>`;
            }
            tableBody.innerHTML = bribeHtml;
        }


        function renderEmissions() {
            return `
                <h1 class="text-3xl font-bold text-cyan-400 mb-6">Emissions & Rewards</h1>

                <div class="card mb-8">
                    <h2 class="text-xl font-semibold text-gray-200 mb-4">Claimable Rewards</h2>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-700">
                            <thead class="bg-gray-700">
                                <tr>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Pool</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Reward Type</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Amount</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Status</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="claimableRewardsTableBody" class="divide-y divide-gray-800">
                                <!-- Claimable rewards will be rendered here -->
                            </tbody>
                        </table>
                    </div>
                    <button id="claimAllRewardsBtn" class="btn-primary mt-4 w-full">Claim All Rewards</button>
                </div>

                <div class="card">
                    <h2 class="text-xl font-semibold text-gray-200 mb-4">Historical Claims</h2>
                    <div class="overflow-x-auto max-h-64 overflow-y-auto">
                        <table class="min-w-full divide-y divide-gray-700">
                            <thead class="bg-gray-700">
                                <tr>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Time (min ago)</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Type</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Description</th>
                                </tr>
                            </thead>
                            <tbody id="historicalClaimsTableBody" class="divide-y divide-gray-800">
                                <!-- Historical claims will be rendered here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        function renderClaimableRewards() {
            const tableBody = document.getElementById('claimableRewardsTableBody');
            if (!tableBody) return;

            // For simplicity, we'll assume rewards are immediately added to user wallet
            // and the 'Claimable Rewards' section here would show a summary of what was just added
            // or what will be added at epoch end.
            // A more complex system would have a separate 'claimable' balance.
            // For now, we'll just show the last few emission/bribe transactions as "claimed"
            // and provide a conceptual "Claim All" button.

            let hasClaimable = false;
            let rewardsHtml = '';

            // This section is more conceptual for now, as emissions/bribes are directly added
            // to wallet at epoch end. In a real app, these would be balances to claim.
            // For this simulation, we'll just show a placeholder or a summary of recent earnings.
            rewardsHtml += `
                <tr>
                    <td colspan="5" class="text-center text-gray-500 py-4">Rewards are automatically distributed to your wallet at epoch end.</td>
                </tr>
            `;

            tableBody.innerHTML = rewardsHtml;

            const historicalClaimsTableBody = document.getElementById('historicalClaimsTableBody');
            if (historicalClaimsTableBody) {
                historicalClaimsTableBody.innerHTML = transactionHistory.filter(tx => tx.type.includes('Claimed') || tx.type.includes('Bribe Refunded')).map(tx => `
                    <tr class="hover:bg-gray-800">
                        <td class="px-4 py-2 whitespace-nowrap">${simulationTime - tx.timestamp}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${tx.type}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${tx.description}</td>
                    </tr>
                `).join('');
            }
        }

        function handleClaimAllRewards() {
            showToast('All rewards are automatically distributed to your wallet at epoch end!', 'info');
            // In a real app, this would trigger a function to move all pending rewards to wallet
        }

        function renderPortfolio() {
            const totalUserVePDEX = userVePDEXLocks.reduce((sum, lock) => sum + lock.vePDEXAmount, 0);
            const totalWalletValue = Object.keys(userWallet).reduce((sum, token) => sum + (userWallet[token] * getPrice(token)), 0);
            const totalFeesWalletValue = Object.keys(feesWallet).reduce((sum, token) => sum + (feesWallet[token] * getPrice(token)), 0);

            return `
                <h1 class="text-3xl font-bold text-cyan-400 mb-6">Your Portfolio</h1>

                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                    <div class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">Overall Portfolio Value</h2>
                        <p class="text-4xl font-bold text-green-400">${formatCurrency(totalWalletValue + (totalUserVePDEX * pdexPrice) + (userUNVEPDEXBalance * getPrice('UNVEPDEX')) + totalFeesWalletValue)}</p>
                    </div>
                    <div class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">Wallet Balances</h2>
                        <div id="walletBalancesList" class="max-h-32 overflow-y-auto">
                            <!-- Wallet balances will be rendered here -->
                        </div>
                    </div>
                    <div class="card interactive">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">FEES Wallet (Protocol Earnings)</h2>
                        <div id="feesWalletBalancesList" class="max-h-32 overflow-y-auto mb-4">
                            <!-- Fees wallet balances will be rendered here -->
                        </div>
                        <button id="transferFeesBtn" class="btn-secondary w-full">Transfer to Main Wallet</button>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="card">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Locked vePDEX</h2>
                        <button id="lockPDEXBtn" class="btn-primary mb-4"><i class="fas fa-lock mr-2"></i> Lock More PDEX</button>
                        <p class="text-sm text-gray-500 mb-4">Note: PDEX is permanently burned when locked for vePDEX.</p>
                        <div id="lockedVePDEXList" class="max-h-64 overflow-y-auto">
                            <!-- Locked vePDEX items will be rendered here -->
                        </div>
                    </div>

                    <div class="card">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">UNVEPDEX Holdings</h2>
                        <p class="text-4xl font-bold text-yellow-400 mb-2" id="userUNVEPDEXBalanceDisplay">${formatLargeNumber(userUNVEPDEXBalance)}</p>
                        <p class="text-sm text-gray-400 mb-4">This token can be sold for USDT at a fixed 1:1 rate.</p>
                        <button id="sellUNVEPDEXBtn" class="btn-primary w-full">Sell 1 UNVEPDEX for USDT</button>
                        <p class="text-xs text-gray-500 mt-2">Daily Sell Limit: 1 UNVEPDEX (Sold today: <span id="userDailyUNVEPDEXSellCountDisplay">0</span>)</p>
                    </div>
                </div>

                <div class="card">
                    <h2 class="text-xl font-semibold text-gray-200 mb-4">Transaction History (Last 20)</h2>
                    <div class="overflow-x-auto max-h-64 overflow-y-auto">
                        <table class="min-w-full divide-y divide-gray-700">
                            <thead class="bg-gray-700">
                                <tr>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Time (min ago)</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Type</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Description</th>
                                </tr>
                            </thead>
                            <tbody id="portfolioTransactionHistoryTableBody" class="divide-y divide-gray-800">
                                <!-- Transaction history will be rendered here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        function renderPortfolioBalances() {
            const walletList = document.getElementById('walletBalancesList');
            if (!walletList) return;
            let html = '';
            let hasBalance = false;
            for (const token in userWallet) {
                if (userWallet[token] > 0.001 && !token.startsWith('LP_')) { // Filter out LP tokens for this list
                    hasBalance = true;
                    html += `
                        <p class="text-sm text-gray-300">${token}: <span class="font-semibold">${formatLargeNumber(userWallet[token])}</span> (${formatCurrency(userWallet[token] * getPrice(token))})</p>
                    `;
                }
            }
            if (!hasBalance) {
                html = '<p class="text-gray-500">Your wallet is empty.</p>';
            }
            walletList.innerHTML = html;

            const portfolioTransactionHistoryTableBody = document.getElementById('portfolioTransactionHistoryTableBody');
            if (portfolioTransactionHistoryTableBody) {
                portfolioTransactionHistoryTableBody.innerHTML = transactionHistory.map(tx => `
                    <tr class="hover:bg-gray-800">
                        <td class="px-4 py-2 whitespace-nowrap">${simulationTime - tx.timestamp}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${tx.type}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${tx.description}</td>
                    </tr>
                `).join('');
            }
        }

        function renderFeesWalletBalances() {
            const feesWalletList = document.getElementById('feesWalletBalancesList');
            if (!feesWalletList) return;
            let html = '';
            let hasFees = false;
            for (const token in feesWallet) {
                if (feesWallet[token] > 0.001) {
                    hasFees = true;
                    html += `
                        <div class="flex justify-between items-center py-1">
                            <p class="text-sm text-gray-300">${token}: <span class="font-semibold">${formatLargeNumber(feesWallet[token])}</span> (${formatCurrency(feesWallet[token] * getPrice(token))})</p>
                            <button class="btn-secondary text-xs px-2 py-1 rounded-md" onclick="showTransferFeesModal('${token}', ${feesWallet[token]})">Transfer</button>
                        </div>
                    `;
                }
            }
            if (!hasFees) {
                html = '<p class="text-gray-500">FEES wallet is empty.</p>';
            }
            feesWalletList.innerHTML = html;
        }

        function showTransferFeesModal(tokenSymbol = '', amount = 0) {
            const allFeesTokens = Object.keys(feesWallet).filter(t => feesWallet[t] > 0.001);
            const tokenOptions = allFeesTokens.map(token => `<option value="${token}" ${token === tokenSymbol ? 'selected' : ''}>${token}</option>`).join('');

            const modalHtml = `
                <div class="modal-overlay">
                    <div class="modal-content">
                        <h3 class="text-xl font-bold mb-4">Transfer from FEES Wallet</h3>
                        <div class="mb-4">
                            <label for="transferTokenSelect" class="block text-gray-400 text-sm mb-1">Token to Transfer</label>
                            <select id="transferTokenSelect" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200">
                                ${tokenOptions}
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="transferAmountInput" class="block text-gray-400 text-sm mb-1">Amount</label>
                            <input type="number" id="transferAmountInput" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" placeholder="0.0" min="0" value="${amount > 0 ? amount : ''}">
                        </div>
                        <div class="flex justify-center space-x-4">
                            <button id="confirmTransferBtn" class="btn-primary">Transfer</button>
                            <button id="cancelTransferBtn" class="btn-secondary">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('modalContainer').innerHTML = modalHtml;

            document.getElementById('confirmTransferBtn').onclick = () => {
                const selectedToken = document.getElementById('transferTokenSelect').value;
                const transferAmount = parseFloat(document.getElementById('transferAmountInput').value);
                if (handleTransferFees(selectedToken, transferAmount)) {
                    document.getElementById('modalContainer').innerHTML = '';
                }
            };
            document.getElementById('cancelTransferBtn').onclick = () => {
                document.getElementById('modalContainer').innerHTML = '';
            };
        }

        function handleTransferFees(tokenSymbol, amount) {
            return transferFeesToMainWallet(tokenSymbol, amount);
        }

        function renderLockedVePDEX() {
            const lockedList = document.getElementById('lockedVePDEXList');
            if (!lockedList) return;
            let html = '';
            if (userVePDEXLocks.length === 0) {
                html = '<p class="text-gray-500 text-center py-4">You have no locked vePDEX.</p>';
            } else {
                html = userVePDEXLocks.map(lock => {
                    const timeLeft = lock.unlockTime - simulationTime;
                    const daysLeft = Math.floor(timeLeft / (24 * 60));
                    const hoursLeft = Math.floor((timeLeft % (24 * 60)) / 60);
                    const minutesLeft = Math.floor(timeLeft % 60);
                    const timeString = timeLeft <= 0 ? 'Expired' : `${daysLeft}d ${hoursLeft}h ${minutesLeft}m`;
                    const isExpired = timeLeft <= 0;

                    return `
                        <div class="p-3 border-b border-gray-700 last:border-b-0">
                            <p class="font-semibold text-gray-200">Locked: ${formatLargeNumber(lock.pdexLocked)} PDEX</p>
                            <p class="text-sm text-gray-400">vePDEX: ${formatLargeNumber(lock.vePDEXAmount)}</p>
                            <p class="text-sm text-gray-400">Lock Duration: ${lock.lockDurationWeeks} weeks</p>
                            <p class="text-sm text-gray-400">Time Left: ${timeString}</p>
                            ${isExpired ? `<button class="btn-primary text-sm mt-2 unlock-vepdex-btn" data-lock-id="${lock.id}">Unlock</button>` : ''}
                        </div>
                    `;
                }).join('');
            }
            lockedList.innerHTML = html;
        }

        function showLockPDEXModal() {
            const totalUserPDEX = userWallet.PDEX;
            const modalHtml = `
                <div class="modal-overlay">
                    <div class="modal-content">
                        <h3 class="text-xl font-bold mb-4">Lock PDEX for vePDEX</h3>
                        <p class="text-sm text-gray-500 mb-4">Your PDEX will be permanently burned.</p>
                        <div class="mb-4">
                            <label for="lockAmountInput" class="block text-gray-400 text-sm mb-1">Amount of PDEX to Lock (Available: ${formatLargeNumber(totalUserPDEX)})</label>
                            <input type="number" id="lockAmountInput" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" placeholder="0.0" min="0" max="${totalUserPDEX}">
                        </div>
                        <div class="mb-4">
                            <label for="lockDurationInput" class="block text-gray-400 text-sm mb-1">Lock Duration (Weeks, Max 208)</label>
                            <input type="number" id="lockDurationInput" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" placeholder="0" min="1" max="208">
                        </div>
                        <div class="flex justify-center space-x-4">
                            <button id="confirmLockBtn" class="btn-primary">Lock PDEX</button>
                            <button id="cancelLockBtn" class="btn-secondary">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('modalContainer').innerHTML = modalHtml;

            document.getElementById('confirmLockBtn').onclick = () => {
                const amount = parseFloat(document.getElementById('lockAmountInput').value);
                const duration = parseInt(document.getElementById('lockDurationInput').value);
                if (lockPDEX(amount, duration, 'user')) {
                    document.getElementById('modalContainer').innerHTML = '';
                }
            };
            document.getElementById('cancelLockBtn').onclick = () => {
                document.getElementById('modalContainer').innerHTML = '';
            };
        }

        function handleUnlockVePDEX(lockId) {
            showConfirmationModal(
                'Confirm Unlock',
                'Are you sure you want to unlock this vePDEX? You will receive UNVEPDEX.',
                () => {
                    unlockVePDEX(lockId);
                }
            );
        }

        function handleSellUNVEPDEX() {
            showConfirmationModal(
                'Confirm Sell UNVEPDEX',
                `Are you sure you want to sell 1 UNVEPDEX for 1 USDT? (Daily limit applies)`,
                () => {
                    sellUNVEPDEX(1, 'user');
                }
            );
        }

        function renderTokens() {
            const allTokens = Object.keys(baseAssetPrices).concat(liquidityPools.filter(p => !baseAssetPrices[p.tokenA] && !baseAssetPrices[p.tokenB]).map(p => p.tokenA)); // Include base and custom tokens
            const uniqueTokens = [...new Set(allTokens)]; // Ensure uniqueness

            return `
                <h1 class="text-3xl font-bold text-cyan-400 mb-6">All Tokens</h1>

                <div class="card mb-8">
                    <h2 class="text-xl font-semibold text-gray-200 mb-4">Token List</h2>
                    <div class="overflow-x-auto max-h-96 overflow-y-auto">
                        <table class="min-w-full divide-y divide-gray-700">
                            <thead class="bg-gray-700">
                                <tr>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Token</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Price (USD)</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Type</th>
                                    <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="tokenListTableBody" class="divide-y divide-gray-800">
                                ${uniqueTokens.map(token => {
                                    const price = getPrice(token);
                                    const isBase = baseAssetPrices[token] !== undefined;
                                    const isStable = token === 'USDT' || token === 'USDC' || token === 'UNVEPDEX';
                                    const type = isBase ? (isStable ? 'Stablecoin' : 'Volatile Base') : 'Custom (Bot/User)';
                                    return `
                                        <tr class="hover:bg-gray-800">
                                            <td class="px-4 py-2 whitespace-nowrap">${token}</td>
                                            <td class="px-4 py-2 whitespace-nowrap">${formatCurrency(price)}</td>
                                            <td class="px-4 py-2 whitespace-nowrap">${type}</td>
                                            <td class="px-4 py-2 whitespace-nowrap">
                                                <button class="btn-secondary text-sm" onclick="showInfoModal('Token Details', 'Details for ${token}: Price: ${formatCurrency(price)}')">View Details</button>
                                            </td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        function renderTokenList() {
            // This function is called by updateUI, the HTML is already static for now.
            // If we add complex token details, this would be dynamic.
        }


        function renderAdmin() {
            const aggressionSlidersHtml = ['trading', 'liquidity', 'bribing', 'pdexLocking', 'voting'].map(type => `
                <div class="mb-4">
                    <label for="${type}AggressionSlider" class="block text-gray-400 text-sm mb-1">${type.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())} Aggression:</label>
                    <input type="range" id="${type}AggressionSlider" min="0" max="100" value="${botAggression[type]}" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg">
                    <span id="${type}AggressionValue" class="text-cyan-400 text-sm">${botAggression[type]}</span>
                </div>
            `).join('');

            const savedProfilesOptions = Object.keys(botProfiles).map(profileName => `<option value="${profileName}">${profileName}</option>`).join('');

            return `
                <h1 class="text-3xl font-bold text-cyan-400 mb-6">Admin Panel</h1>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="card">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Simulation Controls</h2>
                        <div class="mb-4">
                            <label for="simSpeedSlider" class="block text-gray-400 text-sm mb-1">Simulation Speed: <span id="simSpeedValue">${simulationSpeedMultiplier}x</span></label>
                            <input type="range" id="simSpeedSlider" min="0.1" max="20" step="0.1" value="${simulationSpeedMultiplier}" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg">
                        </div>
                        <div class="mb-4">
                            <label for="epochPeriodInput" class="block text-gray-400 text-sm mb-1">Next Epoch Period:</label>
                            <div class="flex space-x-2">
                                <input type="number" id="epochPeriodInput" class="w-2/3 p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" placeholder="Value" value="${Math.floor(epochPeriodSeconds / (60 * 60 * 24))}">
                                <select id="epochPeriodValue" class="w-1/3 p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200">
                                    <option value="seconds">Seconds</option>
                                    <option value="minutes">Minutes</option>
                                    <option value="hours">Hours</option>
                                    <option value="days" selected>Days</option>
                                </select>
                            </div>
                        </div>
                        <button id="manualEndEpochBtn" class="btn-secondary w-full mb-2">Manually End Current Epoch</button>
                        <button id="refillVoterIncentivesBtn" class="btn-secondary w-full mb-2">Refill Voter Incentives Pool</button>
                        <button id="resetSimulationBtn" class="btn-danger w-full">Reset Simulation</button>
                    </div>

                    <div class="card">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Bot Aggression Controls</h2>
                        ${aggressionSlidersHtml}
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="card">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Scenario Editor</h2>
                        <div class="mb-4">
                            <label for="saveBotProfileName" class="block text-gray-400 text-sm mb-1">Save Current Profile As:</label>
                            <input type="text" id="saveBotProfileName" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" placeholder="Profile Name">
                            <button id="saveBotProfileBtn" class="btn-secondary w-full mt-2">Save Profile</button>
                        </div>
                        <div class="mb-4">
                            <label for="loadBotProfileSelect" class="block text-gray-400 text-sm mb-1">Load Saved Profile:</label>
                            <select id="loadBotProfileSelect" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200">
                                <option value="">-- Select Profile --</option>
                                ${savedProfilesOptions}
                            </select>
                            <button id="resetBotAggressionBtn" class="btn-secondary w-full mt-2">Reset to Default Aggression</button>
                        </div>
                    </div>

                    <div class="card">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">User Token Launch System</h2>
                        <button id="manualTokenLaunchBtn" class="btn-primary w-full">Launch New Custom Token</button>
                    </div>
                </div>

                <div class="card">
                    <h2 class="text-xl font-semibold text-gray-200 mb-4">Admin Event Log</h2>
                    <div id="adminEventLog" class="bg-gray-900 p-4 rounded-md text-sm text-gray-400 h-64 overflow-y-auto">
                        <!-- Admin events will be logged here -->
                    </div>
                </div>
            `;
        }

        function renderBotAggressionSliders() {
            // This function is called by updateUI to refresh slider values
            const aggressionSliders = ['trading', 'liquidity', 'bribing', 'pdexLocking', 'voting'];
            aggressionSliders.forEach(type => {
                const slider = document.getElementById(`${type}AggressionSlider`);
                const valueSpan = document.getElementById(`${type}AggressionValue`);
                if (slider && valueSpan) {
                    slider.value = botAggression[type];
                    valueSpan.textContent = botAggression[type];
                }
            });
        }

        function renderScenarioEditor() {
            const select = document.getElementById('loadBotProfileSelect');
            if (select) {
                select.innerHTML = '<option value="">-- Select Profile --</option>' + 
                                   Object.keys(botProfiles).map(profileName => `<option value="${profileName}">${profileName}</option>`).join('');
            }
        }

        function handleSaveBotProfile() {
            const profileName = document.getElementById('saveBotProfileName').value.trim();
            if (!profileName) {
                showToast('Please enter a profile name.', 'error');
                return;
            }
            botProfiles[profileName] = { ...botAggression };
            showToast(`Bot profile "${profileName}" saved!`, 'success');
            renderScenarioEditor(); // Refresh dropdown
        }

        function handleLoadBotProfile() {
            const profileName = document.getElementById('loadBotProfileSelect').value;
            if (profileName && botProfiles[profileName]) {
                botAggression = { ...botProfiles[profileName] };
                showToast(`Bot profile "${profileName}" loaded!`, 'success');
                updateUI(); // Refresh sliders
            }
        }

        function handleResetBotAggression() {
            botAggression = { trading: 50, liquidity: 50, bribing: 50, pdexLocking: 50, voting: 50 };
            showToast('Bot aggression reset to default.', 'info');
            updateUI(); // Refresh sliders
        }

        function showManualTokenLaunchModal() {
            const stableTokens = ['USDT', 'USDC'];
            const stableOptions = stableTokens.map(token => `<option value="${token}">${token}</option>`).join('');

            const modalHtml = `
                <div class="modal-overlay">
                    <div class="modal-content">
                        <h3 class="text-xl font-bold mb-4">Launch New Custom Token</h3>
                        <div class="mb-2">
                            <label for="newTokenName" class="block text-gray-400 text-sm mb-1">Token Name</label>
                            <input type="text" id="newTokenName" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" placeholder="e.g., PRECIDO Token">
                        </div>
                        <div class="mb-2">
                            <label for="newTokenTicker" class="block text-gray-400 text-sm mb-1">Ticker (e.g., PCT)</label>
                            <input type="text" id="newTokenTicker" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" placeholder="e.g., PCT" maxlength="5">
                        </div>
                        <div class="mb-2">
                            <label for="newTotalSupply" class="block text-gray-400 text-sm mb-1">Total Supply</label>
                            <input type="number" id="newTotalSupply" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" placeholder="1000000" min="1">
                        </div>
                        <div class="mb-2">
                            <label for="newLiquidityPair" class="block text-gray-400 text-sm mb-1">Liquidity Pair (Stable Token)</label>
                            <select id="newLiquidityPair" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200">
                                ${stableOptions}
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="newLiquidityAmountStable" class="block text-gray-400 text-sm mb-1">Liquidity Amount (Stable Token)</label>
                            <input type="number" id="newLiquidityAmountStable" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" placeholder="50000" min="1">
                        </div>

                        <h4 class="text-lg font-semibold text-gray-200 mb-2">Supply Allocation (%)</h4>
                        <div class="grid grid-cols-2 gap-4 mb-2">
                            <div>
                                <label for="percentLiquidity" class="block text-gray-400 text-sm mb-1">% for Liquidity Pool</label>
                                <input type="number" id="percentLiquidity" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" min="0" max="100" value="50">
                            </div>
                            <div>
                                <label for="percentPlatformWallet" class="block text-gray-400 text-sm mb-1">% for Platform Wallet</label>
                                <input type="number" id="percentPlatformWallet" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" min="0" max="100" value="5">
                            </div>
                            <div>
                                <label for="percentAirdropUser" class="block text-gray-400 text-sm mb-1">% for User Airdrop</label>
                                <input type="number" id="percentAirdropUser" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" min="0" max="100" value="20">
                            </div>
                            <div>
                                <label for="percentAirdropBots" class="block text-gray-400 text-sm mb-1">% for Bot Airdrop</label>
                                <input type="number" id="percentAirdropBots" class="w-full p-2 rounded-md bg-gray-700 border border-gray-600 text-gray-200" min="0" max="100" value="25">
                            </div>
                        </div>
                        <p id="allocationSum" class="text-sm text-right font-semibold mb-4">Total: <span class="text-green-400">100%</span></p>

                        <div class="flex justify-center space-x-4">
                            <button id="confirmLaunchBtn" class="btn-primary">Launch Token</button>
                            <button id="cancelLaunchBtn" class="btn-secondary">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('modalContainer').innerHTML = modalHtml;

            const updateAllocationSum = () => {
                const pL = parseFloat(document.getElementById('percentLiquidity').value) || 0;
                const pPW = parseFloat(document.getElementById('percentPlatformWallet').value) || 0;
                const pAU = parseFloat(document.getElementById('percentAirdropUser').value) || 0;
                const pAB = parseFloat(document.getElementById('percentAirdropBots').value) || 0;
                const sum = pL + pPW + pAU + pAB;
                const sumSpan = document.getElementById('allocationSum').querySelector('span');
                sumSpan.textContent = `${sum}%`;
                if (sum === 100) {
                    sumSpan.classList.remove('text-red-400');
                    sumSpan.classList.add('text-green-400');
                    document.getElementById('confirmLaunchBtn').disabled = false;
                    document.getElementById('confirmLaunchBtn').classList.remove('btn-disabled');
                } else {
                    sumSpan.classList.remove('text-green-400');
                    sumSpan.classList.add('text-red-400');
                    document.getElementById('confirmLaunchBtn').disabled = true;
                    document.getElementById('confirmLaunchBtn').classList.add('btn-disabled');
                }
            };

            document.getElementById('percentLiquidity').oninput = updateAllocationSum;
            document.getElementById('percentPlatformWallet').oninput = updateAllocationSum;
            document.getElementById('percentAirdropUser').oninput = updateAllocationSum;
            document.getElementById('percentAirdropBots').oninput = updateAllocationSum;
            updateAllocationSum(); // Initial calculation

            document.getElementById('confirmLaunchBtn').onclick = handleManualTokenLaunch;
            document.getElementById('cancelLaunchBtn').onclick = () => {
                document.getElementById('modalContainer').innerHTML = '';
            };
        }

        function handleManualTokenLaunch() {
            const name = document.getElementById('newTokenName').value.trim();
            const ticker = document.getElementById('newTokenTicker').value.trim().toUpperCase();
            const totalSupply = parseFloat(document.getElementById('newTotalSupply').value);
            const liquidityPair = document.getElementById('newLiquidityPair').value;
            const liquidityAmountStable = parseFloat(document.getElementById('newLiquidityAmountStable').value);
            const percentLiquidity = parseFloat(document.getElementById('percentLiquidity').value);
            const percentPlatformWallet = parseFloat(document.getElementById('percentPlatformWallet').value);
            const percentAirdropUser = parseFloat(document.getElementById('percentAirdropUser').value);
            const percentAirdropBots = parseFloat(document.getElementById('percentAirdropBots').value);

            if (!name || !ticker || isNaN(totalSupply) || totalSupply <= 0 || isNaN(liquidityAmountStable) || liquidityAmountStable <= 0 ||
                isNaN(percentLiquidity) || isNaN(percentPlatformWallet) || isNaN(percentAirdropUser) || isNaN(percentAirdropBots) ||
                (percentLiquidity + percentPlatformWallet + percentAirdropUser + percentAirdropBots !== 100)) {
                showToast('Please fill all fields correctly and ensure allocations sum to 100%.', 'error');
                return;
            }
            if (baseAssetPrices[ticker] !== undefined || liquidityPools.some(p => p.tokenA === ticker || p.tokenB === ticker)) {
                showToast('Token ticker already exists. Please choose a unique one.', 'error');
                return;
            }

            // Calculate token amounts based on percentages
            const tokenAmountForLiquidity = (totalSupply * percentLiquidity) / 100;
            const tokenAmountForPlatformWallet = (totalSupply * percentPlatformWallet) / 100;
            const tokenAmountForAirdropUser = (totalSupply * percentAirdropUser) / 100;
            const tokenAmountForAirdropBots = (totalSupply * percentAirdropBots) / 100;

            // Calculate initial price from liquidity
            const initialPrice = liquidityAmountStable / tokenAmountForLiquidity;

            // Add new token to baseAssetPrices (for getPrice function)
            baseAssetPrices[ticker] = initialPrice;

            // Create the new liquidity pool
            const newPool = createLiquidityPool(
                ticker,
                liquidityPair,
                tokenAmountForLiquidity,
                liquidityAmountStable,
                0, // No initial bribe from protocol
                'VOLATILE'
            );

            // Distribute allocated tokens
            feesWallet[ticker] = (feesWallet[ticker] || 0) + tokenAmountForPlatformWallet;
            userWallet[ticker] = (userWallet[ticker] || 0) + tokenAmountForAirdropUser;
            bots.forEach(bot => {
                bot.wallet[ticker] = (bot.wallet[ticker] || 0) + (tokenAmountForAirdropBots / bots.length); // Distribute evenly among bots
            });

            addTransaction('User Token Launch', `User launched new token ${ticker} with total supply ${formatLargeNumber(totalSupply)}.`);
            showToast(`Successfully launched new token ${ticker}!`, 'success');
            document.getElementById('modalContainer').innerHTML = ''; // Close modal
            updateUI();
        }

        function renderLeaderboard() {
            return `
                <h1 class="text-3xl font-bold text-cyan-400 mb-6">Leaderboard</h1>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                    <div class="card">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Top Burners ($PDEX)</h2>
                        <div class="overflow-x-auto">
                            <table class="min-w-full divide-y divide-gray-700">
                                <thead class="bg-gray-700">
                                    <tr>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Rank</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Participant</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Burned PDEX</th>
                                    </tr>
                                </thead>
                                <tbody id="topBurnersTableBody" class="divide-y divide-gray-800">
                                    <!-- Top burners will be rendered here -->
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="card">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Top vePDEX Holders</h2>
                        <div class="overflow-x-auto">
                            <table class="min-w-full divide-y divide-gray-700">
                                <thead class="bg-gray-700">
                                    <tr>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Rank</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Participant</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">vePDEX</th>
                                    </tr>
                                </thead>
                                <tbody id="topVePDEXHoldersTableBody" class="divide-y divide-gray-800">
                                    <!-- Top vePDEX holders will be rendered here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="card">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Top Earners (USD)</h2>
                        <div class="overflow-x-auto">
                            <table class="min-w-full divide-y divide-gray-700">
                                <thead class="bg-gray-700">
                                    <tr>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Rank</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Participant</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Total Earned</th>
                                    </tr>
                                </thead>
                                <tbody id="topEarnersTableBody" class="divide-y divide-gray-800">
                                    <!-- Top earners will be rendered here -->
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="card">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Most Voted Pools</h2>
                        <div class="overflow-x-auto">
                            <table class="min-w-full divide-y divide-gray-700">
                                <thead class="bg-gray-700">
                                    <tr>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Rank</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Pool</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Total Votes</th>
                                    </tr>
                                </thead>
                                <tbody id="mostVotedPoolsTableBody" class="divide-y divide-gray-800">
                                    <!-- Most voted pools will be rendered here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
        }

        function updateLeaderboard() {
            // Top Burners
            const allBurners = [{ id: 'User', amount: userVePDEXLocks.reduce((sum, lock) => sum + lock.pdexLocked, 0) }];
            bots.forEach(bot => {
                allBurners.push({ id: bot.id, amount: bot.vePDEXLocks.reduce((sum, lock) => sum + lock.pdexLocked, 0) });
            });
            leaderboardData.topBurners = allBurners.sort((a, b) => b.amount - a.amount).slice(0, 10);

            // Top vePDEX Holders
            const allVeHolders = [{ id: 'User', amount: userVePDEXLocks.reduce((sum, lock) => sum + lock.vePDEXAmount, 0) }];
            bots.forEach(bot => {
                allVeHolders.push({ id: bot.id, amount: bot.vePDEXLocks.reduce((sum, lock) => sum + lock.vePDEXAmount, 0) });
            });
            leaderboardData.topVePDEXHolders = allVeHolders.sort((a, b) => b.amount - a.amount).slice(0, 10);

            // Top Earners (simplified: sum of all tokens in USD)
            const allEarners = [{ id: 'User', amount: Object.keys(userWallet).reduce((sum, token) => sum + (userWallet[token] * getPrice(token)), 0) }];
            bots.forEach(bot => {
                allEarners.push({ id: bot.id, amount: Object.keys(bot.wallet).reduce((sum, token) => sum + (bot.wallet[token] * getPrice(token)), 0) });
            });
            leaderboardData.topEarners = allEarners.sort((a, b) => b.amount - a.amount).slice(0, 10);

            // Most Voted Pools
            leaderboardData.mostVotedPools = [...liquidityPools].sort((a, b) => b.votes - a.votes).slice(0, 10);

            // Render tables if on leaderboard page
            if (currentActivePage === 'leaderboard') {
                document.getElementById('topBurnersTableBody').innerHTML = leaderboardData.topBurners.map((entry, index) => `
                    <tr class="hover:bg-gray-800">
                        <td class="px-4 py-2 whitespace-nowrap">${index + 1}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${entry.id}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${formatLargeNumber(entry.amount)}</td>
                    </tr>
                `).join('');

                document.getElementById('topVePDEXHoldersTableBody').innerHTML = leaderboardData.topVePDEXHolders.map((entry, index) => `
                    <tr class="hover:bg-gray-800">
                        <td class="px-4 py-2 whitespace-nowrap">${index + 1}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${entry.id}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${formatLargeNumber(entry.amount)}</td>
                    </tr>
                `).join('');

                document.getElementById('topEarnersTableBody').innerHTML = leaderboardData.topEarners.map((entry, index) => `
                    <tr class="hover:bg-gray-800">
                        <td class="px-4 py-2 whitespace-nowrap">${index + 1}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${entry.id}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${formatCurrency(entry.amount)}</td>
                    </tr>
                `).join('');

                document.getElementById('mostVotedPoolsTableBody').innerHTML = leaderboardData.mostVotedPools.map((entry, index) => `
                    <tr class="hover:bg-gray-800">
                        <td class="px-4 py-2 whitespace-nowrap">${index + 1}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${entry.tokenA}/${entry.tokenB}</td>
                        <td class="px-4 py-2 whitespace-nowrap">${formatLargeNumber(entry.votes)}</td>
                    </tr>
                `).join('');
            }
        }


        // --- Admin Actions ---
        function handleManualEndEpoch() {
            showConfirmationModal(
                'Confirm End Epoch',
                'Are you sure you want to manually end the current epoch?',
                () => {
                    endEpoch();
                    showToast('Epoch manually ended!', 'info');
                }
            );
        }

        function handleRefillVoterIncentives() {
            const refillAmount = 100_000_000; // Example refill amount
            if (userWallet.PDEX < refillAmount) {
                showToast(`Insufficient PDEX in your wallet to refill. Need ${formatLargeNumber(refillAmount)} PDEX.`, 'error');
                return;
            }
            showConfirmationModal(
                'Confirm Refill',
                `Are you sure you want to refill the Voter Incentives Pool with ${formatLargeNumber(refillAmount)} PDEX from your wallet?`,
                () => {
                    userWallet.PDEX -= refillAmount;
                    voterIncentivesPool += refillAmount;
                    showToast('Voter Incentives Pool refilled!', 'success');
                    updateUI();
                }
            );
        }

        function handleResetSimulation() {
            showConfirmationModal(
                'Confirm Reset',
                'Are you sure you want to reset the entire simulation? All progress will be lost.',
                () => {
                    clearInterval(simulationInterval);
                    initializeSimulation();
                    showToast('Simulation reset!', 'info');
                    startSimulation();
                    showPage('dashboard');
                }
            );
        }

        // --- Sidebar Toggle for Mobile ---
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const contentArea = document.getElementById('contentArea');
            if (window.innerWidth <= 768) {
                sidebarExpanded = !sidebarExpanded;
                if (sidebarExpanded) {
                    sidebar.classList.add('sidebar-expanded');
                } else {
                    sidebar.classList.remove('sidebar-expanded');
                }
            } else {
                // On desktop, toggle margin for content area
                sidebarExpanded = !sidebarExpanded;
                if (sidebarExpanded) {
                    sidebar.classList.remove('sidebar-collapsed');
                    contentArea.classList.remove('content-area-expanded');
                } else {
                    sidebar.classList.add('sidebar-collapsed');
                    contentArea.classList.add('content-area-expanded');
                }
            }
        }

        // --- Initial App Setup ---
        function startSimulation() {
            initializeSimulation();
            simulationInterval = setInterval(advanceTime, 1000 / simulationSpeedMultiplier); // 1 simulated minute per real second by default
            showPage('dashboard');

            // Attach hamburger menu listener
            document.getElementById('hamburgerMenu').onclick = toggleSidebar;
        }

        // Start the simulation when the window loads
        window.onload = startSimulation;

        // Recharts component for PDEX Price Chart
        // This is a simplified React component integration within plain HTML
        // In a full React app, this would be handled differently.
        const { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } = Recharts;
        const { useState, useEffect } = React;

        let pdexPriceHistory = [{ name: 0, price: 0.01 }]; // Initial data point

        function PDEXPriceChart() {
            const [data, setData] = useState(pdexPriceHistory);

            useEffect(() => {
                const interval = setInterval(() => {
                    // Add new data point every simulated hour
                    if (simulationTime % 60 === 0 && simulationTime !== 0) {
                        const newPoint = { name: simulationTime, price: pdexPrice };
                        pdexPriceHistory.push(newPoint);
                        // Keep history manageable (e.g., last 24 hours of simulated data)
                        if (pdexPriceHistory.length > (24 * 60 / 60) + 1) { // 24 hours + 1 for initial
                            pdexPriceHistory.shift();
                        }
                        setData([...pdexPriceHistory]);
                    }
                }, 1000 * 60 / simulationSpeedMultiplier); // Update every real minute (simulated hour)

                return () => clearInterval(interval);
            }, []);

            return React.createElement(ResponsiveContainer, { width: "100%", height: "100%" },
                React.createElement(LineChart, {
                    data: data,
                    margin: { top: 5, right: 20, left: 10, bottom: 5 }
                },
                    React.createElement(XAxis, { dataKey: "name", stroke: "#6B7280", label: { value: "Simulated Time (min)", position: "insideBottom", offset: -5, fill: "#9CA3AF" } }),
                    React.createElement(YAxis, { stroke: "#6B7280", label: { value: "PDEX Price (USD)", angle: -90, position: "insideLeft", fill: "#9CA3AF" } }),
                    React.createElement(CartesianGrid, { stroke: "#374151", strokeDasharray: "3 3" }),
                    React.createElement(Tooltip, {
                        contentStyle: { backgroundColor: '#1F2937', border: '1px solid #4B5563', borderRadius: '8px' },
                        labelStyle: { color: '#9CA3AF' },
                        itemStyle: { color: '#E5E7EB' },
                        formatter: (value) => formatCurrency(value)
                    }),
                    React.createElement(Line, {
                        type: "monotone",
                        dataKey: "price",
                        stroke: "#06B6D4",
                        strokeWidth: 2,
                        dot: false,
                        animationDuration: 500 // Smooth transition
                    })
                )
            );
        }

        // Function to render the React chart
        function renderPDEXChart() {
            const container = document.getElementById('pdexPriceChartContainer');
            if (container) {
                ReactDOM.render(React.createElement(PDEXPriceChart), container);
            }
        }

        // Call this when dashboard is rendered
        document.addEventListener('DOMContentLoaded', () => {
            // Initial render of the dashboard.
            showPage('dashboard');
            // Render the chart after the dashboard content is in the DOM
            renderPDEXChart();
        });

    </script>
</body>
</html>
