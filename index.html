<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WL LAUNCHER</title>
  <!-- Tailwind CSS CDN for utility-first styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Ethers.js for blockchain interaction simulation (removed xintegrity as it can cause issues) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Chart.js for data visualization -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Google Fonts for Poppins (general text) and Inter (headings, charts) -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    /* Base body styles for font, background, and text color */
    body {
      font-family: 'Poppins', sans-serif;
      background: #0a0a0a; /* Dark background */
      color: #fff; /* White text */
      margin: 0;
      padding: 0;
      overflow-x: hidden; /* Prevent horizontal scrolling */
    }

    /* Glowing box effect for sections and modals */
    .glowing-box {
      border: 2px solid #00ffaa; /* Neon green border */
      box-shadow: 0 0 10px rgba(0, 255, 170, 0.5); /* Initial glow */
      transition: box-shadow 0.3s ease; /* Smooth transition for hover effect */
    }
    .glowing-box:hover {
      box-shadow: 0 0 20px rgba(0, 255, 170, 0.8); /* Enhanced glow on hover */
    }

    /* Neon button styling */
    .neon-btn {
      background: linear-gradient(45deg, #00ffaa, #4b6cb7); /* Gradient background */
      border: none;
      font-weight: 600;
      transition: transform 0.2s, box-shadow 0.2s; /* Smooth transitions for hover effects */
    }
    .neon-btn:hover {
      transform: scale(1.05); /* Slightly enlarge on hover */
      box-shadow: 0 0 15px rgba(0, 255, 170, 0.7); /* Glow on hover */
    }

    /* Modal overlay styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow-y: auto; /* Enable vertical scrolling for modal content */
      background: rgba(0, 0, 0, 0.9); /* Semi-transparent dark overlay */
      z-index: 1000; /* Ensure modal is on top */
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem;
      box-sizing: border-box;
    }
    .modal.hidden {
      display: none; /* Hide modal when 'hidden' class is present */
    }
    .modal > div {
      max-width: 600px; /* Max width for modal content */
      width: 100%;
      background: #1a1a1a; /* Dark background for modal content */
      border: 2px solid #00ffaa; /* Neon green border */
      border-radius: 8px;
      padding: 1.5rem;
      box-shadow: 0 0 20px rgba(0, 255, 170, 0.5); /* Glow effect */
    }

    /* Body scroll lock when modal is open */
    body.modal-open {
      overflow: hidden; /* Prevent scrolling on the main body */
    }

    /* Input and select field styling */
    input, select {
      background: #2a2a2a; /* Darker background for inputs */
      border: 1px solid #00ffaa; /* Neon green border */
      color: #fff;
      padding: 0.5rem;
      border-radius: 4px;
      width: 100%;
      box-sizing: border-box;
    }

    /* Chart container specific styles */
    .chart-container {
      max-height: 300px; /* Max height for chart containers */
      overflow-y: auto; /* Enable scrolling if chart content overflows */
      margin-bottom: 1rem;
    }

    /* Notification area styling */
    #notifications {
      position: fixed;
      top: 1rem;
      right: 1rem;
      max-height: 50vh;
      overflow-y: auto;
      z-index: 1100; /* Ensure notifications are above modals */
    }
    .notification {
      background: #1a1a1a;
      border: 1px solid #00ffaa;
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      border-radius: 4px;
      animation: slideIn 0.3s ease; /* Slide-in animation for new notifications */
    }
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    /* Heading font styles */
    h1, h2, h3 {
      font-family: 'Inter', sans-serif;
      font-weight: 700;
    }

    /* Custom scrollbar for modal content */
    .modal-content {
      max-height: 100vh; /* Ensure content doesn't overflow viewport */
      overflow-y: auto; /* Enable scrolling */
      scrollbar-width: thin; /* Firefox */
      scrollbar-color: #00ffaa #1a1a1a; /* Firefox */
    }
    /* Webkit (Chrome, Safari) scrollbar styling */
    .modal-content::-webkit-scrollbar {
      width: 8px;
    }
    .modal-content::-webkit-scrollbar-thumb {
      background-color: #00ffaa;
      border-radius: 4px;
    }
    .modal-content::-webkit-scrollbar-track {
      background-color: #1a1a1a;
    }
  </style>
</head>
<body>
  <!-- Audio element for click sound effect -->
  <audio id="clickSound" src="https://freesound.org/data/previews/171/171671_2437358-lq.mp3"></audio>

  <!-- Notifications container -->
  <div id="notifications"></div>

  <!-- Header section with title and main action buttons -->
  <header class="glowing-box p-4 text-center">
    <h1 class="text-3xl font-bold">WL LAUNCHER</h1>
    <button id="connectBtn" class="neon-btn text-white px-4 py-2 rounded mt-2">Connect Wallet</button>
    <button id="portfolioBtn" class="neon-btn text-white px-4 py-2 rounded mt-2">Portfolio</button>
    <button id="menuBtn" class="neon-btn text-white px-4 py-2 rounded mt-2">Menu</button>
  </header>

  <!-- Main content area with token sections -->
  <main class="p-4 space-y-6">
    <!-- Whitelist Tokens Section -->
    <section id="whitelistSection" class="glowing-box p-6 rounded-lg">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-2xl font-bold">Whitelist Tokens</h2>
        <button id="toggleWhitelist" class="neon-btn text-white px-2 py-1 rounded text-sm">Collapse</button>
      </div>
      <div id="whitelistTokens" class="space-y-4"></div>
    </section>
    <!-- Trading Tokens Section -->
    <section id="tradingSection" class="glowing-box p-6 rounded-lg">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-2xl font-bold">Trading Tokens</h2>
        <button id="toggleTrading" class="neon-btn text-white px-2 py-1 rounded text-sm">Collapse</button>
      </div>
      <div id="tradingTokens" class="space-y-4"></div>
    </section>
    <!-- Trending Tokens Section -->
    <section id="trendingSection" class="glowing-box p-6 rounded-lg">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-2xl font-bold">Trending Tokens</h2>
        <button id="toggleTrending" class="neon-btn text-white px-2 py-1 rounded text-sm">Collapse</button>
      </div>
      <div id="trendingTokens" class="space-y-4"></div>
    </section>
  </main>

  <!-- Menu Modal -->
  <div id="menuModal" class="modal hidden">
    <div class="modal-content">
      <h2 class="text-2xl font-bold mb-4">Menu</h2>
      <button id="launchTokenBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Launch Token</button>
      <button id="swapBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Swap</button>
      <button id="autoTradeBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Automated Trading</button>
      <button id="claimBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Claim Tokens</button>
      <button id="votingBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Voting</button>
      <button id="questsBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Quests</button>
      <button id="treasuryBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Treasury</button>
      <button id="closeMenu" class="w-full neon-btn text-white px-4 py-2 rounded">Close</button>
    </div>
  </div>

  <!-- Portfolio Page Modal -->
  <div id="portfolioPage" class="modal hidden">
    <div class="modal-content">
      <h2 class="text-2xl font-bold mb-4">Portfolio</h2>
      <div class="chart-container">
        <canvas></canvas>
      </div>
      <div class="chart-container">
        <canvas></canvas>
      </div>
      <p><strong>Total Value:</strong> $<span id="portfolioValue">0.00</span></p>
      <p><strong>PnL:</strong> $<span id="portfolioPnL">0.00</span></p>
      <div id="portfolioHoldings"></div>
      <button id="closePortfolio" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Close</button>
    </div>
  </div>

  <!-- Launch Token Modal -->
  <div id="launchPage" class="modal hidden">
    <div class="modal-content">
      <h2 class="text-2xl font-bold mb-4">Launch New Token</h2>
      <form id="launchForm">
        <input id="tokenName" type="text" placeholder="Token Name" required class="mb-2">
        <input id="tokenTicker" type="text" placeholder="Token Ticker" required class="mb-2">
        <input id="tokenSupply" type="number" placeholder="Total Supply" required class="mb-2">
        <input id="tokenImage" type="url" placeholder="Image URL" class="mb-2">
        <input id="twitterLink" type="url" placeholder="Twitter Link" class="mb-2">
        <input id="discordLink" type="url" placeholder="Discord Link" class="mb-2">
        <input id="whitelistDuration" type="number" placeholder="Whitelist Duration" required class="mb-2">
        <select id="durationUnit" class="mb-2">
          <option value="seconds">Seconds</option>
          <option value="minutes">Minutes</option>
          <option value="hours">Hours</option>
          <option value="days">Days</option>
        </select>
        <input id="minContribution" type="number" placeholder="Min Contribution (AVAX)" required class="mb-2">
        <input id="maxContribution" type="number" placeholder="Max Contribution (AVAX)" required class="mb-2">
        <input id="airdropPercentage" type="number" placeholder="Airdrop Percentage" required class="mb-2">
        <input id="vestingDuration" type="number" placeholder="Vesting Duration" required class="mb-2">
        <select id="vestingUnit" class="mb-2">
          <option value="seconds">Seconds</option>
          <option value="minutes">Minutes</option>
          <option value="hours">Hours</option>
          <option value="days">Days</option>
          <option value="months">Months</option>
        </select>
        <input id="creatorFeeInput" type="number" placeholder="Creator Fee (%)" min="0" max="5" required class="mb-2">
        <input id="preBuyPercentage" type="number" placeholder="Pre-Buy Percentage (0-50)" min="0" max="50" class="mb-2">
        <input id="preBuyAvax" type="number" placeholder="Pre-Buy AVAX Amount" class="mb-2">
        <button type="submit" class="w-full neon-btn text-white px-4 py-2 rounded">Launch</button>
      </form>
      <button id="backLaunch" class="w-full neon-btn text-white px-4 py-2 rounded mt-2">Back</button>
    </div>
  </div>

  <!-- Automated Trading Modal -->
  <div id="autoTradeModal" class="modal hidden">
    <div class="modal-content">
      <h2 class="text-2xl font-bold mb-4">Automated Trading</h2>
      <h3 class="text-lg font-semibold mb-2">Auto Buy</h3>
      <select id="autoBuyToken" class="mb-2"></select>
      <input id="autoBuyAmount" type="number" placeholder="AVAX Amount" class="mb-2">
      <input id="autoBuyInterval" type="number" placeholder="Interval" class="mb-2">
      <select id="autoBuyUnit" class="mb-2">
        <option value="seconds">Seconds</option>
        <option value="minutes">Minutes</option>
      </select>
      <button id="startAutoBuy" class="w-full neon-btn text-white px-4 py-2 rounded mb-4">Start Auto Buy</button>
      <h3 class="text-lg font-semibold mb-2">Auto Sell</h3>
      <select id="autoSellToken" class="mb-2"></select>
      <input id="autoSellAmount" type="number" placeholder="Token Amount" class="mb-2">
      <input id="autoSellInterval" type="number" placeholder="Interval" class="mb-2">
      <select id="autoSellUnit" class="mb-2">
        <option value="seconds">Seconds</option>
        <option value="minutes">Minutes</option>
      </select>
      <button id="startAutoSell" class="w-full neon-btn text-white px-4 py-2 rounded mb-4">Start Auto Sell</button>
      <h3 class="text-lg font-semibold mb-2">Active Auto Trades</h3>
      <div id="activeAutoTrades" class="space-y-2"></div>
      <button id="closeAutoTrade" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Close</button>
      <button id="backAutoTrade" class="w-full neon-btn text-white px-4 py-2 rounded mt-2">Back</button>
    </div>
  </div>

  <!-- Claim Tokens Modal -->
  <div id="claimModal" class="modal hidden">
    <div class="modal-content">
      <h2 class="text-2xl font-bold mb-4">Claim Tokens</h2>
      <select id="claimToken" class="mb-2"></select>
      <p><strong>Total Airdrop:</strong> <span id="airdropTotal">0</span></p>
      <p><strong>Claimable:</strong> <span id="airdropClaimable">0</span></p>
      <p><strong>Vesting Progress:</strong> <span id="vestingProgress">0</span>%</p>
      <button id="claimAirdropBtn" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Claim</button>
      <button id="closeClaim" class="w-full neon-btn text-white px-4 py-2 rounded mt-2">Close</button>
    </div>
  </div>

  <!-- Voting Modal -->
  <div id="votingModal" class="modal hidden">
    <div class="modal-content">
      <h2 class="text-2xl font-bold mb-4">Voting</h2>
      <select id="voteToken" class="mb-2"></select>
      <input id="proposalText" type="text" placeholder="Proposal Text" class="mb-2">
      <input id="proposalOptions" type="text" placeholder="Options (comma-separated)" class="mb-2">
      <input id="proposalReward" type="number" placeholder="Reward (AVAX)" class="mb-2">
      <button id="createProposalBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-4">Create Proposal</button>
      <h3 class="text-lg font-semibold mb-2">Active Proposals</h3>
      <div id="activeProposals" class="space-y-2"></div>
      <button id="closeVoting" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Close</button>
    </div>
  </div>

  <!-- Quests Modal -->
  <div id="questsModal" class="modal hidden">
    <div class="modal-content">
      <h2 class="text-2xl font-bold mb-4">Quests</h2>
      <select id="questToken" class="mb-2"></select>
      <input id="questDescription" type="text" placeholder="Quest Description" class="mb-2">
      <input id="questReward" type="number" placeholder="Reward (Tokens)" class="mb-2">
      <button id="createQuestBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-4">Create Quest</button>
      <h3 class="text-lg font-semibold mb-2">Active Quests</h3>
      <div id="activeQuests" class="space-y-2"></div>
      <button id="closeQuests" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Close</button>
    </div>
  </div>

  <!-- Treasury Modal -->
  <div id="treasuryModal" class="modal hidden">
    <div class="modal-content">
      <h2 class="text-2xl font-bold mb-4">Platform Treasury</h2>
      <p><strong>Balance:</strong> <span id="treasuryBalance">0</span> AVAX</p>
      <button id="closeTreasury" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Close</button>
    </div>
  </div>

  <!-- Swap Page Modal -->
  <div id="swapPage" class="modal hidden">
    <div class="modal-content">
      <h2 class="text-2xl font-bold mb-4">Swap</h2>
      <select id="swapToken" class="mb-2"></select>
      <input id="tradeAvaxAmount" type="number" placeholder="AVAX Amount" class="mb-2">
      <input id="tradeTokenAmount" type="number" placeholder="Token Amount" class="mb-2">
      <select id="slippageSelect" class="mb-2">
        <option value="0.5">0.5%</option>
        <option value="1">1%</option>
        <option value="3">3%</option>
      </select>
      <button id="tradeBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Swap</button>
      <button id="backSwap" class="w-full neon-btn text-white px-4 py-2 rounded">Back</button>
    </div>
  </div>

  <!-- Trade Confirmation Modal -->
  <div id="tradeConfirmModal" class="modal hidden">
    <div class="modal-content">
      <h2 class="text-2xl font-bold mb-4">Confirm Swap</h2>
      <p><strong>AVAX Amount:</strong> <span id="confirmAvaxAmount">0</span></p>
      <p><strong>Token Amount:</strong> <span id="confirmTokenAmount">0</span> <span id="confirmTokenTicker"></span></p>
      <p><strong>Slippage:</strong> <span id="confirmSlippage">0</span>%</p>
      <p><strong>Gas Fee:</strong> <span id="confirmGasFee">0</span> AVAX</p>
      <p><strong>Platform Fee:</strong> <span id="confirmPlatformFee">0</span> AVAX</p>
      <button id="confirmTradeBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Confirm</button>
      <button id="cancelTradeBtn" class="w-full neon-btn text-white px-4 py-2 rounded">Cancel</button>
    </div>
  </div>

  <!-- Boost Modal -->
  <div id="boostModal" class="modal hidden">
    <div class="modal-content">
      <h2 class="text-2xl font-bold mb-4">Boost <span id="boostToken"></span></h2>
      <p>Balance: <span id="boostTokenBalance">0</span> <span id="boostTokenTicker"></span></p>
      <input id="boostAmount" type="number" placeholder="Amount to Boost" class="mb-2">
      <button id="confirmBoostBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Boost</button>
      <button id="cancelBoostBtn" class="w-full neon-btn text-white px-4 py-2 rounded">Cancel</button>
    </div>
  </div>

  <!-- Token Details Page Modal -->
  <div id="tokenDetailsPage" class="modal hidden">
    <div class="modal-content">
      <h2 class="text-2xl font-bold mb-4">Token Details</h2>
      <img id="tokenImg" class="w-16 h-16 rounded-full mb-2">
      <table class="w-full mb-4">
        <tr><td><strong>Name:</strong></td><td id="displayTokenName"></td></tr>
        <tr><td><strong>Ticker:</strong></td><td id="displayTokenTicker"></td></tr>
        <tr><td><strong>Supply:</strong></td><td id="displayTokenSupply"></td></tr>
        <tr><td><strong>Market Cap:</strong></td><td id="marketCap"></td></tr>
        <tr><td><strong>Price:</strong></td><td id="tokenPrice"></td></tr>
        <tr><td><strong>FDV:</strong></td><td id="fdv"></td></tr>
        <tr><td><strong>Locked Liquidity:</strong></td><td id="lockedLiquidity"></td></tr>
        <tr><td><strong>Creator Fee:</strong></td><td id="creatorFee"></td></tr>
        <tr><td><strong>Stage:</strong></td><td id="currentStage"></td></tr>
        <tr><td><strong>Creator:</strong></td><td id="displayCreatorWallet"></td></tr>
        <tr><td><strong>Twitter:</strong></td><td><a id="twitterLinkDisplay" href="#"></a></td></tr>
        <tr><td><strong>Discord:</strong></td><td><a id="discordLinkDisplay" href="#"></a></td></tr>
        <tr><td><strong>Boost:</strong></td><td id="boostStatus"></td></tr>
        <tr><td><strong>Tokenomics:</strong></td><td id="tokenomics"></td></tr>
      </table>
      <div id="snipeSection" class="mb-4">
        <h3 class="text-lg font-semibold mb-2">Contribute to Whitelist</h3>
        <input id="snipeAmount" type="number" placeholder="AVAX Amount" class="mb-2">
        <button id="snipeBtn" class="w-full neon-btn text-white px-4 py-2 rounded">Contribute</button>
        <p><strong>Total Contributed:</strong> <span id="totalContributed">0</span> AVAX (~$<span id="totalContributedValue">0</span>)</p>
        <p><strong>Time Left:</strong> <span id="whitelistTimer">0</span></p>
        <div class="chart-container">
          <canvas id="contributionChart"></canvas>
        </div>
      </div>
      <div id="contributionSection" class="mb-4">
        <h3 class="text-lg font-semibold mb-2">Contribution Details</h3>
        <p><strong>Your Contribution:</strong> <span id="yourContribution">0</span> AVAX</p>
      </div>
      <div id="tradingInterface" class="mb-4 hidden">
        <h3 class="text-lg font-semibold mb-2">Trading</h3>
        <p><strong>Price:</strong> $<span id="chartPrice">0</span></p>
        <p><strong>Market Cap:</strong> $<span id="chartMarketCap">0</span></p>
        <p><strong>FDV:</strong> $<span id="chartFdv">0</span></p>
        <p><strong>Locked Liquidity:</strong> $<span id="chartLockedLiquidity">0</span></p>
        <div class="chart-container">
          <canvas id="priceChart"></canvas>
        </div>
      </div>
      <div id="burnSection" class="mb-4 hidden">
        <h3 class="text-lg font-semibold mb-2">Burn Tokens</h3>
        <p><strong>Ticker:</strong> <span id="burnTicker"></span></p>
        <input id="burnAmount" type="number" placeholder="Amount to Burn" class="mb-2">
        <button id="burnBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Burn</button>
        <p><strong>Total Burned:</strong> <span id="totalBurned">0</span></p>
        <p><strong>Supply Remaining:</strong> <span id="supplyRemaining">100</span>%</p>
        <div class="chart-container">
          <canvas id="burnChart"></canvas>
        </div>
      </div>
      <div id="liquiditySection" class="mb-4">
        <h3 class="text-lg font-semibold mb-2">Liquidity Pool</h3>
        <select id="liquidityToken" class="mb-2"></select>
        <input id="avaxAmount" type="number" placeholder="AVAX Amount" class="mb-2">
        <input id="tokenAmount" type="number" placeholder="Token Amount" class="mb-2">
        <button id="addLiquidityBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Add Liquidity</button>
        <button id="removeLiquidityBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Remove Liquidity</button>
        <p><strong>TVL:</strong> $<span id="poolTVL">0</span></p>
        <p><strong>Your Share:</strong> <span id="poolShare">0</span>%</p>
        <p><strong>Fees Earned:</strong> <span id="feesEarned">0</span> AVAX</p>
        <p><strong>APR:</strong> <span id="poolAPR">0</span>%</p>
        <p><strong>Impermanent Loss:</strong> <span id="impermanentLoss">0</span>%</p>
      </div>
      <div id="stakingSection" class="mb-4">
        <h3 class="text-lg font-semibold mb-2">Staking</h3>
        <select id="stakeToken" class="mb-2"></select>
        <select id="stakePool" class="mb-2"></select>
        <input id="stakeAmount" type="number" placeholder="Amount to Stake" class="mb-2">
        <button id="stakeBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Stake</button>
        <button id="unstakeBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Unstake</button>
        <button id="claimStakeRewardsBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Claim Rewards</button>
        <p><strong>Staked Amount:</strong> <span id="stakedAmount">0</span></p>
        <p><strong>Reward Pool:</strong> <span id="rewardPool">0</span></p>
        <p><strong>APR:</strong> <span id="stakeAPR">0</span>%</p>
      </div>
      <div id="priceAlertSection" class="mb-4">
        <h3 class="text-lg font-semibold mb-2">Price Alerts</h3>
        <input id="alertPrice" type="number" placeholder="Target Price (USD)" class="mb-2">
        <select id="alertType" class="mb-2">
          <option value="above">Above</option>
          <option value="below">Below</option>
        </select>
        <button id="setAlertBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Set Alert</button>
        <div id="activeAlerts" class="space-y-2"></div>
      </div>
      <div id="limitOrderSection" class="mb-4">
        <h3 class="text-lg font-semibold mb-2">Limit Order</h3>
        <select id="orderToken" class="mb-2"></select>
        <input id="orderPrice" type="number" placeholder="Target Price (USD)" class="mb-2">
        <input id="orderAmount" type="number" placeholder="Token Amount" class="mb-2">
        <select id="orderType" class="mb-2">
          <option value="buy">Buy</option>
          <option value="sell">Sell</option>
        </select>
        <button id="placeOrderBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Place Order</button>
        <div id="activeOrders" class="space-y-2"></div>
      </div>
      <button id="viewTransactionsBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">View Transactions</button>
      <button id="viewChatBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Community Chat</button>
      <button id="boostBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Boost Token</button>
      <button id="shareTokenBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Share Token</button>
      <button id="backTokenDetails" class="w-full neon-btn text-white px-4 py-2 rounded">Back</button>
    </div>
  </div>

  <!-- Transaction History Modal -->
  <div id="transactionPage" class="modal hidden">
    <div class="modal-content">
      <h2 class="text-2xl font-bold mb-4">Transaction History</h2>
      <div id="transactionHistory" class="space-y-2"></div>
      <button id="backTransactions" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Back</button>
    </div>
  </div>

  <!-- Community Chat Modal -->
  <div id="chatPage" class="modal hidden">
    <div class="modal-content">
      <h2 class="text-2xl font-bold mb-4">Community Chat</h2>
      <p><strong>Sentiment:</strong> <span id="chatSentiment">Neutral</span></p>
      <div id="chatMessages" class="space-y-2 mb-4"></div>
      <input id="chatInput" type="text" placeholder="Type a message..." class="mb-2">
      <button id="sendChat" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Send</button>
      <button id="backChat" class="w-full neon-btn text-white px-4 py-2 rounded">Back</button>
    </div>
  </div>

  <script>
    // Global state variables for the application
    let wallet = null; // Stores the simulated Ethereum wallet
    let avaxBalance = 100; // User's AVAX balance
    const AVAX_PRICE = 30; // Simulated price of AVAX in USD
    let tokenBalances = {}; // Object to store user's balances for each token
    let platformTreasury = 0; // Accumulated platform fees
    let tokens = []; // Array to store all launched tokens
    let liquidityPools = {}; // Object to manage liquidity pools
    let proposals = []; // Array to store active voting proposals
    let quests = []; // Array to store active quests
    let autoTrades = []; // Array to store active automated trading bots
    let priceAlerts = []; // Array to store active price alerts
    let limitOrders = []; // Array to store active limit orders
    let stakingPools = {}; // Object to manage staking pools
    let currentToken = null; // Currently selected token for detail view
    // Portfolio history for charting, initialized with a dummy entry
    let portfolioHistory = [{ timestamp: new Date().toLocaleString(), value: 0, costBasis: 0 }];
    let portfolioPieChart = null; // Chart.js instance for portfolio allocation
    let portfolioValueChart = null; // Chart.js instance for portfolio value history
    let contributionChart = null; // Chart.js instance for whitelist contributions
    let priceChart = null; // Chart.js instance for token price chart
    let burnChart = null; // Chart.js instance for token burn chart
    let chatMessages = {}; // Object to store chat messages for each token

    /**
     * Plays a click sound effect.
     */
    function playSound() {
      document.getElementById('clickSound').play();
    }

    /**
     * Displays a notification message to the user.
     * @param {string} message - The message to display.
     */
    function notify(message) {
      const notifications = document.getElementById('notifications');
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.textContent = message;
      notifications.appendChild(notification);
      // Remove notification after 5 seconds
      setTimeout(() => notification.remove(), 5000);
    }

    /**
     * Toggles the visibility of a modal and locks/unlocks body scrolling.
     * @param {string} modalId - The ID of the modal element.
     * @param {boolean} isOpen - True to open the modal, false to close.
     */
    function toggleModalScroll(modalId, isOpen) {
      document.body.classList.toggle('modal-open', isOpen);
      document.getElementById(modalId).classList.toggle('hidden', !isOpen);
    }

    /**
     * Initializes the application by connecting a wallet and starting simulations.
     */
    function initialize() {
      // Connects a new random wallet if not already connected
      if (!wallet) {
        wallet = { address: ethers.Wallet.createRandom().address };
        notify('Wallet connected: ' + wallet.address.slice(0, 6) + '...' + wallet.address.slice(-4));
      }
      simulateBotTokens(); // Creates initial simulated tokens
      setInterval(simulateBotActivity, 30000); // Runs bot activity every 30 seconds
      updateTokenLists(); // Updates the main token lists
      updatePortfolio(); // Updates the portfolio display
    }

    // Event listener for the "Connect Wallet" button
    document.getElementById('connectBtn').addEventListener('click', () => {
      wallet = { address: ethers.Wallet.createRandom().address }; // Re-generate wallet on connect
      avaxBalance = 100; // Reset AVAX balance
      tokenBalances = {}; // Clear token balances
      notify('Wallet connected: ' + wallet.address.slice(0, 6) + '...' + wallet.address.slice(-4));
      updateBalanceModal();
      updatePortfolio();
      playSound();
    });

    // Event listener for the "Portfolio" button
    document.getElementById('portfolioBtn').addEventListener('click', () => {
      toggleModalScroll('portfolioPage', true); // Open portfolio modal
      updatePortfolio(); // Update portfolio data
      playSound();
    });

    // Event listener for the "Close Portfolio" button
    document.getElementById('closePortfolio').addEventListener('click', () => {
      toggleModalScroll('portfolioPage', false); // Close portfolio modal
      playSound();
    });

    // Event listener for the "Menu" button
    document.getElementById('menuBtn').addEventListener('click', () => {
      toggleModalScroll('menuModal', true); // Open menu modal
      playSound();
    });

    // Event listener for the "Close Menu" button
    document.getElementById('closeMenu').addEventListener('click', () => {
      toggleModalScroll('menuModal', false); // Close menu modal
      playSound();
    });

    /**
     * Updates the portfolio display, including charts and holdings.
     */
    function updatePortfolio() {
      const labels = ['AVAX', ...Object.keys(tokenBalances)];
      const data = [avaxBalance * AVAX_PRICE, ...Object.keys(tokenBalances).map(ticker => {
        const token = tokens.find(t => t.ticker === ticker);
        return token ? tokenBalances[ticker] * token.price : 0;
      })];
      const totalValue = data.reduce((sum, val) => sum + val, 0).toFixed(2);
      // Calculate Profit and Loss (PnL) based on the last recorded cost basis
      const costBasis = portfolioHistory.length > 0 ? portfolioHistory[portfolioHistory.length - 1].costBasis : 0;
      const pnl = (totalValue - costBasis).toFixed(2);

      document.getElementById('portfolioValue').textContent = totalValue;
      document.getElementById('portfolioPnL').textContent = `${pnl >= 0 ? '+' : ''}${pnl}`;
      // Apply color based on PnL (green for positive, red for negative)
      document.getElementById('portfolioPnL').className = `text-sm ${pnl >= 0 ? 'text-green-400' : 'text-red-400'}`;
      // Add current portfolio snapshot to history
      portfolioHistory.push({ timestamp: new Date().toLocaleString(), value: parseFloat(totalValue), costBasis });

      // Destroy existing chart instances to prevent memory leaks and re-render correctly
      if (portfolioPieChart) portfolioPieChart.destroy();
      if (portfolioValueChart) portfolioValueChart.destroy();

      // Create or update the Pie Chart for portfolio allocation
      const pieCanvas = document.querySelector('#portfolioPage canvas:first-child');
      if (pieCanvas) {
        portfolioPieChart = new Chart(pieCanvas.getContext('2d'), {
          type: 'pie',
          data: {
            labels,
            datasets: [{
              label: 'Portfolio Allocation',
              data,
              backgroundColor: ['#00ffaa', '#ff4d4d', '#4b6cb7', '#facc15', '#a855f7'], // Custom colors
              borderColor: ['#00ffaa', '#ff4d4d', '#4b6cb7', '#facc15', '#a855f7'],
              borderWidth: 2,
              hoverOffset: 20
            }]
          },
          options: {
            plugins: {
              legend: { position: 'top', labels: { font: { family: 'Inter', size: 14, weight: 'bold' } } }
            }
          }
        });
      }

      // Create or update the Line Chart for portfolio value history
      const lineCanvas = document.querySelector('#portfolioPage canvas:last-child');
      if (lineCanvas) {
        portfolioValueChart = new Chart(lineCanvas.getContext('2d'), {
          type: 'line',
          data: {
            labels: portfolioHistory.map(h => h.timestamp), // Timestamps for X-axis
            datasets: [{
              label: 'Portfolio Value (USD)',
              data: portfolioHistory.map(h => h.value), // Values for Y-axis
              borderColor: '#00ffaa',
              backgroundColor: 'rgba(0, 255, 170, 0.2)',
              fill: true,
              tension: 0.4 // Smooth line
            }]
          },
          options: {
            scales: {
              y: { beginAtZero: false, title: { display: true, text: 'Value (USD)', font: { family: 'Inter', size: 14, weight: 'bold' } } }
            }
          }
        });
      }

      // Update the detailed holdings list
      const holdings = document.getElementById('portfolioHoldings');
      holdings.innerHTML = '<h3 class="text-lg font-semibold mb-2">Holdings</h3>';
      holdings.innerHTML += `<p class="glowing-box p-2 rounded"><strong>AVAX:</strong> ${avaxBalance} (~$${(avaxBalance * AVAX_PRICE).toFixed(2)})</p>`;
      for (const [ticker, balance] of Object.entries(tokenBalances)) {
        const token = tokens.find(t => t.ticker === ticker);
        const value = (balance * (token ? token.price : 0)).toFixed(2);
        holdings.innerHTML += `<p class="glowing-box p-2 rounded"><strong>${ticker}:</strong> ${balance} (~$${value})</p>`;
      }
    }

    /**
     * Triggers a portfolio update if the portfolio modal is currently open.
     * This is used to keep the portfolio view live-updating.
     */
    function updateBalanceModal() {
      const modal = document.getElementById('portfolioPage');
      if (!modal.classList.contains('hidden')) updatePortfolio();
    }

    // Event listener for "Launch Token" button
    document.getElementById('launchTokenBtn').addEventListener('click', () => {
      toggleModalScroll('menuModal', false); // Close menu
      toggleModalScroll('launchPage', true); // Open launch token modal
      playSound();
    });

    // Event listener for "Back" button in Launch Token modal
    document.getElementById('backLaunch').addEventListener('click', () => {
      toggleModalScroll('launchPage', false); // Close launch token modal
      toggleModalScroll('menuModal', true); // Re-open menu
      playSound();
    });

    // Event listener for "Swap" button
    document.getElementById('swapBtn').addEventListener('click', () => {
      toggleModalScroll('menuModal', false); // Close menu
      toggleModalScroll('swapPage', true); // Open swap modal
      updateSwapSection(); // Populate swap token dropdown
      playSound();
    });

    // Event listener for "Toggle Whitelist" button
    document.getElementById('toggleWhitelist').addEventListener('click', () => {
      const content = document.getElementById('whitelistTokens');
      content.classList.toggle('hidden'); // Toggle visibility of content
      // Update button text based on visibility
      document.getElementById('toggleWhitelist').textContent = content.classList.contains('hidden') ? 'Expand' : 'Collapse';
      playSound();
    });

    // Event listener for "Toggle Trading" button
    document.getElementById('toggleTrading').addEventListener('click', () => {
      const content = document.getElementById('tradingTokens');
      content.classList.toggle('hidden');
      document.getElementById('toggleTrading').textContent = content.classList.contains('hidden') ? 'Expand' : 'Collapse';
      playSound();
    });

    // Event listener for "Toggle Trending" button
    document.getElementById('toggleTrending').addEventListener('click', () => {
      const content = document.getElementById('trendingTokens');
      content.classList.toggle('hidden');
      document.getElementById('toggleTrending').textContent = content.classList.contains('hidden') ? 'Expand' : 'Collapse';
      playSound();
    });

    // Event listener for "Launch Token" form submission
    document.getElementById('launchForm').addEventListener('submit', (e) => {
      e.preventDefault(); // Prevent default form submission behavior
      if (!wallet) {
        notify('Please sign in.');
        return;
      }
      // Retrieve all form input values
      const name = document.getElementById('tokenName').value;
      const ticker = document.getElementById('tokenTicker').value.toUpperCase();
      const supply = parseFloat(document.getElementById('tokenSupply').value);
      const image = document.getElementById('tokenImage').value;
      const twitterLink = document.getElementById('twitterLink').value;
      const discordLink = document.getElementById('discordLink').value;
      const duration = parseFloat(document.getElementById('whitelistDuration').value);
      const unit = document.getElementById('durationUnit').value;
      const minContribution = parseFloat(document.getElementById('minContribution').value);
      const maxContribution = parseFloat(document.getElementById('maxContribution').value);
      const airdropPercentage = parseFloat(document.getElementById('airdropPercentage').value);
      const vestingDuration = parseFloat(document.getElementById('vestingDuration').value);
      const vestingUnit = document.getElementById('vestingUnit').value;
      const creatorFee = parseFloat(document.getElementById('creatorFeeInput').value);
      const preBuyPercentage = parseFloat(document.getElementById('preBuyPercentage').value) || 0;
      const preBuyAvax = parseFloat(document.getElementById('preBuyAvax').value) || 0;
      const platformFee = 0.02 * 0.05; // Simulated platform fee for transaction

      // Validate inputs
      if (tokens.some(t => t.ticker === ticker) || isNaN(supply) || supply <= 0 || isNaN(duration) || duration <= 0 ||
          isNaN(minContribution) || isNaN(maxContribution) || minContribution <= 0 || maxContribution < minContribution ||
          isNaN(airdropPercentage) || airdropPercentage < 0 || airdropPercentage > 100 ||
          isNaN(vestingDuration) || vestingDuration <= 0 || isNaN(creatorFee) || creatorFee < 0 || creatorFee > 5 ||
          isNaN(preBuyPercentage) || preBuyPercentage < 0 || preBuyPercentage > 50 ||
          isNaN(preBuyAvax) || preBuyAvax < 0 || preBuyAvax + platformFee + 0.02 > avaxBalance) {
        notify('Invalid token parameters or insufficient AVAX.');
        return;
      }

      // Calculate durations in milliseconds
      const durationMs = duration * (unit === 'days' ? 24 * 60 * 60 * 1000 : unit === 'hours' ? 60 * 60 * 1000 : unit === 'minutes' ? 60 * 1000 : 1000);
      const vestingMs = vestingDuration * (vestingUnit === 'days' ? 24 * 60 * 60 * 1000 : vestingUnit === 'hours' ? 60 * 60 * 1000 : vestingUnit === 'minutes' ? 60 * 1000 : 1000);
      const preBuyTokens = preBuyPercentage > 0 ? (supply * preBuyPercentage / 100) : 0;

      // Create new token object
      const token = {
        name,
        ticker,
        originalSupply: supply,
        supply,
        burned: 0,
        price: 0, // Initial price is 0 during whitelist
        marketCap: 0, // Initial market cap is 0 during whitelist
        image,
        twitterLink,
        discordLink,
        creatorWallet: wallet.address,
        creatorFee,
        stage: 'whitelist', // Start in whitelist stage
        whitelistEnd: Date.now() + durationMs, // Calculate whitelist end time
        contributors: preBuyAvax > 0 ? [{ wallet: wallet.address, amount: preBuyAvax }] : [], // Add pre-buyer as a contributor
        airdropPercentage,
        airdropPool: 0, // Will be calculated after whitelist ends
        vestingDuration: vestingMs,
        vestingStart: 0, // Will start after whitelist ends
        claimed: {}, // Tracks claimed airdrop amounts per user
        minContribution,
        maxContribution,
        boost: 0,
        transactions: preBuyAvax > 0 ? [{ type: 'Pre-Buy', amount: `${preBuyAvax} AVAX`, timestamp: new Date().toLocaleString() }] : [],
        priceHistory: [] // Stores historical price data for charting
      };
      tokens.push(token); // Add the new token to the global tokens array

      // Handle pre-buy logic
      if (preBuyAvax > 0) {
        avaxBalance = (parseFloat(avaxBalance) - (preBuyAvax + platformFee + 0.02)).toFixed(2); // Deduct AVAX and fees
        tokenBalances[ticker] = (parseFloat(tokenBalances[ticker] || 0) + preBuyTokens).toFixed(2); // Add pre-bought tokens
        platformTreasury += platformFee; // Add platform fee to treasury
        // Update portfolio cost basis for pre-buy
        portfolioHistory[portfolioHistory.length - 1].costBasis += preBuyAvax * AVAX_PRICE;
      }

      // Update UI and notify
      updateTokenLists();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      toggleModalScroll('launchPage', false); // Close launch modal
      notify(`Launched token ${ticker} with ${airdropPercentage}% airdrop.`);
      playSound();
    });

    /**
     * Updates the display of token lists (Whitelist, Trading, Trending).
     */
    function updateTokenLists() {
      const whitelistTokens = document.getElementById('whitelistTokens');
      const tradingTokens = document.getElementById('tradingTokens');
      const trendingTokens = document.getElementById('trendingTokens');
      whitelistTokens.innerHTML = ''; // Clear existing content
      tradingTokens.innerHTML = '';
      trendingTokens.innerHTML = '';

      // Populate Whitelist Tokens section
      tokens.filter(token => token.stage === 'whitelist').forEach(token => {
        const tokenHtml = `
          <div class="glowing-box p-4 rounded-lg flex items-center space-x-4">
            <img src="${token.image || 'https://placehold.co/64x64/00ffaa/ffffff?text=WL'}" class="w-12 h-12 rounded-full">
            <div>
              <p><strong>${token.name} (${token.ticker})</strong></p>
              <p>Min: ${token.minContribution} AVAX, Max: ${token.maxContribution} AVAX</p>
              <button class="viewTokenBtn neon-btn text-white px-4 py-2 rounded mt-2" data-ticker="${token.ticker}">View</button>
            </div>
          </div>`;
        whitelistTokens.innerHTML += tokenHtml;
      });

      // Populate Trading Tokens section
      tokens.filter(token => token.stage === 'trading').forEach(token => {
        const tokenHtml = `
          <div class="glowing-box p-4 rounded-lg flex items-center space-x-4">
            <img src="${token.image || 'https://placehold.co/64x64/ff4d4d/ffffff?text=TR'}" class="w-12 h-12 rounded-full">
            <div>
              <p><strong>${token.name} (${token.ticker})</strong></p>
              <p>Price: $${token.price.toFixed(4)}</p>
              <p>Market Cap: $${token.marketCap.toFixed(2)}</p>
              <button class="viewTokenBtn neon-btn text-white px-4 py-2 rounded mt-2" data-ticker="${token.ticker}">View</button>
            </div>
          </div>`;
        tradingTokens.innerHTML += tokenHtml;
      });

      // Populate Trending Tokens section (sorted by boost, top 5)
      tokens.sort((a, b) => (b.boost || 0) - (a.boost || 0)).slice(0, 5).forEach(token => {
        const tokenHtml = `
          <div class="glowing-box p-4 rounded-lg flex items-center space-x-4">
            <img src="${token.image || 'https://placehold.co/64x64/4b6cb7/ffffff?text=TD'}" class="w-12 h-12 rounded-full">
            <div>
              <p><strong>${token.name} (${token.ticker})</strong></p>
              <p>Boost: ${token.boost || 0} ${token.ticker}</p>
              <button class="viewTokenBtn neon-btn text-white px-4 py-2 rounded mt-2" data-ticker="${token.ticker}">View</button>
            </div>
          </div>`;
        trendingTokens.innerHTML += tokenHtml;
      });

      // Add event listeners to all "View" buttons
      document.querySelectorAll('.viewTokenBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          currentToken = tokens.find(t => t.ticker === btn.dataset.ticker);
          toggleModalScroll('tokenDetailsPage', true); // Open token details modal
          updateTokenDetails(); // Update details for the selected token
          playSound();
        });
      });
    }

    // Event listener for "Back" button in Token Details modal
    document.getElementById('backTokenDetails').addEventListener('click', () => {
      toggleModalScroll('tokenDetailsPage', false); // Close token details modal
      playSound();
    });

    // Event listener for "Automated Trading" button
    document.getElementById('autoTradeBtn').addEventListener('click', () => {
      toggleModalScroll('menuModal', false); // Close menu
      toggleModalScroll('autoTradeModal', true); // Open auto trade modal
      updateAutoTradeModal(); // Populate auto trade options
      playSound();
    });

    // Event listener for "Close" button in Automated Trading modal
    document.getElementById('closeAutoTrade').addEventListener('click', () => {
      toggleModalScroll('autoTradeModal', false); // Close auto trade modal
      playSound();
    });

    // Event listener for "Back" button in Automated Trading modal
    document.getElementById('backAutoTrade').addEventListener('click', () => {
      toggleModalScroll('autoTradeModal', false); // Close auto trade modal
      toggleModalScroll('menuModal', true); // Re-open menu
      playSound();
    });

    /**
     * Updates the automated trading modal with available tokens and active auto trades.
     */
    function updateAutoTradeModal() {
      const autoBuyTokenSelect = document.getElementById('autoBuyToken');
      const autoSellTokenSelect = document.getElementById('autoSellToken');
      autoBuyTokenSelect.innerHTML = '<option value="">Select Token</option>';
      autoSellTokenSelect.innerHTML = '<option value="">Select Token</option>';
      // Populate dropdowns with trading-stage tokens
      tokens.filter(t => t.stage === 'trading').forEach(token => {
        autoBuyTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker} (${tokenBalances[token.ticker] || 0})</option>`;
        autoSellTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker} (${tokenBalances[token.ticker] || 0})</option>`;
      });
      const activeAutoTrades = document.getElementById('activeAutoTrades');
      activeAutoTrades.innerHTML = ''; // Clear existing active trades
      // Display active auto trades
      autoTrades.forEach(trade => {
        activeAutoTrades.innerHTML += `
          <div class="glowing-box p-4 rounded-lg mb-2">
            <p><strong>${trade.type} ${trade.ticker}</strong></p>
            <p>Amount: ${trade.amount} ${trade.type === 'Buy' ? 'AVAX' : trade.ticker}</p>
            <p>Interval: ${trade.interval} ${trade.unit}</p>
            <button class="stopTradeBtn neon-btn text-white px-4 py-2 rounded mt-2" data-trade-id="${trade.id}">Stop</button>
          </div>`;
      });
      // Add event listeners to "Stop" buttons for active trades
      document.querySelectorAll('.stopTradeBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          autoTrades = autoTrades.filter(t => t.id !== btn.dataset.tradeId); // Remove trade from list
          updateAutoTradeModal(); // Re-render active trades
          notify('Stopped automated trade.');
          playSound();
        });
      });
    }

    // Event listener for "Start Auto Buy" button
    document.getElementById('startAutoBuy').addEventListener('click', () => {
      const ticker = document.getElementById('autoBuyToken').value;
      const amount = parseFloat(document.getElementById('autoBuyAmount').value);
      const interval = parseFloat(document.getElementById('autoBuyInterval').value);
      const unit = document.getElementById('autoBuyUnit').value;
      if (!ticker || isNaN(amount) || amount <= 0 || isNaN(interval) || interval <= 0) {
        notify('Invalid auto buy parameters.');
        return;
      }
      // Add new auto buy trade to the list
      autoTrades.push({
        id: `buy_${Date.now()}`,
        type: 'Buy',
        ticker,
        amount,
        interval,
        unit,
        intervalMs: interval * (unit === 'minutes' ? 60 * 1000 : 1000) // Calculate interval in milliseconds
      });
      updateAutoTradeModal(); // Update active trades display
      notify(`Started auto buy for ${ticker}: ${amount} AVAX every ${interval} ${unit}.`);
      playSound();
    });

    // Event listener for "Start Auto Sell" button
    document.getElementById('startAutoSell').addEventListener('click', () => {
      const ticker = document.getElementById('autoSellToken').value;
      const amount = parseFloat(document.getElementById('autoSellAmount').value);
      const interval = parseFloat(document.getElementById('autoSellInterval').value);
      const unit = document.getElementById('autoSellUnit').value;
      if (!ticker || isNaN(amount) || amount <= 0 || amount > (tokenBalances[ticker] || 0) || isNaN(interval) || interval <= 0) {
        notify('Invalid auto sell parameters.');
        return;
      }
      // Add new auto sell trade to the list
      autoTrades.push({
        id: `sell_${Date.now()}`,
        type: 'Sell',
        ticker,
        amount,
        interval,
        unit,
        intervalMs: interval * (unit === 'minutes' ? 60 * 1000 : 1000)
      });
      updateAutoTradeModal();
      notify(`Started auto sell for ${ticker}: ${amount} ${ticker} every ${interval} ${unit}.`);
      playSound();
    });

    // Event listener for "Add Liquidity" button
    document.getElementById('addLiquidityBtn').addEventListener('click', () => {
      if (!wallet || !currentToken) {
        notify('Please sign in and select a token.');
        return;
      }
      const avaxAmount = parseFloat(document.getElementById('avaxAmount').value);
      const tokenAmount = parseFloat(document.getElementById('tokenAmount').value);
      const platformFee = avaxAmount * 0.05; // 5% platform fee
      if (isNaN(avaxAmount) || isNaN(tokenAmount) || avaxAmount <= 0 || tokenAmount <= 0 ||
          avaxAmount + platformFee + 0.02 > avaxBalance || tokenAmount > (tokenBalances[currentToken.ticker] || 0)) {
        notify('Invalid amounts or insufficient balance.');
        return;
      }
      // Initialize pool if it doesn't exist
      const pool = liquidityPools[currentToken.ticker] || { avax: 0, token: 0, totalShares: 0, userShares: {}, fees: {} };
      // Simplified share calculation: proportional to existing pool or sqrt for initial
      const share = pool.totalShares === 0 ? Math.sqrt(avaxAmount * tokenAmount) : (avaxAmount / pool.avax) * pool.totalShares;
      pool.avax += avaxAmount;
      pool.token += tokenAmount;
      pool.totalShares += share;
      pool.userShares[wallet.address] = (pool.userShares[wallet.address] || 0) + share;
      pool.fees[wallet.address] = (pool.fees[wallet.address] || 0) + (avaxAmount * 0.003); // Simulate small trading fees earned
      avaxBalance = (parseFloat(avaxBalance) - (avaxAmount + platformFee + 0.02)).toFixed(2);
      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) - tokenAmount).toFixed(2);
      platformTreasury += platformFee;
      liquidityPools[currentToken.ticker] = pool; // Update the global liquidity pools object
      currentToken.price = pool.avax / pool.token * AVAX_PRICE; // Recalculate token price
      currentToken.marketCap = currentToken.price * (currentToken.supply - currentToken.burned); // Update market cap
      currentToken.transactions.push({
        type: 'Add Liquidity',
        amount: `${avaxAmount} AVAX + ${tokenAmount} ${currentToken.ticker}`,
        timestamp: new Date().toLocaleString()
      });
      updateLiquiditySection();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      updateTokenDetails(); // Update token details if open
      notify(`Added ${avaxAmount} AVAX and ${tokenAmount} ${currentToken.ticker} to liquidity pool.`);
      playSound();
    });

    // Event listener for "Remove Liquidity" button
    document.getElementById('removeLiquidityBtn').addEventListener('click', () => {
      if (!wallet || !currentToken) {
        notify('Please sign in and select a token.');
        return;
      }
      const pool = liquidityPools[currentToken.ticker];
      if (!pool || !pool.userShares[wallet.address]) {
        notify('No liquidity to remove.');
        return;
      }
      const share = pool.userShares[wallet.address];
      const platformFee = 0.02 * 0.05; // Platform fee for removing liquidity
      if (platformFee + 0.02 > avaxBalance) {
        notify('Insufficient AVAX for fees.');
        return;
      }
      // Calculate proportional shares of AVAX and token to return
      const avaxShare = (share / pool.totalShares) * pool.avax;
      const tokenShare = (share / pool.totalShares) * pool.token;
      const fees = pool.fees[wallet.address] || 0; // Fees earned by the user
      pool.avax -= avaxShare;
      pool.token -= tokenShare;
      pool.totalShares -= share;
      pool.fees[wallet.address] = 0; // Reset claimed fees
      avaxBalance = (parseFloat(avaxBalance) + avaxShare - platformFee - 0.02).toFixed(2); // Return AVAX, deduct fees
      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) + tokenShare).toFixed(2); // Return tokens
      platformTreasury += platformFee;
      delete pool.userShares[wallet.address]; // Remove user's shares
      currentToken.price = pool.avax / pool.token * AVAX_PRICE; // Recalculate price
      currentToken.marketCap = currentToken.price * (currentToken.supply - currentToken.burned); // Update market cap
      currentToken.transactions.push({
        type: 'Remove Liquidity',
        amount: `${avaxShare} AVAX + ${tokenShare} ${currentToken.ticker}`,
        timestamp: new Date().toLocaleString()
      });
      updateLiquiditySection();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      updateTokenDetails();
      notify(`Removed ${avaxShare.toFixed(2)} AVAX and ${tokenShare.toFixed(2)} ${currentToken.ticker} from liquidity pool. Claimed ${fees.toFixed(2)} AVAX fees.`);
      playSound();
    });

    /**
     * Updates the liquidity section in the token details modal.
     */
    function updateLiquiditySection() {
      if (!currentToken) return;
      // Initialize pool if it doesn't exist
      const pool = liquidityPools[currentToken.ticker] || { avax: 0, token: 0, totalShares: 0, userShares: {}, fees: {} };
      const tvl = (pool.avax * AVAX_PRICE + pool.token * currentToken.price).toFixed(2);
      const share = pool.userShares[wallet.address] || 0;
      const sharePercent = pool.totalShares > 0 ? (share / pool.totalShares * 100).toFixed(2) : 0;
      const fees = pool.fees[wallet.address] || 0;
      const apr = pool.totalShares > 0 ? (fees * 365 / (share * AVAX_PRICE) * 100).toFixed(2) : 0; // Simplified APR
      // Simplified impermanent loss calculation (conceptual)
      const impermanentLoss = pool.avax > 0 && pool.token > 0 ? ((pool.avax / pool.token * currentToken.price) / AVAX_PRICE - 1).toFixed(2) : 0;

      document.getElementById('poolTVL').textContent = tvl;
      document.getElementById('poolShare').textContent = sharePercent;
      document.getElementById('feesEarned').textContent = fees.toFixed(2);
      document.getElementById('poolAPR').textContent = apr;
      document.getElementById('impermanentLoss').textContent = impermanentLoss;
      // Update liquidity token dropdown with current token and its balance
      document.getElementById('liquidityToken').innerHTML = `<option value="${currentToken.ticker}">${currentToken.ticker} (${tokenBalances[currentToken.ticker] || 0})</option>`;
    }

    // Event listener for "Claim Tokens" button
    document.getElementById('claimBtn').addEventListener('click', () => {
      toggleModalScroll('menuModal', false); // Close menu
      toggleModalScroll('claimModal', true); // Open claim modal
      updateClaimModal(); // Populate claim token dropdown
      playSound();
    });

    // Event listener for "Close Claim" button
    document.getElementById('closeClaim').addEventListener('click', () => {
      toggleModalScroll('claimModal', false); // Close claim modal
      playSound();
    });

    /**
     * Updates the claim tokens modal with available tokens for airdrop claiming.
     */
    function updateClaimModal() {
      const claimTokenSelect = document.getElementById('claimToken');
      claimTokenSelect.innerHTML = '<option value="">Select Token</option>';
      // Only show tokens that have started vesting
      tokens.filter(t => t.vestingStart).forEach(token => {
        claimTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker} (${tokenBalances[token.ticker] || 0})</option>`;
      });
      // Update currentToken and airdrop section when a token is selected
      claimTokenSelect.addEventListener('change', () => {
        currentToken = tokens.find(t => t.ticker === claimTokenSelect.value);
        updateAirdropSection();
      });
      updateAirdropSection(); // Initial update
    }

    // Event listener for "Claim Airdrop" button
    document.getElementById('claimAirdropBtn').addEventListener('click', () => {
      if (!currentToken || !currentToken.vestingStart) {
        notify('Airdrop not yet started.');
        return;
      }
      const platformFee = 0.02 * 0.05;
      if (platformFee + 0.02 > avaxBalance) {
        notify('Insufficient AVAX for fees.');
        return;
      }
      // Calculate user's share of the airdrop pool
      const totalAirdrop = currentToken.airdropPool || 0;
      const userContribution = currentToken.contributors.find(c => c.wallet === wallet.address)?.amount || 0;
      const totalContributed = currentToken.contributors.reduce((sum, c) => sum + c.amount, 0) || 1;
      const userShare = totalContributed > 0 ? userContribution / totalContributed : 0;
      const elapsed = Date.now() - currentToken.vestingStart;
      const vestedPercent = Math.min(elapsed / currentToken.vestingDuration, 1);
      // Calculate claimable amount, deducting already claimed amounts
      const claimable = (totalAirdrop * userShare * vestedPercent - (currentToken.claimed[wallet.address] || 0)).toFixed(2);
      if (claimable <= 0) {
        notify('No tokens available to claim.');
        return;
      }
      // Transfer claimed tokens to user's balance
      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) + parseFloat(claimable)).toFixed(2);
      currentToken.claimed[wallet.address] = (currentToken.claimed[wallet.address] || 0) + parseFloat(claimable); // Update claimed amount
      avaxBalance = (parseFloat(avaxBalance) - (platformFee + 0.02)).toFixed(2); // Deduct fees
      platformTreasury += platformFee;
      currentToken.transactions.push({
        type: 'Airdrop Claim',
        amount: `${claimable} ${currentToken.ticker}`,
        timestamp: new Date().toLocaleString()
      });
      updateAirdropSection();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      notify(`Claimed ${claimable} ${currentToken.ticker} from airdrop.`);
      playSound();
    });

    /**
     * Updates the airdrop information section for the current token.
     */
    function updateAirdropSection() {
      if (!currentToken) return;
      const totalAirdrop = currentToken.airdropPool || 0;
      const userContribution = currentToken.contributors.find(c => c.wallet === wallet.address)?.amount || 0;
      const totalContributed = currentToken.contributors.reduce((sum, c) => sum + c.amount, 0) || 1;
      const userShare = totalContributed > 0 ? userContribution / totalContributed : 0;
      const elapsed = currentToken.vestingStart ? (Date.now() - currentToken.vestingStart) : 0;
      const vestedPercent = currentToken.vestingStart ? Math.min(elapsed / currentToken.vestingDuration, 1) * 100 : 0;
      document.getElementById('airdropTotal').textContent = (totalAirdrop * userShare).toFixed(2);
      document.getElementById('airdropClaimable').textContent = (totalAirdrop * userShare * vestedPercent / 100 - (currentToken.claimed[wallet.address] || 0)).toFixed(2);
      document.getElementById('vestingProgress').textContent = vestedPercent.toFixed(2);
    }

    // Event listener for "Voting" button
    document.getElementById('votingBtn').addEventListener('click', () => {
      toggleModalScroll('menuModal', false); // Close menu
      toggleModalScroll('votingModal', true); // Open voting modal
      updateVotingModal(); // Populate voting options
      playSound();
    });

    // Event listener for "Close Voting" button
    document.getElementById('closeVoting').addEventListener('click', () => {
      toggleModalScroll('votingModal', false); // Close voting modal
      playSound();
    });

    /**
     * Updates the voting modal with available tokens and active proposals.
     */
    function updateVotingModal() {
      const voteTokenSelect = document.getElementById('voteToken');
      voteTokenSelect.innerHTML = '<option value="">Select Token</option>';
      tokens.forEach(token => {
        voteTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker} (${tokenBalances[token.ticker] || 0})</option>`;
      });
      const activeProposals = document.getElementById('activeProposals');
      activeProposals.innerHTML = '';
      // Filter proposals based on selected token or show all
      proposals.filter(p => p.ticker === voteTokenSelect.value || !voteTokenSelect.value).forEach(proposal => {
        let optionsHtml = '';
        proposal.options.forEach((option, index) => {
          const power = proposal.votingPower[index] || 0;
          optionsHtml += `
            <div class="glowing-box p-2 rounded mb-2">
              <p>${option}: ${power} power</p>
              <button class="voteOptionBtn w-full neon-btn text-white px-4 py-2 rounded mt-2" data-proposal-id="${proposal.id}" data-option-index="${index}">Vote (${tokenBalances[proposal.ticker] || 0} power)</button>
            </div>`;
        });
        activeProposals.innerHTML += `
          <div class="glowing-box p-4 rounded-lg mb-2">
            <p><strong>${proposal.text}</strong></p>
            <p>Reward: ${proposal.reward} AVAX</p>
            ${optionsHtml}
          </div>`;
      });
      // Add event listeners to dynamically created vote buttons
      document.querySelectorAll('.voteOptionBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          const proposalId = btn.dataset.proposalId;
          const optionIndex = btn.dataset.optionIndex;
          const proposal = proposals.find(p => p.id === proposalId);
          const votePower = parseFloat(tokenBalances[proposal.ticker] || 0); // User's token balance is voting power
          if (votePower <= 0) {
            notify('You need tokens to vote.');
            return;
          }
          proposal.votingPower[optionIndex] = (proposal.votingPower[optionIndex] || 0) + votePower;
          avaxBalance = (parseFloat(avaxBalance) + parseFloat(proposal.reward)).toFixed(2); // Reward for voting
          notify(`Voted on "${proposal.text}" with ${votePower} ${proposal.ticker} power. Received ${proposal.reward} AVAX.`);
          updateVotingModal();
          updateBalanceModal();
          updatePortfolio();
          playSound();
        });
      });
    }

    // Event listener for "Create Proposal" button
    document.getElementById('createProposalBtn').addEventListener('click', () => {
      const ticker = document.getElementById('voteToken').value;
      const text = document.getElementById('proposalText').value;
      const options = document.getElementById('proposalOptions').value.split(',').map(o => o.trim());
      const reward = parseFloat(document.getElementById('proposalReward').value);
      if (!ticker || !text || options.length < 2 || isNaN(reward) || reward <= 0 || reward + 0.02 > avaxBalance) {
        notify('Invalid proposal details or insufficient AVAX.');
        return;
      }
      // Add new proposal to the list
      proposals.push({
        id: `prop_${Date.now()}`,
        ticker,
        text,
        options,
        votingPower: new Array(options.length).fill(0), // Initialize voting power for each option
        reward
      });
      avaxBalance = (parseFloat(avaxBalance) - (reward + 0.02)).toFixed(2); // Deduct reward and gas fee
      platformTreasury += 0.02 * 0.05; // Small fee for creating proposal
      updateVotingModal();
      updateBalanceModal();
      updateTreasury();
      notify(`Created proposal for ${ticker}: ${text}`);
      playSound();
    });

    // Event listener for "Quests" button
    document.getElementById('questsBtn').addEventListener('click', () => {
      toggleModalScroll('menuModal', false); // Close menu
      toggleModalScroll('questsModal', true); // Open quests modal
      updateQuestsModal(); // Populate quests list
      playSound();
    });

    // Event listener for "Close Quests" button
    document.getElementById('closeQuests').addEventListener('click', () => {
      toggleModalScroll('questsModal', false); // Close quests modal
      playSound();
    });

    /**
     * Updates the quests modal with available quests.
     */
    function updateQuestsModal() {
      const questTokenSelect = document.getElementById('questToken');
      questTokenSelect.innerHTML = '<option value="">Select Token</option>';
      tokens.forEach(token => {
        questTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker} (${tokenBalances[token.ticker] || 0})</option>`;
      });
      const activeQuests = document.getElementById('activeQuests');
      activeQuests.innerHTML = '';
      // Filter quests based on selected token or show all
      quests.filter(q => q.ticker === questTokenSelect.value || !questTokenSelect.value).forEach(quest => {
        activeQuests.innerHTML += `
          <div class="glowing-box p-4 rounded-lg mb-2">
            <p><strong>${quest.description}</strong></p>
            <p>Reward: ${quest.reward} ${quest.rewardType}</p>
            <button class="completeQuestBtn w-full neon-btn text-white px-4 py-2 rounded mt-2" data-quest-id="${quest.id}">Complete</button>
          </div>`;
      });
      // Add event listeners to dynamically created "Complete" buttons
      document.querySelectorAll('.completeQuestBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          const quest = quests.find(q => q.id === btn.dataset.questId);
          // Distribute rewards based on reward type
          if (quest.rewardType === 'AVAX') {
            avaxBalance = (parseFloat(avaxBalance) + quest.reward).toFixed(2);
          } else {
            tokenBalances[quest.ticker] = (parseFloat(tokenBalances[quest.ticker] || 0) + quest.reward).toFixed(2);
          }
          quests = quests.filter(q => q.id !== quest.id); // Remove completed quest
          notify(`Completed quest: ${quest.description}. Received ${quest.reward} ${quest.rewardType}.`);
          updateQuestsModal();
          updateBalanceModal();
          updatePortfolio();
          playSound();
        });
      });
    }

    // Event listener for "Create Quest" button
    document.getElementById('createQuestBtn').addEventListener('click', () => {
      const ticker = document.getElementById('questToken').value;
      const description = document.getElementById('questDescription').value;
      const reward = parseFloat(document.getElementById('questReward').value);
      if (!ticker || !description || isNaN(reward) || reward <= 0 || reward > (tokenBalances[ticker] || 0)) {
        notify('Invalid quest details or insufficient tokens.');
        return;
      }
      // Add new quest to the list
      quests.push({
        id: `quest_${Date.now()}`,
        ticker,
        description,
        reward,
        rewardType: ticker // Reward in the token itself
      });
      tokenBalances[ticker] = (parseFloat(tokenBalances[ticker]) - reward).toFixed(2); // Deduct reward from creator's balance
      platformTreasury += 0.02 * 0.05; // Small fee for creating quest
      updateQuestsModal();
      updateBalanceModal();
      updateTreasury();
      notify(`Created quest for ${ticker}: ${description}`);
      playSound();
    });

    // Event listener for "Treasury" button
    document.getElementById('treasuryBtn').addEventListener('click', () => {
      toggleModalScroll('menuModal', false); // Close menu
      toggleModalScroll('treasuryModal', true); // Open treasury modal
      updateTreasury(); // Update treasury balance display
      playSound();
    });

    // Event listener for "Close Treasury" button
    document.getElementById('closeTreasury').addEventListener('click', () => {
      toggleModalScroll('treasuryModal', false); // Close treasury modal
      playSound();
    });

    /**
     * Updates the platform treasury balance display.
     */
    function updateTreasury() {
      document.getElementById('treasuryBalance').textContent = platformTreasury.toFixed(2);
    }

    // Event listener for "Back" button in Swap modal
    document.getElementById('backSwap').addEventListener('click', () => {
      toggleModalScroll('swapPage', false); // Close swap modal
      toggleModalScroll('menuModal', true); // Re-open menu
      playSound();
    });

    // Event listener for "Swap Token" dropdown change
    document.getElementById('swapToken').addEventListener('change', () => {
      currentToken = tokens.find(t => t.ticker === document.getElementById('swapToken').value);
      updateSwapSection(); // Re-populate swap section (mainly for token balance display)
    });

    // Event listener for "AVAX Amount" input in Swap modal
    document.getElementById('tradeAvaxAmount').addEventListener('input', () => {
      const avaxAmount = parseFloat(document.getElementById('tradeAvaxAmount').value);
      if (!isNaN(avaxAmount) && currentToken?.price > 0) {
        const tokenAmount = (avaxAmount / currentToken.price).toFixed(2);
        document.getElementById('tradeTokenAmount').value = tokenAmount;
      } else {
        document.getElementById('tradeTokenAmount').value = '';
      }
    });

    // Event listener for "Swap" button (opens confirmation modal)
    document.getElementById('tradeBtn').addEventListener('click', () => {
      if (!wallet || !currentToken) {
        notify('Please sign in and select a token.');
        return;
      }
      const avaxAmount = parseFloat(document.getElementById('tradeAvaxAmount').value);
      const tokenAmount = parseFloat(document.getElementById('tradeTokenAmount').value);
      const slippage = parseFloat(document.getElementById('slippageSelect').value);
      const platformFee = avaxAmount * 0.05;
      if (isNaN(avaxAmount) || avaxAmount <= 0 || avaxAmount + platformFee + 0.02 > avaxBalance) {
        notify('Invalid AVAX amount or insufficient balance.');
        return;
      }
      // Populate trade confirmation modal
      document.getElementById('confirmAvaxAmount').textContent = avaxAmount.toFixed(2);
      document.getElementById('confirmTokenAmount').textContent = tokenAmount.toFixed(2);
      document.getElementById('confirmTokenTicker').textContent = currentToken.ticker;
      document.getElementById('confirmSlippage').textContent = slippage;
      document.getElementById('confirmGasFee').textContent = 0.02; // Simulated gas fee
      document.getElementById('confirmPlatformFee').textContent = platformFee.toFixed(2);
      toggleModalScroll('tradeConfirmModal', true); // Open confirmation modal
      playSound();
    });

    // Event listener for "Confirm Trade" button
    document.getElementById('confirmTradeBtn').addEventListener('click', () => {
      const avaxAmount = parseFloat(document.getElementById('confirmAvaxAmount').textContent);
      const tokenAmount = parseFloat(document.getElementById('confirmTokenAmount').textContent);
      const platformFee = parseFloat(document.getElementById('confirmPlatformFee').textContent);
      // const creatorFee = (avaxAmount * currentToken.creatorFee / 100).toFixed(2); // Creator fee not directly applied here for simplicity

      // Deduct AVAX, add tokens, update treasury
      avaxBalance = (parseFloat(avaxBalance) - (avaxAmount + platformFee + 0.02)).toFixed(2);
      platformTreasury += platformFee;
      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) + tokenAmount).toFixed(2);

      // Simulate liquidity pool changes and price impact
      const pool = liquidityPools[currentToken.ticker];
      pool.avax += avaxAmount;
      pool.token -= tokenAmount;
      currentToken.price = pool.avax / pool.token * AVAX_PRICE; // Recalculate token price
      currentToken.priceHistory.push({ timestamp: new Date().toLocaleString(), price: currentToken.price }); // Add to price history
      currentToken.marketCap = currentToken.price * (currentToken.supply - currentToken.burned); // Update market cap
      currentToken.transactions.push({
        type: 'Buy',
        amount: `${tokenAmount} ${currentToken.ticker}`,
        timestamp: new Date().toLocaleString()
      });
      // Update portfolio cost basis
      portfolioHistory[portfolioHistory.length - 1].costBasis += avaxAmount * AVAX_PRICE;
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      updateTokenDetails(); // Update token details page if open
      toggleModalScroll('tradeConfirmModal', false); // Close confirmation modal
      notify(`Swapped ${avaxAmount.toFixed(2)} AVAX for ${tokenAmount.toFixed(2)} ${currentToken.ticker}.`);
      playSound();
      checkPriceAlerts(); // Check if any price alerts are triggered
    });

    // Event listener for "Cancel Trade" button
    document.getElementById('cancelTradeBtn').addEventListener('click', () => {
      toggleModalScroll('tradeConfirmModal', false); // Close confirmation modal
      playSound();
    });

    // Event listener for "Snipe" button (for whitelist contributions)
    document.getElementById('snipeBtn').addEventListener('click', () => {
      const amount = parseFloat(document.getElementById('snipeAmount').value);
      const platformFee = amount * 0.05;
      if (isNaN(amount) || amount < currentToken.minContribution || amount > currentToken.maxContribution || amount + platformFee + 0.02 > avaxBalance) {
        notify('Invalid contribution amount or insufficient AVAX.');
        return;
      }
      // Deduct AVAX and update treasury
      avaxBalance = (parseFloat(avaxBalance) - (amount + platformFee + 0.02)).toFixed(2);
      platformTreasury += platformFee;
      currentToken.contributors.push({ wallet: wallet.address, amount }); // Record contributor
      currentToken.transactions.push({
        type: 'Contribution',
        amount: `${amount} AVAX`,
        timestamp: new Date().toLocaleString()
      });
      // Update portfolio cost basis
      portfolioHistory[portfolioHistory.length - 1].costBasis += amount * AVAX_PRICE;
      updateTokenDetails();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      notify(`Contributed ${amount} AVAX to ${currentToken.ticker} whitelist.`);
      playSound();
    });

    // Event listener for "Burn" button
    document.getElementById('burnBtn').addEventListener('click', () => {
      const amount = parseFloat(document.getElementById('burnAmount').value);
      const platformFee = 0.02 * 0.05; // Small platform fee for burning
      if (isNaN(amount) || amount <= 0 || amount > (tokenBalances[currentToken.ticker] || 0) || platformFee + 0.02 > avaxBalance) {
        notify('Invalid burn amount or insufficient balance.');
        return;
      }
      // Deduct tokens from user, update supply and burned amounts
      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker]) - amount).toFixed(2);
      currentToken.supply -= amount;
      currentToken.burned += amount;
      currentToken.marketCap = currentToken.price * (currentToken.supply - currentToken.burned); // Update market cap after burn
      avaxBalance = (parseFloat(avaxBalance) - (platformFee + 0.02)).toFixed(2);
      platformTreasury += platformFee;
      currentToken.transactions.push({
        type: 'Burn',
        amount: `${amount} ${currentToken.ticker}`,
        timestamp: new Date().toLocaleString()
      });
      updateTokenDetails();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      notify(`Burned ${amount} ${currentToken.ticker}.`);
      playSound();
    });

    // Event listener for "Stake" button
    document.getElementById('stakeBtn').addEventListener('click', () => {
      const amount = parseFloat(document.getElementById('stakeAmount').value);
      const poolId = document.getElementById('stakePool').value;
      const platformFee = 0.02 * 0.05;
      if (!currentToken || isNaN(amount) || amount <= 0 || amount > (tokenBalances[currentToken.ticker] || 0) || platformFee + 0.02 > avaxBalance) {
        notify('Invalid stake amount or insufficient balance.');
        return;
      }
      // Initialize pool if it doesn't exist
      const pool = stakingPools[currentToken.ticker]?.[poolId] || { staked: 0, users: 0, rewardPool: 0, rewardType: 'AVAX', baseApr: 10, userStakes: {}, lastReward: Date.now() };
      pool.staked += amount;
      // Increment user count only if this is their first stake in this pool
      pool.users += pool.userStakes[wallet.address] ? 0 : 1;
      pool.userStakes[wallet.address] = (pool.userStakes[wallet.address] || 0) + amount;
      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker]) - amount).toFixed(2); // Deduct staked tokens
      avaxBalance = (parseFloat(avaxBalance) - (platformFee + 0.02)).toFixed(2); // Deduct fees
      platformTreasury += platformFee;
      if (!stakingPools[currentToken.ticker]) stakingPools[currentToken.ticker] = {};
      stakingPools[currentToken.ticker][poolId] = pool; // Update the global staking pools object
      currentToken.transactions.push({
        type: 'Stake',
        amount: `${amount} ${currentToken.ticker}`,
        timestamp: new Date().toLocaleString()
      });
      updateStakingSection();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      notify(`Staked ${amount} ${currentToken.ticker} in pool ${poolId}.`);
      playSound();
    });

    // Event listener for "Unstake" button
    document.getElementById('unstakeBtn').addEventListener('click', () => {
      const amount = parseFloat(document.getElementById('stakeAmount').value);
      const poolId = document.getElementById('stakePool').value;
      const platformFee = 0.02 * 0.05;
      if (!currentToken || isNaN(amount) || amount <= 0 || amount > (stakingPools[currentToken.ticker]?.[poolId]?.userStakes[wallet.address] || 0) || platformFee + 0.02 > avaxBalance) {
        notify('Invalid unstake amount or insufficient balance.');
        return;
      }
      const pool = stakingPools[currentToken.ticker][poolId];
      pool.staked -= amount;
      pool.userStakes[wallet.address] -= amount;
      // Decrement user count if their stake becomes zero
      if (pool.userStakes[wallet.address] <= 0) {
        pool.users -= 1;
        delete pool.userStakes[wallet.address];
      }
      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) + amount).toFixed(2); // Return unstaked tokens
      avaxBalance = (parseFloat(avaxBalance) - (platformFee + 0.02)).toFixed(2); // Deduct fees
      platformTreasury += platformFee;
      currentToken.transactions.push({
        type: 'Unstake',
        amount: `${amount} ${currentToken.ticker}`,
        timestamp: new Date().toLocaleString()
      });
      updateStakingSection();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      notify(`Unstaked ${amount} ${currentToken.ticker} from pool ${poolId}.`);
      playSound();
    });

    // Event listener for "Claim Rewards" button
    document.getElementById('claimStakeRewardsBtn').addEventListener('click', () => {
      const poolId = document.getElementById('stakePool').value;
      const platformFee = 0.02 * 0.05;
      if (!currentToken || !stakingPools[currentToken.ticker]?.[poolId] || platformFee + 0.02 > avaxBalance) {
        notify('No staking pool selected or insufficient AVAX for fees.');
        return;
      }
      const pool = stakingPools[currentToken.ticker][poolId];
      // Calculate elapsed time since last reward claim (in days)
      const elapsed = (Date.now() - pool.lastReward) / (1000 * 60 * 60 * 24);
      const userShare = pool.userStakes[wallet.address] / pool.staked;
      // Calculate reward based on APR, elapsed time, and user's share
      const reward = (pool.rewardPool * userShare * pool.baseApr / 100 * elapsed).toFixed(2);
      if (reward <= 0) {
        notify('No rewards available to claim.');
        return;
      }
      // Distribute rewards based on reward type
      if (pool.rewardType === 'AVAX') {
        avaxBalance = (parseFloat(avaxBalance) + parseFloat(reward) - platformFee - 0.02).toFixed(2);
      } else {
        tokenBalances[pool.rewardType] = (parseFloat(tokenBalances[pool.rewardType] || 0) + parseFloat(reward)).toFixed(2);
      }
      pool.lastReward = Date.now(); // Reset last reward time
      platformTreasury += platformFee;
      currentToken.transactions.push({
        type: 'Claim Staking Rewards',
        amount: `${reward} ${pool.rewardType}`,
        timestamp: new Date().toLocaleString()
      });
      updateStakingSection();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      notify(`Claimed ${reward} ${pool.rewardType} from staking pool ${poolId}.`);
      playSound();
    });

    /**
     * Updates the staking section in the token details modal.
     */
    function updateStakingSection() {
      if (!currentToken) return;
      const stakeTokenSelect = document.getElementById('stakeToken');
      const stakePoolSelect = document.getElementById('stakePool');
      // Populate stake token dropdown with current token and its balance
      stakeTokenSelect.innerHTML = `<option value="${currentToken.ticker}">${currentToken.ticker} (${tokenBalances[currentToken.ticker] || 0})</option>`;
      stakePoolSelect.innerHTML = '<option value="">Select Pool</option>';
      // Populate stake pool dropdown with available pools for the current token
      if (stakingPools[currentToken.ticker]) {
        Object.keys(stakingPools[currentToken.ticker]).forEach(poolId => {
          stakePoolSelect.innerHTML += `<option value="${poolId}">${poolId} (${stakingPools[currentToken.ticker][poolId].rewardType}, ${stakingPools[currentToken.ticker][poolId].baseApr}% APR)</option>`;
        });
      }
      const poolId = stakePoolSelect.value;
      if (poolId && stakingPools[currentToken.ticker]?.[poolId]) {
        const pool = stakingPools[currentToken.ticker][poolId];
        document.getElementById('stakedAmount').textContent = (pool.userStakes[wallet.address] || 0).toFixed(2);
        document.getElementById('rewardPool').textContent = pool.rewardPool.toFixed(2);
        document.getElementById('stakeAPR').textContent = pool.baseApr;
      } else {
        // Reset display if no pool is selected or found
        document.getElementById('stakedAmount').textContent = '0';
        document.getElementById('rewardPool').textContent = '0';
        document.getElementById('stakeAPR').textContent = '0';
      }
    }

    // Event listener for "View Transactions" button
    document.getElementById('viewTransactionsBtn').addEventListener('click', () => {
      toggleModalScroll('tokenDetailsPage', false); // Close token details
      toggleModalScroll('transactionPage', true); // Open transaction history
      updateTransactionHistory(); // Populate transaction history
      playSound();
    });

    // Event listener for "Back" button in Transaction History modal
    document.getElementById('backTransactions').addEventListener('click', () => {
      toggleModalScroll('transactionPage', false); // Close transaction history
      toggleModalScroll('tokenDetailsPage', true); // Re-open token details
      updateTokenDetails(); // Re-update token details
      playSound();
    });

    /**
     * Updates the transaction history display for the current token.
     */
    function updateTransactionHistory() {
      const transactionHistory = document.getElementById('transactionHistory');
      transactionHistory.innerHTML = '';
      currentToken.transactions.forEach(tx => {
        transactionHistory.innerHTML += `
          <div class="glowing-box p-4 rounded-lg mb-2">
            <p><strong>${tx.type}</strong></p>
            <p>Amount: ${tx.amount}</p>
            <p>Timestamp: ${tx.timestamp}</p>
          </div>`;
      });
    }

    // Event listener for "Community Chat" button
    document.getElementById('viewChatBtn').addEventListener('click', () => {
      toggleModalScroll('tokenDetailsPage', false); // Close token details
      toggleModalScroll('chatPage', true); // Open chat modal
      updateChatSection(); // Populate chat messages
      playSound();
    });

    // Event listener for "Back" button in Community Chat modal
    document.getElementById('backChat').addEventListener('click', () => {
      toggleModalScroll('chatPage', false); // Close chat modal
      toggleModalScroll('tokenDetailsPage', true); // Re-open token details
      updateTokenDetails(); // Re-update token details
      playSound();
    });

    /**
     * Updates the community chat display and calculates sentiment.
     */
    function updateChatSection() {
      // Get messages for the current token, default to empty array
      const messages = chatMessages[currentToken.ticker] || [];
      // Calculate sentiment based on positive/negative reactions
      const sentiment = messages.reduce((sum, msg) => sum + (msg.reactions?.positive || 0) - (msg.reactions?.negative || 0), 0);
      document.getElementById('chatSentiment').textContent = sentiment > 0 ? 'Positive' : sentiment < 0 ? 'Negative' : 'Neutral';

      const chatMessagesDiv = document.getElementById('chatMessages');
      chatMessagesDiv.innerHTML = ''; // Clear existing messages
      messages.forEach((msg, index) => {
        chatMessagesDiv.innerHTML += `
          <div class="glowing-box p-4 rounded-lg mb-2">
            <p><strong>${msg.user.slice(0, 6)}...${msg.user.slice(-4)}</strong>: ${msg.text}</p>
            <p>Positive: ${msg.reactions?.positive || 0} | Negative: ${msg.reactions?.negative || 0}</p>
            <button class="reactPositiveBtn neon-btn text-white px-2 py-1 rounded mr-2" data-message-index="${index}">👍</button>
            <button class="reactNegativeBtn neon-btn text-white px-2 py-1 rounded" data-message-index="${index}">👎</button>
          </div>`;
      });
      // Add event listeners for reaction buttons
      document.querySelectorAll('.reactPositiveBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          const index = btn.dataset.messageIndex;
          if (!chatMessages[currentToken.ticker][index].reactions) {
            chatMessages[currentToken.ticker][index].reactions = { positive: 0, negative: 0 };
          }
          chatMessages[currentToken.ticker][index].reactions.positive += 1;
          updateChatSection(); // Re-render chat to show updated reactions
          playSound();
        });
      });
      document.querySelectorAll('.reactNegativeBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          const index = btn.dataset.messageIndex;
          if (!chatMessages[currentToken.ticker][index].reactions) {
            chatMessages[currentToken.ticker][index].reactions = { positive: 0, negative: 0 };
          }
          chatMessages[currentToken.ticker][index].reactions.negative += 1;
          updateChatSection();
          playSound();
        });
      });
    }

    // Event listener for "Send Chat" button
    document.getElementById('sendChat').addEventListener('click', () => {
      const text = document.getElementById('chatInput').value;
      if (!text || !wallet || !currentToken) {
        notify('Please sign in and enter a message.');
        return;
      }
      if (!chatMessages[currentToken.ticker]) chatMessages[currentToken.ticker] = [];
      chatMessages[currentToken.ticker].push({
        user: wallet.address,
        text,
        timestamp: new Date().toLocaleString(),
        reactions: { positive: 0, negative: 0 } // Initialize reactions for new message
      });
      document.getElementById('chatInput').value = ''; // Clear input field
      updateChatSection(); // Update chat display
      notify('Message sent.');
      playSound();
    });

    // Event listener for "Boost Token" button
    document.getElementById('boostBtn').addEventListener('click', () => {
      if (!currentToken) {
        notify('Please select a token to boost.');
        return;
      }
      document.getElementById('boostToken').textContent = currentToken.ticker;
      document.getElementById('boostTokenBalance').textContent = tokenBalances[currentToken.ticker] || 0;
      document.getElementById('boostTokenTicker').textContent = currentToken.ticker;
      toggleModalScroll('tokenDetailsPage', false); // Close token details
      toggleModalScroll('boostModal', true); // Open boost modal
      playSound();
    });

    // Event listener for "Confirm Boost" button
    document.getElementById('confirmBoostBtn').addEventListener('click', () => {
      const amount = parseFloat(document.getElementById('boostAmount').value);
      const platformFee = 0.02 * 0.05;
      if (isNaN(amount) || amount <= 0 || amount > (tokenBalances[currentToken.ticker] || 0) || platformFee + 0.02 > avaxBalance) {
        notify('Invalid boost amount or insufficient balance.');
        return;
      }
      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker]) - amount).toFixed(2); // Deduct boost amount
      currentToken.boost = (currentToken.boost || 0) + amount; // Increase token's boost value
      avaxBalance = (parseFloat(avaxBalance) - (platformFee + 0.02)).toFixed(2); // Deduct fees
      platformTreasury += platformFee;
      currentToken.transactions.push({
        type: 'Boost',
        amount: `${amount} ${currentToken.ticker}`,
        timestamp: new Date().toLocaleString()
      });
      updateTokenDetails();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      toggleModalScroll('boostModal', false); // Close boost modal
      toggleModalScroll('tokenDetailsPage', true); // Re-open token details
      notify(`Boosted ${currentToken.ticker} with ${amount} tokens.`);
      playSound();
    });

    // Event listener for "Cancel Boost" button
    document.getElementById('cancelBoostBtn').addEventListener('click', () => {
      toggleModalScroll('boostModal', false); // Close boost modal
      toggleModalScroll('tokenDetailsPage', true); // Re-open token details
      playSound();
    });

    // Event listener for "Share Token" button
    document.getElementById('shareTokenBtn').addEventListener('click', () => {
      const shareText = `Check out ${currentToken.name} (${currentToken.ticker}) on WL LAUNCHER! Price: $${currentToken.price.toFixed(4)}, Market Cap: $${currentToken.marketCap.toFixed(2)}`;
      // Copy text to clipboard (requires user interaction and secure context)
      navigator.clipboard.writeText(shareText).then(() => {
        notify('Token details copied to clipboard for sharing!');
      }).catch(err => {
        console.error('Failed to copy text: ', err);
        notify('Failed to copy token details.');
      });
      playSound();
    });

    // Event listener for "Set Alert" button
    document.getElementById('setAlertBtn').addEventListener('click', () => {
      const price = parseFloat(document.getElementById('alertPrice').value);
      const type = document.getElementById('alertType').value;
      if (isNaN(price) || price <= 0) {
        notify('Invalid price for alert.');
        return;
      }
      // Add new price alert
      priceAlerts.push({
        id: `alert_${Date.now()}`,
        ticker: currentToken.ticker,
        price,
        type
      });
      updatePriceAlerts(); // Update alerts display
      notify(`Price alert set for ${currentToken.ticker} ${type} $${price}.`);
      playSound();
    });

    /**
     * Updates the display of active price alerts.
     */
    function updatePriceAlerts() {
      const activeAlerts = document.getElementById('activeAlerts');
      activeAlerts.innerHTML = '';
      // Display alerts relevant to the current token
      priceAlerts.filter(a => a.ticker === currentToken.ticker).forEach(alert => {
        activeAlerts.innerHTML += `
          <div class="glowing-box p-4 rounded-lg mb-2">
            <p>Alert: ${alert.type} $${alert.price}</p>
            <button class="removeAlertBtn neon-btn text-white px-4 py-2 rounded mt-2" data-alert-id="${alert.id}">Remove</button>
          </div>`;
      });
      // Add event listeners to "Remove" buttons for alerts
      document.querySelectorAll('.removeAlertBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          priceAlerts = priceAlerts.filter(a => a.id !== btn.dataset.alertId); // Remove alert
          updatePriceAlerts(); // Re-render alerts
          notify('Price alert removed.');
          playSound();
        });
      });
    }

    /**
     * Checks if any active price alerts are triggered.
     * This function should be called periodically or after price changes.
     */
    function checkPriceAlerts() {
      priceAlerts.forEach(alert => {
        const token = tokens.find(t => t.ticker === alert.ticker);
        if (token && ((alert.type === 'above' && token.price >= alert.price) || (alert.type === 'below' && token.price <= alert.price))) {
          notify(`Price alert triggered for ${token.ticker}: $${token.price.toFixed(4)} ${alert.type} $${alert.price}`);
          priceAlerts = priceAlerts.filter(a => a.id !== alert.id); // Remove triggered alert
          updatePriceAlerts(); // Re-render alerts
        }
      });
    }

    // Event listener for "Place Order" button (for limit orders)
    document.getElementById('placeOrderBtn').addEventListener('click', () => {
      const ticker = document.getElementById('orderToken').value;
      const price = parseFloat(document.getElementById('orderPrice').value);
      const amount = parseFloat(document.getElementById('orderAmount').value);
      const type = document.getElementById('orderType').value;
      const platformFee = 0.02 * 0.05;
      if (!ticker || isNaN(price) || price <= 0 || isNaN(amount) || amount <= 0 ||
          (type === 'buy' && (amount * price / AVAX_PRICE + platformFee + 0.02 > avaxBalance)) ||
          (type === 'sell' && amount > (tokenBalances[ticker] || 0))) {
        notify('Invalid order details or insufficient balance.');
        return;
      }
      // Add new limit order
      limitOrders.push({
        id: `order_${Date.now()}`,
        ticker,
        price,
        amount,
        type
      });
      updateLimitOrders(); // Update limit orders display
      notify(`Placed ${type} limit order for ${amount} ${ticker} at $${price}.`);
      playSound();
    });

    /**
     * Updates the display of active limit orders.
     */
    function updateLimitOrders() {
      const activeOrders = document.getElementById('activeOrders');
      activeOrders.innerHTML = '';
      // Display orders relevant to the current token
      limitOrders.filter(o => o.ticker === currentToken.ticker).forEach(order => {
        activeOrders.innerHTML += `
          <div class="glowing-box p-4 rounded-lg mb-2">
            <p>${order.type} ${order.amount} ${order.ticker} at $${order.price}</p>
            <button class="cancelOrderBtn neon-btn text-white px-4 py-2 rounded mt-2" data-order-id="${order.id}">Cancel</button>
          </div>`;
      });
      // Add event listeners to "Cancel" buttons for orders
      document.querySelectorAll('.cancelOrderBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          limitOrders = limitOrders.filter(o => o.id !== btn.dataset.orderId); // Cancel order
          updateLimitOrders(); // Re-render orders
          notify('Limit order canceled.');
          playSound();
        });
      });
    }

    /**
     * Checks if any active limit orders are triggered and executes them.
     * This function should be called periodically or after price changes.
     */
    function checkLimitOrders() {
      limitOrders.forEach(order => {
        const token = tokens.find(t => t.ticker === order.ticker);
        if (!token) return; // Skip if token not found

        // Check if order condition is met
        if ((order.type === 'buy' && token.price <= order.price) || (order.type === 'sell' && token.price >= order.price)) {
          const platformFee = 0.02 * 0.05;
          if (platformFee + 0.02 > avaxBalance) return; // Ensure enough AVAX for fees

          if (order.type === 'buy') {
            const avaxAmount = (order.amount * token.price / AVAX_PRICE).toFixed(2);
            // Deduct AVAX and fees, add tokens
            avaxBalance = (parseFloat(avaxBalance) - (parseFloat(avaxAmount) + platformFee + 0.02)).toFixed(2);
            tokenBalances[token.ticker] = (parseFloat(tokenBalances[token.ticker] || 0) + order.amount).toFixed(2);
            portfolioHistory[portfolioHistory.length - 1].costBasis += parseFloat(avaxAmount) * AVAX_PRICE;
            token.transactions.push({
              type: 'Buy (Limit Order)',
              amount: `${order.amount} ${token.ticker}`,
              timestamp: new Date().toLocaleString()
            });
            notify(`Limit order executed: Bought ${order.amount} ${token.ticker} at $${token.price.toFixed(4)}.`);
          } else { // Sell order
            // Ensure enough tokens to sell
            if (order.amount > (tokenBalances[token.ticker] || 0)) return;
            // Add AVAX, deduct fees, deduct tokens
            avaxBalance = (parseFloat(avaxBalance) + (order.amount * token.price / AVAX_PRICE) - platformFee - 0.02).toFixed(2);
            tokenBalances[token.ticker] = (parseFloat(tokenBalances[token.ticker]) - order.amount).toFixed(2);
            token.transactions.push({
              type: 'Sell (Limit Order)',
              amount: `${order.amount} ${token.ticker}`,
              timestamp: new Date().toLocaleString()
            });
            notify(`Limit order executed: Sold ${order.amount} ${token.ticker} at $${token.price.toFixed(4)}.`);
          }
          platformTreasury += platformFee; // Add platform fee
          // Simulate liquidity pool changes and price impact
          const pool = liquidityPools[token.ticker];
          pool.avax += order.type === 'buy' ? order.amount * token.price / AVAX_PRICE : -(order.amount * token.price / AVAX_PRICE);
          pool.token += order.type === 'buy' ? -order.amount : order.amount;
          token.price = pool.avax / pool.token * AVAX_PRICE;
          token.priceHistory.push({ timestamp: new Date().toLocaleString(), price: token.price });
          token.marketCap = token.price * (token.supply - token.burned);
          limitOrders = limitOrders.filter(o => o.id !== order.id); // Remove executed order
          updateLimitOrders();
          updateBalanceModal();
          updatePortfolio();
          updateTreasury();
          updateTokenDetails();
          playSound();
        }
      });
    }

    /**
     * Updates the token details page with information about the currentToken.
     */
    function updateTokenDetails() {
      if (!currentToken) return; // Exit if no token is selected

      // Populate static token details
      document.getElementById('displayTokenName').textContent = currentToken.name;
      document.getElementById('displayTokenTicker').textContent = currentToken.ticker;
      document.getElementById('displayTokenSupply').textContent = currentToken.supply.toFixed(2);
      document.getElementById('marketCap').textContent = currentToken.marketCap.toFixed(2);
      document.getElementById('tokenPrice').textContent = currentToken.price.toFixed(4);
      document.getElementById('fdv').textContent = (currentToken.price * currentToken.originalSupply).toFixed(2);
      // Ensure liquidityPools[currentToken.ticker] exists before accessing
      document.getElementById('lockedLiquidity').textContent = (liquidityPools[currentToken.ticker]?.avax * AVAX_PRICE || 0).toFixed(2);
      document.getElementById('creatorFee').textContent = currentToken.creatorFee;
      document.getElementById('currentStage').textContent = currentToken.stage;
      document.getElementById('displayCreatorWallet').textContent = currentToken.creatorWallet.slice(0, 6) + '...' + currentToken.creatorWallet.slice(-4);
      document.getElementById('twitterLinkDisplay').textContent = currentToken.twitterLink || 'N/A';
      document.getElementById('twitterLinkDisplay').href = currentToken.twitterLink || '#';
      document.getElementById('discordLinkDisplay').textContent = currentToken.discordLink || 'N/A';
      document.getElementById('discordLinkDisplay').href = currentToken.discordLink || '#';
      document.getElementById('boostStatus').textContent = currentToken.boost ? `Boosted (${currentToken.boost} ${currentToken.ticker})` : 'Not Boosted';
      document.getElementById('tokenomics').textContent = `Airdrop: ${currentToken.airdropPercentage}%, Vesting: ${currentToken.vestingDuration / (1000 * 60 * 60 * 24)} days`;
      document.getElementById('tokenImg').src = currentToken.image || 'https://placehold.co/64x64/00ffaa/ffffff?text=Token'; // Placeholder image

      // Show/hide sections based on token stage
      document.getElementById('snipeSection').classList.toggle('hidden', currentToken.stage !== 'whitelist');
      document.getElementById('contributionSection').classList.toggle('hidden', currentToken.stage !== 'whitelist');
      document.getElementById('tradingInterface').classList.toggle('hidden', currentToken.stage !== 'trading');
      document.getElementById('burnSection').classList.toggle('hidden', currentToken.stage !== 'trading');
      document.getElementById('liquiditySection').classList.toggle('hidden', currentToken.stage !== 'trading');
      document.getElementById('stakingSection').classList.toggle('hidden', currentToken.stage !== 'trading');
      document.getElementById('priceAlertSection').classList.toggle('hidden', currentToken.stage !== 'trading');
      document.getElementById('limitOrderSection').classList.toggle('hidden', currentToken.stage !== 'trading');

      if (currentToken.stage === 'whitelist') {
        const totalContributed = currentToken.contributors.reduce((sum, c) => sum + c.amount, 0);
        const userContribution = currentToken.contributors.find(c => c.wallet === wallet.address)?.amount || 0;
        document.getElementById('totalContributed').textContent = totalContributed.toFixed(2);
        document.getElementById('totalContributedValue').textContent = (totalContributed * AVAX_PRICE).toFixed(2);
        document.getElementById('yourContribution').textContent = userContribution.toFixed(2);

        // Clear existing timer to prevent multiple timers for the same token
        if (currentToken.whitelistTimerId) clearInterval(currentToken.whitelistTimerId);

        currentToken.whitelistTimerId = setInterval(() => {
          const timeLeft = currentToken.whitelistEnd - Date.now();
          if (timeLeft <= 0) {
            clearInterval(currentToken.whitelistTimerId);
            currentToken.stage = 'trading'; // Transition to trading stage
            const totalContributed = currentToken.contributors.reduce((sum, c) => sum + c.amount, 0);
            const tradingSupply = currentToken.supply * (1 - currentToken.airdropPercentage / 100);
            currentToken.price = totalContributed / tradingSupply; // Calculate initial price
            currentToken.marketCap = currentToken.price * (currentToken.supply - currentToken.burned);
            currentToken.airdropPool = currentToken.originalSupply * (currentToken.airdropPercentage / 100); // Set airdrop pool
            currentToken.claimed = {}; // Initialize claimed amounts for airdrop
            // Initialize liquidity pool for trading
            liquidityPools[currentToken.ticker] = {
              avax: totalContributed,
              token: tradingSupply,
              totalShares: Math.sqrt(totalContributed * tradingSupply),
              userShares: {},
              fees: {}
            };
            // Distribute tokens to contributors based on their contribution
            currentToken.contributors.forEach(c => {
              const tokensReceived = (c.amount / totalContributed) * tradingSupply;
              // Ensure tokenBalances[c.wallet] is handled correctly (should be tokenBalances[currentToken.ticker])
              // Assuming this means the tokens are added to the user's balance for this ticker
              tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) + tokensReceived).toFixed(2);
            });
            currentToken.vestingStart = Date.now(); // Start vesting timer
            currentToken.priceHistory.push({ timestamp: new Date().toLocaleString(), price: currentToken.price }); // Add initial price to history
            notify(`${currentToken.ticker} whitelist ended. Trading started!`);
            updateTokenLists();
            updateTokenDetails();
            updateBalanceModal();
            updatePortfolio();
            playSound();
            simulateBotActivity(); // Trigger bot activity after transition
          } else {
            document.getElementById('whitelistTimer').textContent = `${Math.floor(timeLeft / 1000)}s`;
          }
        }, 1000);

        if (contributionChart) contributionChart.destroy();
        const contributionData = currentToken.contributors.map(c => c.amount);
        const contributionLabels = currentToken.contributors.map(c => c.wallet.slice(0, 6));
        contributionChart = new Chart(document.getElementById('contributionChart').getContext('2d'), {
          type: 'bar',
          data: {
            labels: contributionLabels,
            datasets: [{
              label: 'Contributions (AVAX)',
              data: contributionData,
              backgroundColor: '#00ffaa',
              borderColor: '#00ffaa',
              borderWidth: 2
            }]
          },
          options: {
            scales: {
              y: { beginAtZero: true, title: { display: true, text: 'AVAX', font: { family: 'Inter', size: 14, weight: 'bold' } } }
            }
          }
        });
      }

      if (currentToken.stage === 'trading') {
        if (priceChart) priceChart.destroy();
        priceChart = new Chart(document.getElementById('priceChart').getContext('2d'), {
          type: 'line',
          data: {
            labels: currentToken.priceHistory.map(h => h.timestamp),
            datasets: [{
              label: 'Price (USD)',
              data: currentToken.priceHistory.map(h => h.price),
              borderColor: '#00ffaa',
              backgroundColor: 'rgba(0, 255, 170, 0.2)',
              fill: true,
              tension: 0.4
            }]
          },
          options: {
            scales: {
              y: { beginAtZero: false, title: { display: true, text: 'Price (USD)', font: { family: 'Inter', size: 14, weight: 'bold' } } }
            }
          }
        });
        document.getElementById('chartPrice').textContent = currentToken.price.toFixed(4);
        document.getElementById('chartMarketCap').textContent = currentToken.marketCap.toFixed(2);
        document.getElementById('chartFdv').textContent = (currentToken.price * currentToken.originalSupply).toFixed(2);
        document.getElementById('chartLockedLiquidity').textContent = (liquidityPools[currentToken.ticker]?.avax * AVAX_PRICE || 0).toFixed(2);
        
        if (burnChart) burnChart.destroy();
        burnChart = new Chart(document.getElementById('burnChart').getContext('2d'), {
          type: 'line',
          data: {
            labels: currentToken.transactions.filter(t => t.type === 'Burn').map(t => t.timestamp),
            datasets: [{
              label: 'Tokens Burned',
              data: currentToken.transactions.filter(t => t.type === 'Burn').map(t => parseFloat(t.amount)),
              borderColor: '#ff4d4d',
              backgroundColor: 'rgba(255, 77, 77, 0.2)',
              fill: true,
              tension: 0.4
            }]
          },
          options: {
            scales: {
              y: { beginAtZero: true, title: { display: true, text: 'Burned Amount', font: { family: 'Inter', size: 14, weight: 'bold' } } }
            }
          }
        });
        updateLiquiditySection();
        updateStakingSection();
        updatePriceAlerts();
        updateLimitOrders();
      }
    }

    /**
     * Simulates the creation of some initial bot tokens for demonstration.
     */
    function simulateBotTokens() {
      const botTokens = [
        { name: 'Bot Token 1', ticker: 'BT1', supply: 1000000, image: 'https://placehold.co/64x64/00ffaa/ffffff?text=BT1', price: 0.1, stage: 'trading' },
        { name: 'Bot Token 2', ticker: 'BT2', supply: 500000, image: 'https://placehold.co/64x64/ff4d4d/ffffff?text=BT2', price: 0.2, stage: 'trading' }
      ];
      botTokens.forEach(token => {
        // Only add if token doesn't already exist
        if (!tokens.find(t => t.ticker === token.ticker)) {
          tokens.push({
            ...token,
            originalSupply: token.supply,
            burned: 0,
            marketCap: token.price * token.supply,
            creatorWallet: ethers.Wallet.createRandom().address,
            creatorFee: 1,
            contributors: [],
            airdropPercentage: 10,
            airdropPool: token.supply * 0.1, // 10% of supply for airdrop
            vestingDuration: 30 * 24 * 60 * 60 * 1000, // 30 days vesting
            vestingStart: Date.now(), // Vesting starts immediately for bot tokens
            claimed: {},
            minContribution: 0.1,
            maxContribution: 10,
            boost: 0,
            transactions: [],
            priceHistory: [{ timestamp: new Date().toLocaleString(), price: token.price }]
          });
          // Initialize liquidity pool for bot tokens
          liquidityPools[token.ticker] = {
            avax: token.supply * token.price / AVAX_PRICE, // AVAX equivalent of tokens in pool
            token: token.supply * 0.9, // 90% of supply in liquidity
            totalShares: Math.sqrt((token.supply * token.price / AVAX_PRICE) * (token.supply * 0.9)),
            userShares: {},
            fees: {}
          };
        }
      });
      updateTokenLists(); // Update token lists after adding bot tokens
    }

    /**
     * Simulates various bot activities (trading, burning, contributions, chat, quests, proposals).
     * This function runs periodically to make the app feel dynamic.
     */
    function simulateBotActivity() {
      tokens.forEach(token => {
        // Random chance for a bot action
        if (Math.random() < 0.3) {
          const pool = liquidityPools[token.ticker];
          // Ensure a liquidity pool exists for trading actions
          if (!pool) return;

          const action = Math.random();
          if (action < 0.3 && token.stage === 'trading') {
            // Simulate bot buying
            const avaxAmount = (Math.random() * 5).toFixed(2);
            const tokenAmount = (parseFloat(avaxAmount) / token.price).toFixed(2);
            pool.avax += parseFloat(avaxAmount);
            pool.token -= parseFloat(tokenAmount);
            token.price = pool.avax / pool.token * AVAX_PRICE;
            token.marketCap = token.price * (token.supply - token.burned);
            token.transactions.push({
              type: 'Bot Buy',
              amount: `${tokenAmount} ${token.ticker}`,
              timestamp: new Date().toLocaleString()
            });
            token.priceHistory.push({ timestamp: new Date().toLocaleString(), price: token.price });
          } else if (action < 0.6 && token.stage === 'trading') {
            // Simulate bot selling
            const tokenAmount = (Math.random() * 1000).toFixed(2);
            if (parseFloat(tokenAmount) <= pool.token) { // Ensure enough tokens in pool to sell
              const avaxAmount = (parseFloat(tokenAmount) * token.price / AVAX_PRICE).toFixed(2);
              pool.avax -= parseFloat(avaxAmount);
              pool.token += parseFloat(tokenAmount);
              token.price = pool.avax / pool.token * AVAX_PRICE;
              token.marketCap = token.price * (token.supply - token.burned);
              token.transactions.push({
                type: 'Bot Sell',
                amount: `${tokenAmount} ${token.ticker}`,
                timestamp: new Date().toLocaleString()
              });
              token.priceHistory.push({ timestamp: new Date().toLocaleString(), price: token.price });
            }
          } else if (action < 0.8) {
            // Simulate bot burning tokens
            const amount = (Math.random() * 100).toFixed(2);
            if (parseFloat(amount) <= token.supply - token.burned) {
              token.supply -= parseFloat(amount);
              token.burned += parseFloat(amount);
              token.marketCap = token.price * (token.supply - token.burned);
              token.transactions.push({
                type: 'Bot Burn',
                amount: `${amount} ${token.ticker}`,
                timestamp: new Date().toLocaleString()
              });
            }
          } else if (token.stage === 'whitelist') {
            // Simulate bot contributions to whitelist
            const amount = (Math.random() * (token.maxContribution - token.minContribution) + token.minContribution).toFixed(2);
            token.contributors.push({ wallet: ethers.Wallet.createRandom().address, amount: parseFloat(amount) });
            token.transactions.push({
              type: 'Bot Contribution',
              amount: `${amount} AVAX`,
              timestamp: new Date().toLocaleString()
            });
          }

          // Simulate bot chat messages
          if (Math.random() < 0.2) {
            if (!chatMessages[token.ticker]) chatMessages[token.ticker] = [];
            chatMessages[token.ticker].push({
              user: ethers.Wallet.createRandom().address,
              text: `Bot message about ${token.ticker}!`,
              timestamp: new Date().toLocaleString(),
              reactions: { positive: Math.floor(Math.random() * 5), negative: Math.floor(Math.random() * 5) }
            });
          }
          // Simulate bot creating quests
          if (Math.random() < 0.1) {
            quests.push({
              id: `quest_${Date.now()}_${token.ticker}`,
              ticker: token.ticker,
              description: `Bot quest for ${token.ticker}`,
              reward: (Math.random() * 100).toFixed(2),
              rewardType: Math.random() < 0.5 ? token.ticker : 'AVAX'
            });
          }
          // Simulate bot creating proposals
          if (Math.random() < 0.1) {
            proposals.push({
              id: `prop_${Date.now()}_${token.ticker}`,
              ticker: token.ticker,
              text: `Bot proposal for ${token.ticker}`,
              options: ['Option A', 'Option B'],
              votingPower: [Math.random() * 100, Math.random() * 100],
              reward: (Math.random() * 0.5).toFixed(2)
            });
          }
        }
      });
      // Update UI elements that might be affected by bot activity
      updateTokenLists();
      updateTokenDetails();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      checkPriceAlerts();
      checkLimitOrders();
    }

    /**
     * Updates the swap section with available trading tokens.
     */
    function updateSwapSection() {
      const swapTokenSelect = document.getElementById('swapToken');
      swapTokenSelect.innerHTML = '<option value="">Select Token</option>';
      tokens.filter(t => t.stage === 'trading').forEach(token => {
        swapTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker} (${tokenBalances[token.ticker] || 0})</option>`;
      });
    }

    // Initialize application when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', () => {
      initialize();
      // Periodically check for whitelist end and transition tokens to trading stage
      setInterval(() => {
        tokens.forEach(token => {
          if (token.stage === 'whitelist' && Date.now() >= token.whitelistEnd) {
            token.stage = 'trading';
            const totalContributed = token.contributors.reduce((sum, c) => sum + c.amount, 0);
            const tradingSupply = token.supply * (1 - token.airdropPercentage / 100);
            token.price = totalContributed / tradingSupply; // Calculate final price
            token.marketCap = token.price * (token.supply - token.burned);
            token.airdropPool = token.originalSupply * (token.airdropPercentage / 100);
            token.claimed = {};
            // Initialize liquidity pool for the newly trading token
            liquidityPools[token.ticker] = {
              avax: totalContributed,
              token: tradingSupply,
              totalShares: Math.sqrt(totalContributed * tradingSupply),
              userShares: {},
              fees: {}
            };
            // Distribute tokens to contributors
            token.contributors.forEach(c => {
              const tokensReceived = (c.amount / totalContributed) * tradingSupply;
              tokenBalances[c.wallet] = (parseFloat(tokenBalances[c.wallet] || 0) + tokensReceived).toFixed(2);
            });
            token.vestingStart = Date.now(); // Start vesting
            token.priceHistory.push({ timestamp: new Date().toLocaleString(), price: token.price }); // Add initial trading price
            notify(`${token.ticker} whitelist ended. Trading started!`);
          }
        });
        // Update UI elements after potential stage transitions
        updateTokenLists();
        updateTokenDetails();
        updateBalanceModal();
        updatePortfolio();
      }, 1000); // Check every second

      // Event listener for modal content scrolling (ensures smooth scrolling)
      document.querySelectorAll('.modal-content').forEach(modal => {
        modal.addEventListener('scroll', () => {
          // This line effectively does nothing but can be a placeholder for custom scroll logic if needed
          // For native smooth scrolling, simply having `overflow-y: auto` is usually sufficient.
          modal.scrollTop = modal.scrollTop;
        });
      });
    });

    // Chart.js global default configurations for consistent styling
    if (typeof Chart !== 'undefined') {
      Chart.defaults.font.family = 'Inter';
      Chart.defaults.font.size = 14;
      Chart.defaults.color = '#ffffff';
      Chart.defaults.plugins.legend.labels.boxWidth = 20;
    }
  </script>
</body>
</html>
