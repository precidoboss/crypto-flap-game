<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WL LAUNCHER</title>
  <!-- Tailwind CSS for utility-first styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Ethers.js for Ethereum blockchain interactions (simulated here) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" xintegrity="sha512-J3ZEBLi4nVWXLG7X2G2G6I8y5H2Z8g8cOsgcry1TyXBRcS3PXmRPW59Leverlyk5T3w29f4b0N0OQA9A77+RHVw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <!-- Chart.js for dynamic data visualization -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Google Fonts for Poppins and Inter, providing a modern look -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="min-h-screen text-white font-poppins bg-gradient-to-b from-gray-900 to-gray-700 transition-colors duration-300" id="app">
  <!-- Header Section: Always visible at the top -->
  <header class="w-full bg-gradient-to-r from-purple-600 to-blue-600 p-4 flex justify-between items-center sticky top-0 z-10 shadow-lg">
    <h1 class="text-3xl font-extrabold text-white">WL LAUNCHER</h1>
    <div class="flex items-center space-x-2">
      <button id="initializeBtn" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">Sign In</button>
      <button id="notificationBtn" class="relative text-2xl">üîî<span id="notificationCount" class="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-4 w-4 flex items-center justify-center hidden">0</span></button>
      <button id="menuBtn" class="text-2xl">‚ò∞</button>
    </div>
  </header>

  <!-- Notification Dropdown -->
  <div id="notificationDropdown" class="hidden absolute right-4 top-14 bg-gray-800 p-4 rounded-lg shadow-lg w-64 max-h-96 overflow-y-auto z-20">
    <h3 class="text-lg font-semibold mb-2">Notifications</h3>
    <div id="notificationsList"></div>
  </div>

  <!-- Menu Modal: Hidden by default, appears on menu button click -->
  <div id="menuModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-full max-w-md animate-slide-up">
      <h2 class="text-xl font-semibold mb-4">Menu</h2>
      <button id="settingsBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded mb-2 transition-transform transform hover:scale-105">Settings</button>
      <button id="balanceBtn" class="w-full bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded mb-2 transition-transform transform hover:scale-105">Balances</button>
      <button id="portfolioBtn" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white px-4 py-2 rounded mb-2 transition-transform transform hover:scale-105">Portfolio</button>
      <button id="stakingBtn" class="w-full bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded mb-2 transition-transform transform hover:scale-105">Staking</button>
      <button id="autoTradeBtn" class="w-full bg-pink-600 hover:bg-pink-700 text-white px-4 py-2 rounded mb-2 transition-transform transform hover:scale-105">Automated Trading</button>
      <button id="closeMenu" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">Close</button>
    </div>
  </div>

  <!-- Settings Modal: Hidden by default, accessible from Menu -->
  <div id="settingsModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-full max-w-md animate-slide-up">
      <h2 class="text-xl font-semibold mb-4">Settings</h2>
      <div class="mb-4">
        <label class="block text-sm font-medium">Theme</label>
        <select id="themeSelect" class="w-full p-2 bg-gray-700 rounded">
          <option value="dark">Dark</option>
          <option value="light">Light</option>
          <option value="neon">Neon</option>
        </select>
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium">Notifications</label>
        <input id="notifications" type="checkbox" class="mr-2" checked> Enable notifications
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium">Sound Effects</label>
        <input id="soundEffects" type="checkbox" class="mr-2" checked> Enable sound effects
      </div>
      <button id="closeSettings" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">Close</button>
    </div>
  </div>

  <!-- Balance Modal: Hidden by default, accessible from Menu -->
  <div id="balanceModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-full max-w-md animate-slide-up">
      <h2 class="text-xl font-semibold mb-4">Your Balances</h2>
      <p><strong>AVAX:</strong> <span id="balanceAvax">0</span> AVAX (~<span id="balanceAvaxValue">0</span> USD)</p>
      <div id="tokenBalances"></div>
      <p class="mt-4"><strong>Total Value:</strong> <span id="totalValue">0</span> USD</p>
      <button id="closeBalance" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded mt-4 transition-transform transform hover:scale-105">Close</button>
    </div>
  </div>

  <!-- Staking Modal: Hidden by default, accessible from Menu -->
  <div id="stakingModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-full max-w-md animate-slide-up">
      <button id="backStaking" class="mb-4 text-blue-400 font-semibold">‚Üê Back</button>
      <h2 class="text-xl font-semibold mb-4">Staking</h2>
      <div class="mb-4">
        <h3 class="text-lg font-semibold">Supply Tokens</h3>
        <select id="supplyToken" class="w-full p-2 bg-gray-700 rounded mb-2"></select>
        <select id="supplyAsset" class="w-full p-2 bg-gray-700 rounded mb-2">
          <option value="AVAX">AVAX</option>
        </select>
        <input id="supplyAmount" type="number" step="0.01" class="w-full p-2 bg-gray-700 rounded mb-2" placeholder="Amount">
        <input id="supplyAPR" type="number" step="0.1" class="w-full p-2 bg-gray-700 rounded mb-2" placeholder="APR (%)">
        <button id="supplyBtn" class="w-full bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">Supply</button>
      </div>
      <div>
        <h3 class="text-lg font-semibold">Stake Tokens</h3>
        <div id="stakePools"></div>
      </div>
      <button id="closeStaking" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded mt-4 transition-transform transform hover:scale-105">Close</button>
    </div>
  </div>

  <!-- Automated Trading Modal -->
  <div id="autoTradeModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-full max-w-md animate-slide-up">
      <button id="backAutoTrade" class="mb-4 text-blue-400 font-semibold">‚Üê Back</button>
      <h2 class="text-xl font-semibold mb-4">Automated Trading</h2>
      <div class="mb-4">
        <h3 class="text-lg font-semibold">Setup Auto-Buy</h3>
        <select id="autoBuyToken" class="w-full p-2 bg-gray-700 rounded mb-2"></select>
        <input id="autoBuyAmount" type="number" step="0.01" class="w-full p-2 bg-gray-700 rounded mb-2" placeholder="AVAX per trade">
        <div class="flex space-x-2">
          <input id="autoBuyInterval" type="number" class="w-full p-2 bg-gray-700 rounded" placeholder="Interval">
          <select id="autoBuyUnit" class="p-2 bg-gray-700 rounded">
            <option value="seconds">Seconds</option>
            <option value="minutes">Minutes</option>
          </select>
        </div>
        <button id="startAutoBuy" class="w-full bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded mt-2 transition-transform transform hover:scale-105">Start Auto-Buy</button>
      </div>
      <div class="mb-4">
        <h3 class="text-lg font-semibold">Setup Auto-Sell</h3>
        <select id="autoSellToken" class="w-full p-2 bg-gray-700 rounded mb-2"></select>
        <input id="autoSellAmount" type="number" step="0.01" class="w-full p-2 bg-gray-700 rounded mb-2" placeholder="Tokens per trade">
        <div class="flex space-x-2">
          <input id="autoSellInterval" type="number" class="w-full p-2 bg-gray-700 rounded" placeholder="Interval">
          <select id="autoSellUnit" class="p-2 bg-gray-700 rounded">
            <option value="seconds">Seconds</option>
            <option value="minutes">Minutes</option>
          </select>
        </div>
        <button id="startAutoSell" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded mt-2 transition-transform transform hover:scale-105">Start Auto-Sell</button>
      </div>
      <div>
        <h3 class="text-lg font-semibold">Active Auto-Trades</h3>
        <div id="activeAutoTrades"></div>
      </div>
      <button id="closeAutoTrade" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded mt-4 transition-transform transform hover:scale-105">Close</button>
    </div>
  </div>

  <!-- Main Content Sections: Displayed on the main page -->
  <main class="w-full max-w-4xl p-4 space-y-4">
    <!-- Launch Token Section: Collapsible card for launching tokens -->
    <section id="launchSection" class="bg-gradient-to-r from-purple-700 to-pink-600 p-6 rounded-lg shadow-lg">
      <div class="flex justify-between items-center">
        <h2 class="text-2xl font-extrabold">Launch Token</h2>
        <button class="toggleSection text-xl">‚àí</button>
      </div>
      <div class="sectionContent">
        <button id="launchTokenBtn" class="w-full bg-neon-green hover:bg-neon-green-dark text-black font-bold px-4 py-3 rounded-lg mt-4 transition-transform transform hover:scale-105">Launch New Token</button>
      </div>
    </section>

    <!-- Whitelist Stage Section: Collapsible card for tokens in whitelist -->
    <section id="whitelistSection" class="bg-gradient-to-r from-blue-700 to-purple-600 p-6 rounded-lg shadow-lg">
      <div class="flex justify-between items-center">
        <h2 class="text-2xl font-extrabold">Whitelist Stage</h2>
        <button class="toggleSection text-xl">‚àí</button>
      </div>
      <div class="sectionContent" id="whitelistTokens"></div>
    </section>

    <!-- Trading Stage Section: Collapsible card for tokens in trading -->
    <section id="tradingSection" class="bg-gradient-to-r from-pink-700 to-blue-600 p-6 rounded-lg shadow-lg">
      <div class="flex justify-between items-center">
        <h2 class="text-2xl font-extrabold">Trading Stage</h2>
        <button class="toggleSection text-xl">‚àí</button>
      </div>
      <div class="sectionContent" id="tradingTokens"></div>
    </section>

    <!-- Trending Tokens Section: Collapsible card for trending tokens -->
    <section id="trendingSection" class="bg-gradient-to-r from-purple-600 to-pink-700 p-6 rounded-lg shadow-lg">
      <div class="flex justify-between items-center">
        <h2 class="text-2xl font-extrabold">Trending Tokens</h2>
        <button class="toggleSection text-xl">‚àí</button>
      </div>
      <div class="sectionContent" id="trendingTokens"></div>
    </section>
  </main>

  <!-- Launch Token Page: Full page for launching a new token -->
  <div id="launchPage" class="hidden w-full max-w-4xl p-4 animate-fade-in">
    <button id="backLaunch" class="mb-4 text-blue-400 font-semibold">‚Üê Back</button>
    <h2 class="text-2xl font-extrabold mb-4">Launch a New Token</h2>
    <form id="launchForm" class="bg-gray-800 p-6 rounded-lg shadow-lg">
      <div class="mb-4">
        <label class="block text-sm font-medium">Token Name</label>
        <input id="tokenName" type="text" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="e.g., MyToken" required>
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium">Ticker</label>
        <input id="tokenTicker" type="text" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="e.g., MTK" required>
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium">Total Supply</label>
        <input id="tokenSupply" type="number" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="e.g., 1000000" required>
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium">Image URL (Imgur)</label>
        <input id="tokenImage" type="text" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="e.g., https://imgur.com/abc123">
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium">Twitter Link</label>
        <input id="twitterLink" type="text" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="e.g., https://twitter.com/project">
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium">Discord Link</label>
        <input id="discordLink" type="text" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="e.g., https://discord.gg/project">
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium">Whitelist Duration</label>
        <div class="flex space-x-2">
          <input id="whitelistDuration" type="number" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="e.g., 24" required>
          <select id="durationUnit" class="p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green">
            <option value="hours">Hours</option>
            <option value="minutes">Minutes</option>
            <option value="seconds">Seconds</option>
          </select>
        </div>
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium">Min Contribution (AVAX)</label>
        <input id="minContribution" type="number" step="0.01" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="e.g., 0.1" required>
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium">Max Contribution (AVAX)</label>
        <input id="maxContribution" type="number" step="0.01" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="Max 500 AVAX" max="500" required>
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium">Airdrop Percentage (up to 90%)</label>
        <input id="airdropPercentage" type="number" step="0.1" max="90" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="e.g., 30" required>
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium">Vesting Duration</label>
        <div class="flex space-x-2">
          <input id="vestingDuration" type="number" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="e.g., 6" required>
          <select id="vestingUnit" class="p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green">
            <option value="seconds">Seconds</option>
            <option value="minutes">Minutes</option>
            <option value="hours">Hours</option>
            <option value="days">Days</option>
            <option value="months">Months</option>
          </select>
        </div>
      </div>
      <button type="submit" class="w-full bg-neon-green hover:bg-neon-green-dark text-black font-bold px-4 py-2 rounded transition-transform transform hover:scale-105">Launch Token</button>
    </form>
  </div>

  <!-- Token Details Page: Displays detailed information about a selected token -->
  <div id="tokenDetailsPage" class="hidden w-full max-w-4xl p-4 animate-fade-in">
    <button id="backTokenDetails" class="mb-4 text-blue-400 font-semibold">‚Üê Back</button>
    <h2 class="text-2xl font-extrabold mb-4">Token Details</h2>
    <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
      <div class="flex items-center mb-4">
        <img id="tokenImg" class="w-24 h-24 rounded-full mr-4 border-2 border-neon-green" src="" alt="Token Image">
        <div>
          <p><strong>Name:</strong> <span id="displayTokenName"></span></p>
          <p><strong>Ticker:</strong> <span id="displayTokenTicker"></span></p>
          <p><strong>Total Supply:</strong> <span id="displayTokenSupply"></span></p>
          <p><strong>Market Cap:</strong> <span id="marketCap"></span> USD</p>
          <p><strong>Creator Wallet:</strong> <span id="displayCreatorWallet"></span></p>
          <p><strong>Stage:</strong> <span id="currentStage"></span></p>
          <p><strong>Whitelist Timer:</strong> <span id="whitelistTimer"></span></p>
          <p><strong>Social:</strong> <a id="twitterLinkDisplay" class="text-blue-400 hover:underline" href="#">Twitter</a> | <a id="discordLinkDisplay" class="text-blue-400 hover:underline" href="#">Discord</a></p>
          <p><strong>Audit Status:</strong> <span class="text-green-400">Simulated Audit Passed</span></p>
          <p><strong>Boost Status:</strong> <span id="boostStatus">Not Boosted</span></p>
          <p><strong>Tokenomics:</strong> <span id="tokenomics"></span></p>
        </div>
      </div>
      <div id="snipeSection" class="mb-4 hidden">
        <h3 class="text-lg font-semibold mb-2">Snipe Token</h3>
        <input id="snipeAmount" type="number" step="0.01" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green mb-2" placeholder="AVAX to snipe">
        <button id="snipeBtn" class="w-full bg-yellow-600 hover:bg-yellow-700 text-black px-4 py-2 rounded transition-transform transform hover:scale-105">Setup Snipe</button>
      </div>
      <div id="contributionSection" class="mb-4 hidden">
        <canvas id="contributionChart" class="w-full h-40"></canvas>
        <input id="contributeAmount" type="number" step="0.01" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green mb-2" placeholder="Amount in AVAX">
        <button id="contributeBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">Contribute</button>
        <p class="text-sm text-gray-400 mt-2">Estimated Gas Fee: <span id="gasFee">0.01</span> AVAX</p>
        <p>Total Contributed: <span id="totalContributed">0</span> AVAX (~<span id="totalContributedValue">0</span> USD)</p>
      </div>
      <div id="tradingInterface" class="mb-4 hidden">
        <canvas id="priceChart" class="w-full h-64"></canvas>
        <div class="mb-4">
          <label class="block text-sm font-medium">Pay with AVAX</label>
          <input id="tradeAvaxAmount" type="number" step="0.01" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="e.g., 10 AVAX">
        </div>
        <div class="mb-4">
          <label class="block text-sm font-medium">Receive <span id="receiveTokenTicker"></span></label>
          <input id="tradeTokenAmount" type="number" step="0.01" class="w-full p-2 bg-gray-700 rounded" placeholder="Tokens" disabled>
        </div>
        <div class="mb-4">
          <label class="block text-sm font-medium">Slippage Tolerance</label>
          <select id="slippageSelect" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green">
            <option value="0.5">0.5%</option>
            <option value="1">1%</option>
            <option value="3">3%</option>
          </select>
        </div>
        <p class="text-sm text-gray-400 mb-4">Estimated Gas Fee: <span id="tradeGasFee">0.02</span> AVAX</p>
        <button id="tradeBtn" class="w-full bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">Swap</button>
      </div>
      <div id="liquiditySection" class="mb-4 hidden">
        <h3 class="text-lg font-semibold mb-2">Liquidity Pool</h3>
        <p>TVL: <span id="poolTVL">0</span> USD</p>
        <p>Your Share: <span id="poolShare">0</span>%</p>
        <p>Fees Earned: <span id="feesEarned">0</span> AVAX</p>
        <div class="mb-4">
          <label class="block text-sm font-medium">Supply Type</label>
          <select id="supplyType" class="w-full p-2 bg-gray-700 rounded mb-2">
            <option value="single">Single-Sided (AVAX)</option>
            <option value="dual">Dual-Sided (AVAX + Token)</option>
          </select>
        </div>
        <div id="singleSupply" class="mb-4">
          <label class="block text-sm font-medium">AVAX Amount</label>
          <input id="avaxAmount" type="number" step="0.01" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="e.g., 10 AVAX">
        </div>
        <div id="dualSupply" class="mb-4 hidden">
          <label class="block text-sm font-medium">AVAX Amount</label>
          <input id="dualAvaxAmount" type="number" step="0.01" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green mb-2" placeholder="e.g., 10 AVAX">
          <label class="block text-sm font-medium"><span id="poolTokenTicker"></span> Amount</label>
          <input id="dualTokenAmount" type="number" step="0.01" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="Tokens">
        </div>
        <button id="addLiquidityBtn" class="w-full bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">Add Liquidity</button>
        <button id="removeLiquidityBtn" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded mt-2 transition-transform transform hover:scale-105">Remove Liquidity</button>
      </div>
      <div id="burnSection" class="mb-4 hidden">
        <h3 class="text-lg font-semibold mb-2">Token Burn</h3>
        <p>Total Burned: <span id="totalBurned">0</span> <span id="burnTicker"></span></p>
        <p>Supply Remaining: <span id="supplyRemaining">100</span>%</p>
        <canvas id="burnChart" class="w-full h-40"></canvas>
        <input id="burnAmount" type="number" step="0.01" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green mb-2" placeholder="Tokens to burn">
        <button id="burnBtn" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">Burn Tokens</button>
      </div>
      <div id="airdropSection" class="mb-4 hidden">
        <h3 class="text-lg font-semibold mb-2">Airdrop Claim</h3>
        <p>Airdrop Amount: <span id="airdropTotal">0</span> <span id="airdropTicker"></span></p>
        <p>Claimable: <span id="airdropClaimable">0</span> <span id="airdropTicker2"></span></p>
        <p>Vesting Progress: <span id="vestingProgress">0</span>%</p>
        <button id="claimAirdropBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">Claim Airdrop</button>
      </div>
      <div class="mb-4">
        <button id="boostBtn" class="w-full bg-yellow-600 hover:bg-yellow-700 text-black px-4 py-2 rounded transition-transform transform hover:scale-105">Boost Token</button>
      </div>
      <div class="mb-4">
        <button id="viewTransactionsBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">View Transactions</button>
      </div>
      <div class="mb-4">
        <button id="viewChatBtn" class="w-full bg-pink-600 hover:bg-pink-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">View Community Chat</button>
      </div>
    </div>
  </div>

  <!-- Portfolio Page -->
  <div id="portfolioPage" class="hidden w-full max-w-4xl p-4 animate-fade-in">
    <button id="backPortfolio" class="mb-4 text-blue-400 font-semibold">‚Üê Back</button>
    <h2 class="text-2xl font-extrabold mb-4">Portfolio</h2>
    <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
      <p class="text-lg font-semibold mb-2">Total Value: <span id="portfolioValue">0</span> USD</p>
      <p class="text-sm mb-4">Profit/Loss: <span id="portfolioPnL" class="text-green-400">0</span> USD</p>
      <div class="mb-4">
        <canvas id="portfolioPieChart" class="w-full h-64"></canvas>
      </div>
      <div class="mb-4">
        <canvas id="portfolioValueChart" class="w-full h-64"></canvas>
      </div>
      <div id="portfolioHoldings" class="mt-4"></div>
      <button id="exportPortfolio" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded mt-4 transition-transform transform hover:scale-105">Export Portfolio (CSV)</button>
    </div>
  </div>

  <!-- Transaction History Page: Displays a token's transaction history -->
  <div id="transactionPage" class="hidden w-full max-w-4xl p-4 animate-fade-in">
    <button id="backTransactions" class="mb-4 text-blue-400 font-semibold">‚Üê Back</button>
    <h2 class="text-2xl font-extrabold mb-4">Transaction History</h2>
    <div id="transactionHistory" class="bg-gray-800 p-6 rounded-lg shadow-lg"></div>
  </div>

  <!-- Community Chat Page: Displays a token's community chat -->
  <div id="chatPage" class="hidden w-full max-w-4xl p-4 animate-fade-in">
    <button id="backChat" class="mb-4 text-blue-400 font-semibold">‚Üê Back</button>
    <h2 class="text-2xl font-extrabold mb-4">Community Chat</h2>
    <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
      <p>Sentiment: <span id="chatSentiment" class="font-semibold">Neutral</span></p>
      <div id="chatMessages" class="h-64 overflow-y-auto mb-4 bg-gray-900 p-2 rounded"></div>
      <input id="chatInput" type="text" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green mb-2" placeholder="Type a message...">
      <button id="sendChat" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">Send</button>
    </div>
  </div>

  <!-- Trading Confirmation Modal: Appears before a trade is executed -->
  <div id="tradeConfirmModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-full max-w-md animate-slide-up">
      <h2 class="text-xl font-semibold mb-4">Confirm Swap</h2>
      <p>Pay: <span id="confirmAvaxAmount"></span> AVAX</p>
      <p>Receive: <span id="confirmTokenAmount"></span> <span id="confirmTokenTicker"></span></p>
      <p>Slippage: <span id="confirmSlippage"></span>%</p>
      <p>Gas Fee: <span id="confirmGasFee"></span> AVAX</p>
      <div class="mt-4 flex space-x-2">
        <button id="confirmTradeBtn" class="flex-1 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">Confirm</button>
        <button id="cancelTradeBtn" class="flex-1 bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Boost Modal: Appears when boosting a token -->
  <div id="boostModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-full max-w-md animate-slide-up">
      <h2 class="text-xl font-semibold mb-4">Boost Token</h2>
      <p>Boost <span id="boostTokenTicker"></span> to improve its trending rank.</p>
      <div class="mb-4">
        <label class="block text-sm font-medium">Boost Amount (<span id="boostToken"></span>)</label>
        <input id="boostAmount" type="number" step="0.01" class="w-full p-2 bg-gray-700 rounded focus:ring-2 focus:ring-neon-green" placeholder="e.g., 100 for Rank 3">
      </div>
      <p class="text-sm text-gray-400 mb-4">100 for Rank 3, 200 for Rank 2, 300 for Rank 1</p>
      <div class="mt-4 flex space-x-2">
        <button id="confirmBoostBtn" class="flex-1 bg-yellow-600 hover:bg-yellow-700 text-black px-4 py-2 rounded transition-transform transform hover:scale-105">Confirm</button>
        <button id="cancelBoostBtn" class="flex-1 bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded transition-transform transform hover:scale-105">Cancel</button>
      </div>
    </div>
  </div>

  <style>
    /* Custom CSS for animations and neon green color */
    .animate-fade-in {
      animation: fadeIn 0.5s ease-in;
    }
    .animate-slide-up {
      animation: slideUp 0.3s ease-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    .bg-neon-green { background-color: #00ffaa; }
    .bg-neon-green-dark { background-color: #00cc88; }
    .focus:ring-neon-green { --tw-ring-color: #00ffaa; }
    .shadow-lg { box-shadow: 0 10px 15px -3px rgba(0, 255, 170, 0.2), 0 4px 6px -2px rgba(0, 255, 170, 0.1); }

    /* Custom styles for the message and input boxes */
    .custom-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .custom-modal-content {
      background-color: #16213e;
      color: #fff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      text-align: center;
      max-width: 80%;
      word-wrap: break-word;
    }
    .custom-modal-content input {
      width: calc(100% - 20px);
      padding: 8px;
      margin: 10px 0;
      border-radius: 5px;
      border: none;
      color: #333; /* Text color for input field */
    }
    .custom-modal-content button {
      background: #e94560;
      color: #fff;
      border: none;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 10px;
      margin-right: 10px;
    }
    .custom-modal-content button:last-child {
      margin-right: 0;
    }
  </style>

  <script>
    // Custom Message Box
    function showMessageBox(message) {
      const overlay = document.createElement("div");
      overlay.className = "custom-modal-overlay";
      overlay.innerHTML = `
        <div class="custom-modal-content">
          <p>${message}</p>
          <button onclick="this.parentNode.parentNode.remove()">OK</button>
        </div>
      `;
      document.body.appendChild(overlay);
    }

    // Custom Input Box (for prompt replacement)
    function showInputBox(promptText, callback) {
      const overlay = document.createElement("div");
      overlay.className = "custom-modal-overlay";
      overlay.innerHTML = `
        <div class="custom-modal-content">
          <p>${promptText}</p>
          <input type="text" id="customInput">
          <button id="customInputOk">OK</button>
          <button onclick="this.parentNode.parentNode.remove()">Cancel</button>
        </div>
      `;
      document.body.appendChild(overlay);

      document.getElementById("customInputOk").onclick = () => {
        const value = document.getElementById("customInput").value;
        overlay.remove();
        callback(value);
      };
      document.getElementById("customInput").focus();
    }

    // Custom Confirm Box
    function showConfirmBox(message, callback) {
      const overlay = document.createElement("div");
      overlay.className = "custom-modal-overlay";
      overlay.innerHTML = `
        <div class="custom-modal-content">
          <p>${message}</p>
          <button id="customConfirmOk">Yes</button>
          <button id="customConfirmCancel">No</button>
        </div>
      `;
      document.body.appendChild(overlay);

      document.getElementById("customConfirmOk").onclick = () => {
        overlay.remove();
        callback(true);
      };
      document.getElementById("customConfirmCancel").onclick = () => {
        overlay.remove();
        callback(false);
      };
    }

    // Simulated state variables for the application
    let wallet = null; // Stores the generated wallet (address and private key)
    let avaxBalance = 0; // User's simulated AVAX balance
    let tokens = []; // Array to store all launched token data
    let tokenBalances = {}; // User's balances for various tokens (key: ticker, value: amount)
    let stakingPools = {}; // Simulated staking pools for tokens
    let liquidityPools = {}; // Simulated liquidity pools for tokens
    let autoTrades = []; // Stores active automated trading strategies
    let portfolioHistory = []; // Stores historical portfolio value for charting
    let notifications = []; // Stores recent notifications
    let currentToken = null; // The token currently being viewed in detail
    const AVAX_PRICE = 30; // Simulated price of AVAX in USD
    const clickSound = new Audio('https://freesound.org/data/previews/171/171671_2437358-lq.mp3'); // Sound effect for clicks

    // --- Initialization ---
    // Called when the page loads to set up initial state
    function initialize() {
      // Generate a random wallet for the user
      wallet = ethers.Wallet.createRandom();
      // Assign a random initial AVAX balance to the user
      avaxBalance = (Math.random() * 990 + 10).toFixed(2); // Random value between 10 and 1000 AVAX
      // Add initial portfolio history entry
      portfolioHistory.push({ timestamp: new Date().toLocaleString(), value: parseFloat(avaxBalance) * AVAX_PRICE, costBasis: parseFloat(avaxBalance) * AVAX_PRICE });
      // Update the AVAX balance display in the balance modal
      document.getElementById('balanceAvax').textContent = avaxBalance;
      document.getElementById('balanceAvaxValue').textContent = (parseFloat(avaxBalance) * AVAX_PRICE).toFixed(2);
      // Update the entire balance modal
      updateBalanceModal();
      // Update portfolio display
      updatePortfolio();
      // Simulate some initial bot-launched tokens to populate the lists
      simulateBotTokens();
      // Set up a recurring interval for general bot activity (buying, selling, FUD, etc.)
      setInterval(simulateBotActivity, 30000); // Every 30 seconds
      // Update portfolio value periodically
      setInterval(updatePortfolio, 60000); // Update portfolio every minute
    }

    // --- Sound Effects ---
    // Plays a click sound if sound effects are enabled in settings
    function playSound() {
      if (document.getElementById('soundEffects').checked) {
        clickSound.play();
      }
    }

    // --- Notification System ---
    // Displays a notification message if notifications are enabled in settings
    function notify(message) {
      if (document.getElementById('notifications').checked) {
        notifications.push({ message, timestamp: new Date().toLocaleString() });
        updateNotifications();
      }
    }

    // Updates the notification count and lists them in the dropdown
    function updateNotifications() {
      const notificationsList = document.getElementById('notificationsList');
      notificationsList.innerHTML = '';
      // Display notifications in reverse chronological order
      notifications.slice().reverse().forEach(n => {
        notificationsList.innerHTML += `<p class="text-sm text-gray-400">${n.timestamp}: ${n.message}</p>`;
      });
      const count = notifications.length;
      document.getElementById('notificationCount').textContent = count;
      document.getElementById('notificationCount').classList.toggle('hidden', count === 0);
    }

    // Event listener for Notification button to toggle dropdown
    document.getElementById('notificationBtn').addEventListener('click', () => {
      document.getElementById('notificationDropdown').classList.toggle('hidden');
      playSound();
    });

    // --- Menu Modal Logic ---
    document.getElementById('menuBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.remove('hidden');
      playSound();
    });
    document.getElementById('closeMenu').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      playSound();
    });

    // --- Settings Modal Logic ---
    document.getElementById('settingsBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden'); // Close menu first
      document.getElementById('settingsModal').classList.remove('hidden'); // Open settings
      playSound();
    });
    document.getElementById('closeSettings').addEventListener('click', () => {
      document.getElementById('settingsModal').classList.add('hidden'); // Close settings
      // Apply theme changes based on selection
      const theme = document.getElementById('themeSelect').value;
      document.getElementById('app').classList.toggle('bg-gradient-to-b from-gray-900 to-gray-700', theme === 'dark');
      document.getElementById('app').classList.toggle('bg-gradient-to-b from-gray-100 to-gray-300', theme === 'light');
      document.getElementById('app').classList.toggle('bg-gradient-to-b from-purple-900 to-pink-700', theme === 'neon');
      document.getElementById('app').classList.toggle('text-white', theme !== 'light');
      document.getElementById('app').classList.toggle('text-black', theme === 'light');
      playSound();
    });

    // --- Balance Modal Logic ---
    document.getElementById('balanceBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden'); // Close menu first
      updateBalanceModal(); // Refresh balances before opening
      document.getElementById('balanceModal').classList.remove('hidden'); // Open balance modal
      playSound();
    });
    document.getElementById('closeBalance').addEventListener('click', () => {
      document.getElementById('balanceModal').classList.add('hidden'); // Close balance modal
      playSound();
    });

    // Updates the display of AVAX and token balances in the balance modal
    function updateBalanceModal() {
      document.getElementById('balanceAvax').textContent = parseFloat(avaxBalance).toFixed(2);
      document.getElementById('balanceAvaxValue').textContent = (parseFloat(avaxBalance) * AVAX_PRICE).toFixed(2);
      let totalValue = parseFloat(avaxBalance) * AVAX_PRICE;
      let tokenHtml = '';
      // Iterate through each token the user holds
      for (const [ticker, balance] of Object.entries(tokenBalances)) {
        const token = tokens.find(t => t.ticker === ticker); // Find the full token object
        const value = (parseFloat(balance) * (token ? token.price : 0)).toFixed(2); // Calculate USD value
        tokenHtml += `<p><strong>${ticker}:</strong> ${parseFloat(balance).toFixed(2)} (~${value} USD)</p>`;
        totalValue += parseFloat(value);
      }
      document.getElementById('tokenBalances').innerHTML = tokenHtml;
      document.getElementById('totalValue').textContent = totalValue.toFixed(2);
    }

    // --- Portfolio Page Logic ---
    document.getElementById('portfolioBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      updatePortfolio(); // Refresh portfolio data and charts
      document.getElementById('portfolioPage').classList.remove('hidden');
      playSound();
    });
    document.getElementById('backPortfolio').addEventListener('click', () => {
      document.getElementById('portfolioPage').classList.add('hidden');
      // No need to show menu modal again, just hide portfolio
      playSound();
    });

    let portfolioPieChart = null; // Chart instance for portfolio allocation
    let portfolioValueChart = null; // Chart instance for portfolio value history

    // Updates the portfolio display, including charts and holdings
    function updatePortfolio() {
      const labels = ['AVAX', ...Object.keys(tokenBalances)];
      const data = [parseFloat(avaxBalance) * AVAX_PRICE, ...Object.keys(tokenBalances).map(ticker => {
        const token = tokens.find(t => t.ticker === ticker);
        return token ? parseFloat(tokenBalances[ticker]) * token.price : 0;
      })];
      const totalValue = data.reduce((sum, val) => sum + val, 0).toFixed(2);
      const currentCostBasis = portfolioHistory.length > 0 ? portfolioHistory[portfolioHistory.length - 1].costBasis : 0;
      const pnl = (parseFloat(totalValue) - currentCostBasis).toFixed(2);

      document.getElementById('portfolioValue').textContent = totalValue;
      document.getElementById('portfolioPnL').textContent = `${pnl >= 0 ? '+' : ''}${pnl}`;
      document.getElementById('portfolioPnL').className = `text-sm ${pnl >= 0 ? 'text-green-400' : 'text-red-400'}`;

      // Update portfolio history for the line chart
      portfolioHistory.push({ timestamp: new Date().toLocaleString(), value: parseFloat(totalValue), costBasis: currentCostBasis });

      // Destroy existing charts before re-creating to prevent memory leaks
      if (portfolioPieChart) portfolioPieChart.destroy();
      portfolioPieChart = new Chart(document.querySelector('#portfolioPage #portfolioPieChart').getContext('2d'), {
        type: 'pie',
        data: {
          labels,
          datasets: [{
            label: 'Portfolio Allocation',
            data,
            backgroundColor: ['#00ffaa', '#ff4d4d', '#4b6cb7', '#facc15', '#a855f7', '#9966FF', '#FF9F40', '#C9CBCF', '#6A5ACD', '#20B2AA'], // More colors
            borderColor: ['#00ffaa', '#ff4d4d', '#4b6cb7', '#facc15', '#a855f7', '#9966FF', '#FF9F40', '#C9CBCF', '#6A5ACD', '#20B2AA'],
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { position: 'top', labels: { color: '#fff' } },
            title: { display: true, text: 'Portfolio Allocation', color: '#fff' }
          }
        }
      });

      if (portfolioValueChart) portfolioValueChart.destroy();
      portfolioValueChart = new Chart(document.querySelector('#portfolioPage #portfolioValueChart').getContext('2d'), {
        type: 'line',
        data: {
          labels: portfolioHistory.map(h => h.timestamp),
          datasets: [{
            label: 'Portfolio Value (USD)',
            data: portfolioHistory.map(h => h.value),
            borderColor: '#00ffaa',
            backgroundColor: 'rgba(0, 255, 170, 0.2)',
            fill: true,
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          scales: {
            y: { beginAtZero: false, ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } },
            x: { ticks: { color: '#fff' }, grid: { color: 'rgba(255,255,255,0.1)' } }
          },
          plugins: {
            legend: { display: false },
            title: { display: true, text: 'Portfolio Value History', color: '#fff' }
          }
        }
      });

      const holdings = document.getElementById('portfolioHoldings');
      holdings.innerHTML = '<h3 class="text-lg font-semibold mb-2">Holdings</h3>';
      holdings.innerHTML += `<p><strong>AVAX:</strong> ${parseFloat(avaxBalance).toFixed(2)} (~${(parseFloat(avaxBalance) * AVAX_PRICE).toFixed(2)} USD)</p>`;
      for (const [ticker, balance] of Object.entries(tokenBalances)) {
        const token = tokens.find(t => t.ticker === ticker);
        const value = (parseFloat(balance) * (token ? token.price : 0)).toFixed(2);
        holdings.innerHTML += `<p><strong>${ticker}:</strong> ${parseFloat(balance).toFixed(2)} (~${value} USD)</p>`;
      }
    }

    // Exports portfolio data to a CSV file
    document.getElementById('exportPortfolio').addEventListener('click', () => {
      const csv = ['Timestamp,Asset,Amount,Value (USD)'];
      csv.push(`${new Date().toLocaleString()},AVAX,${parseFloat(avaxBalance).toFixed(2)},${(parseFloat(avaxBalance) * AVAX_PRICE).toFixed(2)}`);
      for (const [ticker, balance] of Object.entries(tokenBalances)) {
        const token = tokens.find(t => t.ticker === ticker);
        csv.push(`${new Date().toLocaleString()},${ticker},${parseFloat(balance).toFixed(2)},${(parseFloat(balance) * (token ? token.price : 0)).toFixed(2)}`);
      }
      const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'portfolio.csv';
      a.click();
      URL.revokeObjectURL(url);
      notify('Portfolio exported as CSV.');
      playSound();
    });

    // --- Staking Modal Logic ---
    document.getElementById('stakingBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      updateStakingModal(); // Refresh staking pools before opening
      document.getElementById('stakingModal').classList.remove('hidden');
      playSound();
    });
    document.getElementById('closeStaking').addEventListener('click', () => {
      document.getElementById('stakingModal').classList.add('hidden');
      playSound();
    });
    document.getElementById('backStaking').addEventListener('click', () => {
      document.getElementById('stakingModal').classList.add('hidden');
      playSound();
    });

    // Updates the display of staking pools and user's supply/stake options
    function updateStakingModal() {
      const supplyTokenSelect = document.getElementById('supplyToken');
      supplyTokenSelect.innerHTML = '<option value="">Select Token</option>';
      // Populate supply token dropdown with all launched tokens
      tokens.forEach(token => {
        supplyTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker}</option>`;
      });

      const supplyAssetSelect = document.getElementById('supplyAsset');
      supplyAssetSelect.innerHTML = '<option value="AVAX">AVAX</option>';
      // Populate supply asset dropdown with AVAX and user's owned tokens
      Object.keys(tokenBalances).forEach(ticker => {
        if (parseFloat(tokenBalances[ticker]) > 0) { // Only show tokens user actually holds
          supplyAssetSelect.innerHTML += `<option value="${ticker}">${ticker}</option>`;
        }
      });

      const stakePoolsDiv = document.getElementById('stakePools');
      stakePoolsDiv.innerHTML = '';
      // Display each existing staking pool
      Object.entries(stakingPools).forEach(([ticker, pool]) => {
        stakePoolsDiv.innerHTML += `
          <div class="bg-gray-700 p-4 rounded-lg mb-2">
            <p><strong>${ticker}</strong></p>
            <p>Total Staked: ${pool.totalStaked.toFixed(2)} ${pool.asset}</p>
            <p>APR: ${pool.apr}%</p>
            <p>Users Staking: ${pool.users}</p>
            <p>Rewards: ${pool.rewards.toFixed(2)} ${pool.asset}</p>
            <button class="stakeBtn w-full bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded mt-2 transition-transform transform hover:scale-105" data-ticker="${ticker}">Stake</button>
            <button class="claimBtn w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded mt-2 transition-transform transform hover:scale-105" data-ticker="${ticker}">Claim</button>
          </div>`;
      });

      // Add event listeners for Stake buttons
      document.querySelectorAll('.stakeBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          const ticker = btn.dataset.ticker;
          const pool = stakingPools[ticker];
          showInputBox(`Enter amount of ${pool.asset} to stake for ${ticker}:`, (amount) => {
            if (amount && !isNaN(amount) && parseFloat(amount) > 0) {
              const stakeAmount = parseFloat(amount);
              let hasSufficientFunds = false;
              if (pool.asset === 'AVAX' && parseFloat(avaxBalance) >= stakeAmount) {
                avaxBalance = (parseFloat(avaxBalance) - stakeAmount).toFixed(2);
                hasSufficientFunds = true;
              } else if (tokenBalances[pool.asset] && parseFloat(tokenBalances[pool.asset]) >= stakeAmount) {
                tokenBalances[pool.asset] = (parseFloat(tokenBalances[pool.asset]) - stakeAmount).toFixed(2);
                hasSufficientFunds = true;
              }

              if (hasSufficientFunds) {
                pool.totalStaked += stakeAmount;
                pool.users += 1; // Simulate one more user staking
                notify(`Staked ${stakeAmount} ${pool.asset} successfully!`);
                updateStakingModal();
                updateBalanceModal();
                updatePortfolio();
                playSound();
              } else {
                showMessageBox('Insufficient balance.');
              }
            } else {
              showMessageBox('Invalid amount.');
            }
          });
        });
      });

      // Add event listeners for Claim buttons
      document.querySelectorAll('.claimBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          const ticker = btn.dataset.ticker;
          const pool = stakingPools[ticker];
          if (pool.users > 0) {
            // Simulate claiming a portion of rewards
            const rewardsPerUser = pool.rewards / pool.users;
            if (pool.asset === 'AVAX') {
              avaxBalance = (parseFloat(avaxBalance) + rewardsPerUser).toFixed(2);
            } else {
              tokenBalances[pool.asset] = (parseFloat(tokenBalances[pool.asset] || 0) + rewardsPerUser).toFixed(2);
            }
            pool.rewards -= rewardsPerUser; // Deduct claimed rewards from total pool rewards
            notify(`Claimed ${rewardsPerUser.toFixed(2)} ${pool.asset} rewards!`);
            updateStakingModal();
            updateBalanceModal();
            updatePortfolio();
            playSound();
          } else {
            showMessageBox('No users currently staking in this pool to claim rewards from.');
          }
        });
      });
    }

    // Event listener for Supply button in Staking modal
    document.getElementById('supplyBtn').addEventListener('click', () => {
      const ticker = document.getElementById('supplyToken').value;
      const asset = document.getElementById('supplyAsset').value;
      const amount = parseFloat(document.getElementById('supplyAmount').value);
      const apr = parseFloat(document.getElementById('supplyAPR').value);

      if (!ticker || !asset || isNaN(amount) || amount <= 0 || isNaN(apr) || apr <= 0) {
        showMessageBox('Invalid input: Please fill all fields correctly.');
        return;
      }

      // Check if user has enough balance of the asset to supply
      if (asset === 'AVAX' && amount > parseFloat(avaxBalance)) {
        showMessageBox('Insufficient AVAX balance to supply.');
        return;
      }
      if (asset !== 'AVAX' && (!tokenBalances[asset] || amount > parseFloat(tokenBalances[asset]))) {
        showMessageBox(`Insufficient ${asset} balance to supply.`);
        return;
      }

      // Create new pool or update existing one
      if (!stakingPools[ticker]) {
        stakingPools[ticker] = { totalStaked: 0, apr: apr, users: 0, rewards: 0, asset: asset };
      }
      stakingPools[ticker].totalStaked += amount;
      // Simulate rewards accumulation based on APR
      stakingPools[ticker].rewards += amount * (apr / 100) / 365; // Daily rewards calculation

      // Deduct supplied amount from user's balance
      if (asset === 'AVAX') {
        avaxBalance = (parseFloat(avaxBalance) - amount).toFixed(2);
      } else {
        tokenBalances[asset] = (parseFloat(tokenBalances[asset]) - amount).toFixed(2);
      }

      notify(`Supplied ${amount} ${asset} to ${ticker} pool with ${apr}% APR.`);
      updateStakingModal(); // Refresh staking modal display
      updateBalanceModal(); // Refresh balance modal display
      updatePortfolio(); // Refresh portfolio
      playSound();
    });

    // --- Automated Trading Modal Logic ---
    document.getElementById('autoTradeBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      updateAutoTradeModal(); // Refresh auto-trade options and active trades
      document.getElementById('autoTradeModal').classList.remove('hidden');
      playSound();
    });
    document.getElementById('closeAutoTrade').addEventListener('click', () => {
      document.getElementById('autoTradeModal').classList.add('hidden');
      playSound();
    });
    document.getElementById('backAutoTrade').addEventListener('click', () => {
      document.getElementById('autoTradeModal').classList.add('hidden');
      playSound();
    });

    // Updates the display of automated trading options and active trades
    function updateAutoTradeModal() {
      const autoBuyToken = document.getElementById('autoBuyToken');
      const autoSellToken = document.getElementById('autoSellToken');
      autoBuyToken.innerHTML = autoSellToken.innerHTML = '<option value="">Select Token</option>';
      // Populate dropdowns with tokens in trading stage
      tokens.filter(t => t.stage === 'trading').forEach(token => {
        autoBuyToken.innerHTML += `<option value="${token.ticker}">${token.ticker}</option>`;
        autoSellToken.innerHTML += `<option value="${token.ticker}">${token.ticker}</option>`;
      });

      const activeTrades = document.getElementById('activeAutoTrades');
      activeTrades.innerHTML = '';
      // Display active auto-trades
      autoTrades.forEach((trade, index) => {
        activeTrades.innerHTML += `
          <div class="bg-gray-700 p-4 rounded-lg mb-2">
            <p><strong>${trade.type.charAt(0).toUpperCase() + trade.type.slice(1)} ${trade.ticker}</strong></p>
            <p>Amount: ${trade.amount} ${trade.type === 'buy' ? 'AVAX' : trade.ticker}</p>
            <p>Interval: ${trade.interval} ${trade.unit}</p>
            <button class="stopAutoTrade w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded mt-2 transition-transform transform hover:scale-105" data-index="${index}">Stop</button>
          </div>`;
      });
      // Add event listeners for Stop buttons
      document.querySelectorAll('.stopAutoTrade').forEach(btn => {
        btn.addEventListener('click', () => {
          const index = parseInt(btn.dataset.index);
          if (autoTrades[index]) {
            clearInterval(autoTrades[index].intervalId);
            notify(`Stopped auto-${autoTrades[index].type} for ${autoTrades[index].ticker}.`);
            autoTrades.splice(index, 1); // Remove from array
            updateAutoTradeModal(); // Refresh display
            playSound();
          }
        });
      });
    }

    // Starts an automated buy strategy
    document.getElementById('startAutoBuy').addEventListener('click', () => {
      const ticker = document.getElementById('autoBuyToken').value;
      const amount = parseFloat(document.getElementById('autoBuyAmount').value);
      const interval = parseInt(document.getElementById('autoBuyInterval').value);
      const unit = document.getElementById('autoBuyUnit').value;

      if (!ticker || isNaN(amount) || amount <= 0 || isNaN(interval) || interval <= 0) {
        showMessageBox('Invalid input: Please select a token, enter a positive amount, and a valid interval.');
        return;
      }
      const token = tokens.find(t => t.ticker === ticker);
      if (!token || token.stage !== 'trading') {
          showMessageBox('Selected token is not in the trading stage.');
          return;
      }

      const intervalMs = unit === 'seconds' ? interval * 1000 : interval * 60000;
      const intervalId = setInterval(() => {
        if (parseFloat(avaxBalance) < amount + 0.02) { // Check for AVAX balance + gas fee
          notify(`Insufficient AVAX balance for auto-buy ${ticker}. Stopping strategy.`);
          clearInterval(intervalId);
          autoTrades = autoTrades.filter(t => t.intervalId !== intervalId); // Remove stopped trade
          updateAutoTradeModal();
          return;
        }
        // Simulate buy transaction
        avaxBalance = (parseFloat(avaxBalance) - amount - 0.02).toFixed(2); // Deduct AVAX and gas
        const tokenAmountReceived = (amount / token.price).toFixed(2);
        tokenBalances[ticker] = (parseFloat(tokenBalances[ticker] || 0) + parseFloat(tokenAmountReceived)).toFixed(2);
        token.price = (parseFloat(token.price) * 1.02).toFixed(8); // Simulate slight price increase on buy
        token.marketCap = (token.price * token.supply).toFixed(2);
        token.priceHistory.push({ price: parseFloat(token.price), timestamp: new Date().toLocaleString(), type: 'auto-buy' });
        token.transactions.push({ type: 'Auto-Buy', amount: tokenAmountReceived, token: ticker, timestamp: new Date().toLocaleString() });
        portfolioHistory[portfolioHistory.length - 1].costBasis += amount * AVAX_PRICE; // Update portfolio cost basis
        updateTokenLists();
        updateBalanceModal();
        updatePortfolio();
        if (currentToken && currentToken.ticker === ticker) updatePriceChart(); // Update chart if viewing
        notify(`Auto-bought ${tokenAmountReceived} ${ticker} for ${amount} AVAX.`);
      }, intervalMs);
      autoTrades.push({ type: 'buy', ticker, amount, interval, unit, intervalId });
      updateAutoTradeModal();
      notify(`Started auto-buy for ${ticker}: ${amount} AVAX every ${interval} ${unit}.`);
      playSound();
    });

    // Starts an automated sell strategy
    document.getElementById('startAutoSell').addEventListener('click', () => {
      const ticker = document.getElementById('autoSellToken').value;
      const amount = parseFloat(document.getElementById('autoSellAmount').value);
      const interval = parseInt(document.getElementById('autoSellInterval').value);
      const unit = document.getElementById('autoSellUnit').value;

      if (!ticker || isNaN(amount) || amount <= 0 || isNaN(interval) || interval <= 0) {
        showMessageBox('Invalid input: Please select a token, enter a positive amount, and a valid interval.');
        return;
      }
      const token = tokens.find(t => t.ticker === ticker);
      if (!token || token.stage !== 'trading') {
          showMessageBox('Selected token is not in the trading stage.');
          return;
      }

      const intervalMs = unit === 'seconds' ? interval * 1000 : interval * 60000;
      const intervalId = setInterval(() => {
        if (parseFloat(tokenBalances[ticker] || 0) < amount) {
          notify(`Insufficient ${ticker} balance for auto-sell. Stopping strategy.`);
          clearInterval(intervalId);
          autoTrades = autoTrades.filter(t => t.intervalId !== intervalId); // Remove stopped trade
          updateAutoTradeModal();
          return;
        }
        // Simulate sell transaction
        tokenBalances[ticker] = (parseFloat(tokenBalances[ticker]) - amount).toFixed(2);
        const avaxReceived = (amount * token.price - 0.02).toFixed(2); // Deduct gas
        avaxBalance = (parseFloat(avaxBalance) + parseFloat(avaxReceived)).toFixed(2);
        token.price = (parseFloat(token.price) * 0.98).toFixed(8); // Simulate slight price decrease on sell
        token.marketCap = (token.price * token.supply).toFixed(2);
        token.priceHistory.push({ price: parseFloat(token.price), timestamp: new Date().toLocaleString(), type: 'auto-sell' });
        token.transactions.push({ type: 'Auto-Sell', amount, token: ticker, timestamp: new Date().toLocaleString() });
        updateTokenLists();
        updateBalanceModal();
        updatePortfolio();
        if (currentToken && currentToken.ticker === ticker) updatePriceChart(); // Update chart if viewing
        notify(`Auto-sold ${amount} ${ticker} for ${avaxReceived} AVAX.`);
      }, intervalMs);
      autoTrades.push({ type: 'sell', ticker, amount, interval, unit, intervalId });
      updateAutoTradeModal();
      notify(`Started auto-sell for ${ticker}: ${amount} tokens every ${interval} ${unit}.`);
      playSound();
    });

    // --- Collapsible Sections Logic ---
    // Toggles the visibility of content sections on the main page
    document.querySelectorAll('.toggleSection').forEach(btn => {
      btn.addEventListener('click', () => {
        const sectionContent = btn.parentElement.nextElementSibling; // The content div
        sectionContent.classList.toggle('hidden'); // Toggle hidden class
        btn.textContent = sectionContent.classList.contains('hidden') ? '+' : '‚àí'; // Change button text
        playSound();
      });
    });

    // --- Launch Token Page Logic ---
    // Shows the launch token form
    document.getElementById('launchTokenBtn').addEventListener('click', () => {
      document.getElementById('launchSection').classList.add('hidden'); // Hide main launch section
      document.getElementById('launchPage').classList.remove('hidden'); // Show launch form page
      playSound();
    });
    // Goes back from launch token form to main sections
    document.getElementById('backLaunch').addEventListener('click', () => {
      document.getElementById('launchPage').classList.add('hidden'); // Hide launch form page
      document.getElementById('launchSection').classList.remove('hidden'); // Show main launch section
      playSound();
    });

    // --- Token Launch Form Submission ---
    document.getElementById('launchForm').addEventListener('submit', (e) => {
      e.preventDefault(); // Prevent default form submission
      if (!wallet) {
        showMessageBox('Please sign in by initializing the app first.');
        return;
      }

      // Get form values
      const duration = parseInt(document.getElementById('whitelistDuration').value);
      const unit = document.getElementById('durationUnit').value;
      let durationMs = duration * 1000; // Convert to milliseconds
      if (unit === 'hours') durationMs *= 3600;
      else if (unit === 'minutes') durationMs *= 60;

      const vestingDuration = parseInt(document.getElementById('vestingDuration').value);
      const vestingUnit = document.getElementById('vestingUnit').value;
      let vestingDurationMs = vestingDuration * 1000;
      if (vestingUnit === 'hours') vestingDurationMs *= 3600;
      else if (vestingUnit === 'minutes') vestingDurationMs *= 60;
      else if (vestingUnit === 'days') vestingDurationMs *= 86400;
      else if (vestingUnit === 'months') vestingDurationMs *= 2592000; // Approximate for 30 days

      const tokenData = {
        name: document.getElementById('tokenName').value,
        ticker: document.getElementById('tokenTicker').value.toUpperCase(), // Convert ticker to uppercase
        supply: parseInt(document.getElementById('tokenSupply').value),
        originalSupply: parseInt(document.getElementById('tokenSupply').value), // Store original supply for burn calculations
        image: document.getElementById('tokenImage').value || 'https://placehold.co/150x150/888888/ffffff?text=Token', // Default placeholder image
        twitter: document.getElementById('twitterLink').value,
        discord: document.getElementById('discordLink').value,
        duration: durationMs, // Whitelist duration in milliseconds
        minContribution: parseFloat(document.getElementById('minContribution').value),
        maxContribution: parseFloat(document.getElementById('maxContribution').value),
        airdropPercentage: parseFloat(document.getElementById('airdropPercentage').value),
        vestingDuration: vestingDurationMs,
        vestingStart: null, // Will be set when airdrop becomes claimable
        airdropClaimed: 0, // Amount of airdrop claimed by creator
        totalBurned: 0, // Total tokens burned
        creatorWallet: wallet.address,
        stage: 'whitelist', // Initial stage
        totalContributed: 0,
        transactions: [],
        chat: [],
        price: 0, // Initial price before trading
        priceHistory: [], // Stores historical price data for chart
        boostLevel: 0, // Initial boost level
        marketCap: 0, // Initial market cap
        liquidity: { avax: 0, token: 0, userShares: {}, fees: {} }, // Liquidity pool data
        whitelistEndTime: Date.now() + durationMs // Calculate whitelist end time
      };

      // Input validation
      if (tokenData.maxContribution > 500) {
        showMessageBox('Max contribution cannot exceed 500 AVAX.');
        return;
      }
      if (isNaN(tokenData.duration) || tokenData.duration <= 0) {
        showMessageBox('Whitelist duration must be a positive number.');
        return;
      }
      if (isNaN(tokenData.minContribution) || tokenData.minContribution <= 0) {
        showMessageBox('Min contribution must be a positive number.');
        return;
      }
      if (isNaN(tokenData.maxContribution) || tokenData.maxContribution <= 0) {
        showMessageBox('Max contribution must be a positive number.');
        return;
      }
      if (tokenData.minContribution > tokenData.maxContribution) {
        showMessageBox('Min contribution cannot be greater than Max contribution.');
        return;
      }
      if (isNaN(tokenData.supply) || tokenData.supply <= 0) {
        showMessageBox('Total supply must be a positive number.');
        return;
      }
      if (isNaN(tokenData.airdropPercentage) || tokenData.airdropPercentage < 0 || tokenData.airdropPercentage > 90) {
        showMessageBox('Airdrop percentage must be between 0 and 90.');
        return;
      }
      if (isNaN(tokenData.vestingDuration) || tokenData.vestingDuration <= 0) {
        showMessageBox('Vesting duration must be a positive number.');
        return;
      }

      tokens.push(tokenData); // Add new token to the global tokens array
      liquidityPools[tokenData.ticker] = { avax: 0, token: 0, totalShares: 0, userShares: {}, fees: {} }; // Initialize liquidity pool for new token
      updateTokenLists(); // Refresh token lists on main page
      startWhitelistTimer(tokenData); // Start the timer for this token's whitelist
      document.getElementById('launchPage').classList.add('hidden'); // Hide launch form
      document.getElementById('launchSection').classList.remove('hidden'); // Show main launch section
      notify(`Token ${tokenData.ticker} launched successfully!`);
      playSound();
    });

    // --- Token Details Page Logic ---
    // Displays detailed information for a selected token
    let contributionChart = null; // Chart instance for contribution progress
    let priceChart = null; // Chart instance for token price history
    let burnChart = null; // Chart instance for token burn progress

    function showTokenDetails(ticker) {
      currentToken = tokens.find(t => t.ticker === ticker); // Set the global currentToken
      if (!currentToken) {
        showMessageBox('Token not found.');
        return;
      }

      // Hide main sections and show token details page
      document.getElementById('launchSection').classList.add('hidden');
      document.getElementById('whitelistSection').classList.add('hidden');
      document.getElementById('tradingSection').classList.add('hidden');
      document.getElementById('trendingSection').classList.add('hidden');
      document.getElementById('tokenDetailsPage').classList.remove('hidden');

      // Populate token details
      document.getElementById('tokenImg').src = currentToken.image;
      document.getElementById('tokenImg').onerror = function() { // Fallback for broken image URLs
          this.onerror=null;
          this.src='https://placehold.co/150x150/888888/ffffff?text=Image+Error';
      };
      document.getElementById('displayTokenName').textContent = currentToken.name;
      document.getElementById('displayTokenTicker').textContent = currentToken.ticker;
      document.getElementById('displayTokenSupply').textContent = currentToken.supply.toLocaleString(); // Format with commas
      document.getElementById('marketCap').textContent = parseFloat(currentToken.marketCap).toFixed(2);
      document.getElementById('displayCreatorWallet').textContent = currentToken.creatorWallet;
      document.getElementById('currentStage').textContent = currentToken.stage.charAt(0).toUpperCase() + currentToken.stage.slice(1); // Capitalize first letter
      document.getElementById('twitterLinkDisplay').href = currentToken.twitter || '#';
      document.getElementById('twitterLinkDisplay').textContent = currentToken.twitter ? 'Twitter' : 'N/A';
      document.getElementById('discordLinkDisplay').href = currentToken.discord || '#';
      document.getElementById('discordLinkDisplay').textContent = currentToken.discord ? 'Discord' : 'N/A';
      document.getElementById('boostStatus').textContent = currentToken.boostLevel > 0 ? `Boosted (Rank ${currentToken.boostLevel})` : 'Not Boosted';
      document.getElementById('tokenomics').textContent = `${currentToken.airdropPercentage}% Airdrop, 50% Liquidity, ${100 - currentToken.airdropPercentage - 50}% Team`; // Dynamic team percentage

      // Update contribution specific details
      document.getElementById('totalContributed').textContent = currentToken.totalContributed.toFixed(2);
      document.getElementById('totalContributedValue').textContent = (currentToken.totalContributed * AVAX_PRICE).toFixed(2);

      // Toggle visibility of sections based on token stage and creator status
      document.getElementById('snipeSection').classList.toggle('hidden', currentToken.stage !== 'whitelist');
      document.getElementById('contributionSection').classList.toggle('hidden', currentToken.stage !== 'whitelist');
      document.getElementById('tradingInterface').classList.toggle('hidden', currentToken.stage !== 'trading');
      document.getElementById('liquiditySection').classList.toggle('hidden', currentToken.stage !== 'trading');
      document.getElementById('burnSection').classList.toggle('hidden', currentToken.creatorWallet !== wallet.address); // Only creator can burn
      document.getElementById('airdropSection').classList.toggle('hidden', !currentToken.vestingStart); // Airdrop section visible after vesting starts

      document.getElementById('receiveTokenTicker').textContent = currentToken.ticker; // Set ticker for trading interface
      document.getElementById('poolTokenTicker').textContent = currentToken.ticker; // Set ticker for liquidity
      document.getElementById('burnTicker').textContent = currentToken.ticker; // Set ticker for burn
      document.getElementById('airdropTicker').textContent = currentToken.ticker; // Set ticker for airdrop
      document.getElementById('airdropTicker2').textContent = currentToken.ticker; // Set ticker for airdrop

      updateLiquiditySection(); // Update liquidity pool details
      updateBurnSection(); // Update burn section details
      updateAirdropSection(); // Update airdrop section details
      updateContributionChart(); // Update contribution chart for current token
      updatePriceChart(); // Update price chart for current token
      playSound();
    }

    // Goes back from token details page to main sections
    document.getElementById('backTokenDetails').addEventListener('click', () => {
      document.getElementById('tokenDetailsPage').classList.add('hidden'); // Hide token details
      // Show main sections again
      document.getElementById('launchSection').classList.remove('hidden');
      document.getElementById('whitelistSection').classList.remove('hidden');
      document.getElementById('tradingSection').classList.remove('hidden');
      document.getElementById('trendingSection').classList.remove('hidden');
      // Destroy charts to free up memory
      if (contributionChart) { contributionChart.destroy(); contributionChart = null; }
      if (priceChart) { priceChart.destroy(); priceChart = null; }
      if (burnChart) { burnChart.destroy(); burnChart = null; }
      playSound();
    });

    // --- Whitelist Timer Logic ---
    // Manages the countdown for a token's whitelist period
    function startWhitelistTimer(token) {
      const updateTimer = () => {
        const timeLeft = token.whitelistEndTime - Date.now();
        if (timeLeft <= 0) {
          // Whitelist ends, transition to trading stage
          token.stage = 'trading';
          // Calculate initial price based on contributions and airdrop percentage (50% of total supply goes to liquidity)
          // Assuming 50% of total supply is paired with total contributed AVAX
          const liquidityTokenAmount = token.supply * 0.5;
          token.price = (token.totalContributed / liquidityTokenAmount).toFixed(8); // Price per token in AVAX
          token.marketCap = (parseFloat(token.price) * token.supply * AVAX_PRICE).toFixed(2); // Update market cap in USD
          // Record initial price in history
          token.priceHistory.push({ price: parseFloat(token.price), timestamp: new Date().toLocaleString(), type: 'init' });
          // Set vesting start time for airdrop
          token.vestingStart = Date.now();

          // Initialize liquidity pool for this token
          const pool = liquidityPools[token.ticker];
          pool.avax = token.totalContributed; // All contributed AVAX goes to liquidity
          pool.token = liquidityTokenAmount; // 50% of supply goes to liquidity
          pool.totalShares = Math.sqrt(pool.avax * pool.token); // Simplified LP share calculation
          // Give all initial LP shares to the creator (for simplicity)
          pool.userShares[token.creatorWallet] = pool.totalShares;
          pool.fees[token.creatorWallet] = 0; // Initial fees for creator

          updateTokenLists(); // Refresh token lists to reflect stage change
          updateBalanceModal(); // Update user's balance modal
          updatePortfolio(); // Update portfolio to reflect new token value
          notify(`Whitelist ended for ${token.ticker}. Trading is now live!`);
          return;
        }
        // Calculate remaining time
        const hours = Math.floor(timeLeft / 3600000);
        const minutes = Math.floor((timeLeft % 3600000) / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        // Update timer display only if this token is currently being viewed
        if (currentToken && currentToken.ticker === token.ticker) {
          document.getElementById('whitelistTimer').textContent = `${hours}h ${minutes}m ${seconds}s`;
        }
        // Also update timers in the main whitelist section
        document.querySelectorAll(`.timer-${token.ticker}`).forEach(el => {
            el.textContent = `${hours}h ${minutes}m ${seconds}s`;
        });
        setTimeout(updateTimer, 1000); // Update every second
      };
      updateTimer(); // Initial call to start the timer

      // Simulate bot contributions starting halfway through the whitelist
      setTimeout(() => {
        const botInterval = setInterval(() => {
          if (token.stage === 'whitelist' && token.totalContributed < 500) {
            const botAmount = Math.random() * (token.maxContribution - token.minContribution) / 2; // Bots contribute a random amount within limits
            if (token.totalContributed + botAmount > 500) { // Cap at max contribution
                token.totalContributed = 500;
            } else {
                token.totalContributed += botAmount;
            }
            token.transactions.push({ type: 'Bot Contribution', amount: botAmount.toFixed(2), token: 'AVAX', timestamp: new Date().toLocaleString() });
            updateTokenLists(); // Update lists to show progress
            if (currentToken && currentToken.ticker === token.ticker) {
              updateContributionChart(); // Update chart if viewing this token
            }
          } else {
            clearInterval(botInterval); // Stop bot contributions if whitelist ends or max reached
          }
        }, 5000); // Bots contribute every 5 seconds
      }, token.duration / 2); // Bots start halfway through whitelist duration
    }

    // --- Contribution Logic ---
    document.getElementById('contributeBtn').addEventListener('click', () => {
      if (!wallet) {
        showMessageBox('Please sign in by initializing the app.');
        return;
      }
      const amount = parseFloat(document.getElementById('contributeAmount').value);

      // Input and balance validation
      if (isNaN(amount) || amount <= 0) {
        showMessageBox('Please enter a valid positive amount to contribute.');
        return;
      }
      if (Date.now() > currentToken.whitelistEndTime) {
          showMessageBox('Whitelist has ended. Cannot contribute.');
          return;
      }
      if (amount < currentToken.minContribution) {
        showMessageBox(`Contribution must be at least ${currentToken.minContribution} AVAX.`);
        return;
      }
      if (amount > currentToken.maxContribution) {
        showMessageBox(`Contribution cannot exceed ${currentToken.maxContribution} AVAX.`);
        return;
      }
      if (currentToken.totalContributed + amount > 500) {
        showMessageBox(`Total contribution limit (500 AVAX) exceeded. You can contribute up to ${(500 - currentToken.totalContributed).toFixed(2)} AVAX.`);
        return;
      }
      if (amount + 0.01 > parseFloat(avaxBalance)) { // Check AVAX balance + gas fee
        showMessageBox('Insufficient AVAX balance for this contribution (including gas fee).');
        return;
      }

      // Simulate transaction confirmation
      showConfirmBox(`Confirm contribution of ${amount} AVAX to ${currentToken.ticker} whitelist? (Gas fee: 0.01 AVAX)`, (confirmed) => {
        if (confirmed) {
          avaxBalance = (parseFloat(avaxBalance) - amount - 0.01).toFixed(2); // Deduct amount and gas fee
          currentToken.totalContributed += amount;
          currentToken.transactions.push({ type: 'Contribution', amount: amount.toFixed(2), token: 'AVAX', timestamp: new Date().toLocaleString() });
          updateContributionChart();
          updateTokenLists();
          updateBalanceModal();
          updatePortfolio();
          notify(`Contributed ${amount} AVAX to ${currentToken.ticker} successfully!`);
          playSound();
        } else {
          notify('Contribution cancelled.');
        }
      });
    });

    // --- Token Sniping Logic ---
    document.getElementById('snipeBtn').addEventListener('click', () => {
      if (!wallet) {
        showMessageBox('Please sign in by initializing the app.');
        return;
      }
      const amount = parseFloat(document.getElementById('snipeAmount').value);

      if (isNaN(amount) || amount <= 0) {
        showMessageBox('Please enter a valid positive amount to snipe.');
        return;
      }
      if (amount + 0.02 > parseFloat(avaxBalance)) { // Check AVAX balance + gas fee
        showMessageBox('Insufficient AVAX balance for sniping (including gas fee).');
        return;
      }
      if (amount < currentToken.minContribution || amount > currentToken.maxContribution) {
        showMessageBox(`Snipe amount must be between ${currentToken.minContribution} and ${currentToken.maxContribution} AVAX.`);
        return;
      }
      if (currentToken.totalContributed + amount > 500) {
        showMessageBox(`Total contribution limit (500 AVAX) will be exceeded. You can snipe up to ${(500 - currentToken.totalContributed).toFixed(2)} AVAX.`);
        return;
      }
      if (currentToken.stage !== 'whitelist') {
        showMessageBox('Snipe can only be set up during the whitelist stage.');
        return;
      }

      showConfirmBox(`Confirm setting up snipe for ${amount} AVAX on ${currentToken.ticker}? (Gas fee: 0.02 AVAX)`, (confirmed) => {
        if (confirmed) {
          avaxBalance = (parseFloat(avaxBalance) - amount - 0.02).toFixed(2); // Deduct amount and gas fee
          currentToken.totalContributed += amount; // Simulate immediate contribution for snipe
          // Simulate receiving tokens based on a simplified price model at launch
          // Assuming 50% of total supply is paired with total contributed AVAX for initial price
          const estimatedLaunchPrice = (currentToken.totalContributed / (currentToken.supply * 0.5));
          const estimatedTokensReceived = (amount / estimatedLaunchPrice).toFixed(2);

          tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) + parseFloat(estimatedTokensReceived)).toFixed(2);
          currentToken.transactions.push({
            type: 'Snipe (Pre-Launch)',
            amount: `${amount} AVAX`,
            tokenAmount: estimatedTokensReceived,
            timestamp: new Date().toLocaleString()
          });
          portfolioHistory[portfolioHistory.length - 1].costBasis += amount * AVAX_PRICE; // Update portfolio cost basis

          // Simulate the snipe executing at launch (this will be handled by the whitelist timer transition)
          notify(`Snipe for ${amount} AVAX on ${currentToken.ticker} set up! You will receive approx. ${estimatedTokensReceived} tokens at launch.`);
          updateContributionChart();
          updateBalanceModal();
          updatePortfolio();
          updateTokenLists();
          playSound();
        } else {
          notify('Snipe setup cancelled.');
        }
      });
    });

    // --- Trading Logic ---
    // Updates the receive token amount based on AVAX input and current token price
    document.getElementById('tradeAvaxAmount').addEventListener('input', () => {
      const avaxAmount = parseFloat(document.getElementById('tradeAvaxAmount').value);
      if (!isNaN(avaxAmount) && currentToken && currentToken.price > 0) {
        // Calculate received tokens based on current price and a small fee (e.g., 0.3%)
        const receivedTokens = (avaxAmount / currentToken.price) * 0.997; // 0.3% trading fee
        document.getElementById('tradeTokenAmount').value = receivedTokens.toFixed(2);
      } else {
        document.getElementById('tradeTokenAmount').value = '';
      }
    });

    // Initiates the trade confirmation modal
    document.getElementById('tradeBtn').addEventListener('click', () => {
      if (!wallet) {
        showMessageBox('Please sign in by initializing the app.');
        return;
      }
      const avaxAmount = parseFloat(document.getElementById('tradeAvaxAmount').value);
      const slippage = parseFloat(document.getElementById('slippageSelect').value);

      // Validation
      if (isNaN(avaxAmount) || avaxAmount <= 0) {
        showMessageBox('Please enter a valid positive AVAX amount to trade.');
        return;
      }
      if (avaxAmount + 0.02 > parseFloat(avaxBalance)) { // Check AVAX balance + gas fee
        showMessageBox('Insufficient AVAX balance for this trade (including gas fee).');
        return;
      }
      if (currentToken.stage !== 'trading') {
        showMessageBox('Trading is not active for this token yet.');
        return;
      }
      if (parseFloat(currentToken.price) <= 0) {
          showMessageBox('Token price is zero or not set. Cannot trade.');
          return;
      }

      const tokenAmount = (avaxAmount / parseFloat(currentToken.price)).toFixed(2);
      const gasFee = 0.02; // Simulated gas fee

      // Populate confirmation modal
      document.getElementById('confirmAvaxAmount').textContent = avaxAmount.toFixed(2);
      document.getElementById('confirmTokenAmount').textContent = tokenAmount;
      document.getElementById('confirmTokenTicker').textContent = currentToken.ticker;
      document.getElementById('confirmSlippage').textContent = slippage;
      document.getElementById('confirmGasFee').textContent = gasFee.toFixed(2);
      document.getElementById('tradeConfirmModal').classList.remove('hidden'); // Show confirmation modal
      playSound();
    });

    // Confirms and executes the trade
    document.getElementById('confirmTradeBtn').addEventListener('click', () => {
      const avaxAmount = parseFloat(document.getElementById('confirmAvaxAmount').textContent);
      const tokenAmount = parseFloat(document.getElementById('confirmTokenAmount').textContent);
      const gasFee = parseFloat(document.getElementById('confirmGasFee').textContent);

      // Simulate transaction execution
      avaxBalance = (parseFloat(avaxBalance) - avaxAmount - gasFee).toFixed(2); // Deduct AVAX and gas fee
      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) + tokenAmount).toFixed(2); // Add tokens to user's balance

      // Simulate price impact: price increases slightly on buy (simplified)
      currentToken.price = (parseFloat(currentToken.price) * 1.02).toFixed(8);
      currentToken.marketCap = (parseFloat(currentToken.price) * currentToken.supply * AVAX_PRICE).toFixed(2); // Update market cap in USD
      currentToken.priceHistory.push({ price: parseFloat(currentToken.price), timestamp: new Date().toLocaleString(), type: 'buy' }); // Record price change

      currentToken.transactions.push({ type: 'Swap (Buy)', amount: `${tokenAmount} ${currentToken.ticker} for ${avaxAmount} AVAX`, timestamp: new Date().toLocaleString() }); // Record transaction

      // Simulate liquidity pool update (simplified)
      const pool = liquidityPools[currentToken.ticker];
      pool.avax += avaxAmount;
      pool.token -= tokenAmount; // Tokens are removed from pool
      pool.fees[wallet.address] = (pool.fees[wallet.address] || 0) + (avaxAmount * 0.003); // Simulate 0.3% fee to LP providers

      updatePriceChart(); // Update price chart
      updateTokenLists(); // Update token lists (trending, etc.)
      updateBalanceModal(); // Update user's balance
      updatePortfolio(); // Update portfolio
      updateLiquiditySection(); // Update liquidity section
      document.getElementById('tradeConfirmModal').classList.add('hidden'); // Hide confirmation modal
      notify(`Swapped ${avaxAmount} AVAX for ${tokenAmount} ${currentToken.ticker}!`);
      playSound();
    });

    // Cancels the trade
    document.getElementById('cancelTradeBtn').addEventListener('click', () => {
      document.getElementById('tradeConfirmModal').classList.add('hidden');
      notify('Trade cancelled.');
      playSound();
    });

    // --- Boost Token Logic ---
    document.getElementById('boostBtn').addEventListener('click', () => {
      if (!wallet) {
        showMessageBox('Please sign in by initializing the app.');
        return;
      }
      if (!currentToken || currentToken.stage !== 'trading') {
          showMessageBox('Cannot boost a token that is not in the trading stage.');
          return;
      }
      document.getElementById('boostTokenTicker').textContent = currentToken.ticker; // Set ticker in modal
      document.getElementById('boostToken').textContent = currentToken.ticker; // Set ticker in input label
      document.getElementById('boostModal').classList.remove('hidden'); // Show boost modal
      playSound();
    });

    document.getElementById('confirmBoostBtn').addEventListener('click', () => {
      const boostAmount = parseFloat(document.getElementById('boostAmount').value);

      // Validation
      if (isNaN(boostAmount) || boostAmount < 100) {
        showMessageBox('Invalid boost amount. Must be at least 100.');
        return;
      }
      if (!tokenBalances[currentToken.ticker] || parseFloat(tokenBalances[currentToken.ticker]) < boostAmount) {
        showMessageBox(`Insufficient ${currentToken.ticker} balance to boost.`);
        return;
      }

      let boostLevel = 0;
      if (boostAmount >= 300) boostLevel = 1; // Highest boost
      else if (boostAmount >= 200) boostLevel = 2;
      else if (boostAmount >= 100) boostLevel = 3; // Lowest boost

      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker]) - boostAmount).toFixed(2); // Deduct boost amount
      currentToken.boostLevel = boostLevel; // Apply boost level
      document.getElementById('boostStatus').textContent = `Boosted (Rank ${boostLevel})`; // Update display
      currentToken.transactions.push({ type: 'Boost', amount: `${boostAmount} ${currentToken.ticker}`, timestamp: new Date().toLocaleString() }); // Record transaction
      updateTokenLists(); // Refresh trending list
      updateBalanceModal(); // Update balance
      updatePortfolio(); // Update portfolio
      document.getElementById('boostModal').classList.add('hidden'); // Hide modal
      notify(`Boosted ${currentToken.ticker} to Rank ${boostLevel}!`);
      playSound();
    });

    document.getElementById('cancelBoostBtn').addEventListener('click', () => {
      document.getElementById('boostModal').classList.add('hidden');
      notify('Boost cancelled.');
      playSound();
    });

    // --- Liquidity Pool Logic ---
    document.getElementById('supplyType').addEventListener('change', () => {
      const supplyType = document.getElementById('supplyType').value;
      document.getElementById('singleSupply').classList.toggle('hidden', supplyType !== 'single');
      document.getElementById('dualSupply').classList.toggle('hidden', supplyType !== 'dual');
    });

    document.getElementById('dualAvaxAmount').addEventListener('input', () => {
      const avaxAmount = parseFloat(document.getElementById('dualAvaxAmount').value);
      if (!isNaN(avaxAmount) && currentToken && currentToken.price > 0) {
        const tokenAmount = (avaxAmount / currentToken.price).toFixed(2);
        document.getElementById('dualTokenAmount').value = tokenAmount;
      } else {
        document.getElementById('dualTokenAmount').value = '';
      }
    });

    document.getElementById('addLiquidityBtn').addEventListener('click', () => {
      if (!wallet) {
        showMessageBox('Please sign in by initializing the app.');
        return;
      }
      if (!currentToken || currentToken.stage !== 'trading') {
        showMessageBox('Can only add liquidity for tokens in the trading stage.');
        return;
      }

      const supplyType = document.getElementById('supplyType').value;
      const pool = liquidityPools[currentToken.ticker];
      let avaxAmount = parseFloat(document.getElementById('avaxAmount').value);
      let tokenAmount = 0;
      let gasFee = 0.02;

      if (supplyType === 'dual') {
        avaxAmount = parseFloat(document.getElementById('dualAvaxAmount').value);
        tokenAmount = parseFloat(document.getElementById('dualTokenAmount').value);
      }

      // Validation
      if (isNaN(avaxAmount) || avaxAmount <= 0 || avaxAmount + gasFee > parseFloat(avaxBalance)) {
        showMessageBox('Invalid AVAX amount or insufficient balance (including gas fee).');
        return;
      }
      if (supplyType === 'dual' && (isNaN(tokenAmount) || tokenAmount <= 0 || tokenAmount > parseFloat(tokenBalances[currentToken.ticker] || 0))) {
        showMessageBox(`Invalid ${currentToken.ticker} amount or insufficient balance.`);
        return;
      }

      showConfirmBox(`Confirm adding liquidity: ${avaxAmount} AVAX${supplyType === 'dual' ? ` + ${tokenAmount} ${currentToken.ticker}` : ''}? (Gas fee: ${gasFee} AVAX)`, (confirmed) => {
        if (confirmed) {
          const initialAvax = pool.avax;
          const initialToken = pool.token;

          // Simulate LP share calculation (simplified: proportional to contribution)
          let shares = 0;
          if (pool.totalShares === 0) { // First liquidity provider
              shares = Math.sqrt(avaxAmount * (supplyType === 'dual' ? tokenAmount : avaxAmount / currentToken.price));
          } else { // Subsequent liquidity providers
              // Calculate shares based on current pool ratio
              const ratio = initialToken / initialAvax;
              const equivalentTokenAmount = avaxAmount * ratio; // How many tokens are equivalent to AVAX amount
              shares = (avaxAmount / initialAvax) * pool.totalShares; // Shares based on AVAX contribution
              if (supplyType === 'dual' && Math.abs(tokenAmount - equivalentTokenAmount) > 0.01) { // If not exact ratio
                  // This is a simplification; a real AMM would handle this with impermanent loss
                  showMessageBox("Warning: Adding liquidity with a non-ideal ratio might result in impermanent loss.");
              }
          }

          pool.avax += avaxAmount;
          pool.token += supplyType === 'dual' ? tokenAmount : (avaxAmount / currentToken.price); // Convert AVAX to token if single-sided
          pool.totalShares += shares;
          pool.userShares[wallet.address] = (pool.userShares[wallet.address] || 0) + shares;
          pool.fees[wallet.address] = (pool.fees[wallet.address] || 0); // Fees start at 0 for new deposit

          avaxBalance = (parseFloat(avaxBalance) - avaxAmount - gasFee).toFixed(2);
          if (supplyType === 'dual') {
            tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) - tokenAmount).toFixed(2);
          }
          currentToken.transactions.push({
            type: 'Add Liquidity',
            amount: `${avaxAmount} AVAX${supplyType === 'dual' ? ` + ${tokenAmount} ${currentToken.ticker}` : ''}`,
            timestamp: new Date().toLocaleString()
          });
          portfolioHistory[portfolioHistory.length - 1].costBasis += avaxAmount * AVAX_PRICE; // Update portfolio cost basis
          updateLiquiditySection();
          updateBalanceModal();
          updatePortfolio();
          notify(`Added ${avaxAmount} AVAX${supplyType === 'dual' ? ` and ${tokenAmount} ${currentToken.ticker}` : ''} to liquidity pool.`);
          playSound();
        } else {
          notify('Add liquidity cancelled.');
        }
      });
    });

    document.getElementById('removeLiquidityBtn').addEventListener('click', () => {
      if (!wallet) {
        showMessageBox('Please sign in by initializing the app.');
        return;
      }
      const pool = liquidityPools[currentToken.ticker];
      const shares = pool.userShares[wallet.address] || 0;
      const gasFee = 0.02;

      if (shares <= 0) {
        showMessageBox('No liquidity to remove.');
        return;
      }

      showConfirmBox(`Confirm removing all your liquidity? (Gas fee: ${gasFee} AVAX)`, (confirmed) => {
        if (confirmed) {
          const avaxShare = (pool.avax * shares / pool.totalShares);
          const tokenShare = (pool.token * shares / pool.totalShares);
          const feesEarned = (pool.fees[wallet.address] || 0); // Claim all accumulated fees

          // Deduct from pool and add to user's balance
          pool.avax -= avaxShare;
          pool.token -= tokenShare;
          pool.totalShares -= shares;
          pool.userShares[wallet.address] = 0; // Reset user's shares
          pool.fees[wallet.address] = 0; // Reset user's fees

          avaxBalance = (parseFloat(avaxBalance) + avaxShare + feesEarned - gasFee).toFixed(2);
          tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) + tokenShare).toFixed(2);

          currentToken.transactions.push({
            type: 'Remove Liquidity',
            amount: `${avaxShare.toFixed(2)} AVAX + ${tokenShare.toFixed(2)} ${currentToken.ticker} (Fees: ${feesEarned.toFixed(2)} AVAX)`,
            timestamp: new Date().toLocaleString()
          });
          updateLiquiditySection();
          updateBalanceModal();
          updatePortfolio();
          notify(`Removed ${avaxShare.toFixed(2)} AVAX and ${tokenShare.toFixed(2)} ${currentToken.ticker} from liquidity pool. Claimed ${feesEarned.toFixed(2)} AVAX fees.`);
          playSound();
        } else {
          notify('Remove liquidity cancelled.');
        }
      });
    });

    // Updates the liquidity pool section display
    function updateLiquiditySection() {
      const pool = liquidityPools[currentToken.ticker];
      const tvl = (pool.avax * AVAX_PRICE + pool.token * parseFloat(currentToken.price) * AVAX_PRICE).toFixed(2); // TVL in USD
      const share = pool.userShares[wallet.address] || 0;
      const sharePercent = pool.totalShares > 0 ? (share / pool.totalShares * 100).toFixed(2) : 0;
      document.getElementById('poolTVL').textContent = tvl;
      document.getElementById('poolShare').textContent = sharePercent;
      document.getElementById('feesEarned').textContent = (pool.fees[wallet.address] || 0).toFixed(2);
    }

    // --- Token Burn Logic ---
    document.getElementById('burnBtn').addEventListener('click', () => {
      if (!wallet || currentToken.creatorWallet !== wallet.address) {
        showMessageBox('Only the token creator can burn tokens.');
        return;
      }
      const amount = parseFloat(document.getElementById('burnAmount').value);
      const gasFee = 0.01;

      if (isNaN(amount) || amount <= 0 || amount + gasFee > parseFloat(tokenBalances[currentToken.ticker] || 0)) {
        showMessageBox('Invalid amount or insufficient balance (including gas fee).');
        return;
      }

      showConfirmBox(`Confirm burning ${amount} ${currentToken.ticker}? (Gas fee: ${gasFee} ${currentToken.ticker})`, (confirmed) => {
        if (confirmed) {
          currentToken.supply -= amount; // Reduce total supply
          currentToken.totalBurned += amount; // Track total burned
          tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker]) - amount - gasFee).toFixed(2); // Deduct from creator's balance
          currentToken.marketCap = (parseFloat(currentToken.price) * currentToken.supply * AVAX_PRICE).toFixed(2); // Update market cap
          currentToken.transactions.push({
            type: 'Burn',
            amount: `${amount.toFixed(2)} ${currentToken.ticker}`,
            timestamp: new Date().toLocaleString()
          });
          updateBurnSection();
          updateBalanceModal();
          updatePortfolio();
          updateTokenLists(); // Update lists to reflect new supply/market cap
          notify(`Burned ${amount} ${currentToken.ticker}. New supply: ${currentToken.supply.toLocaleString()}`);
          playSound();
        } else {
          notify('Burn cancelled.');
        }
      });
    });

    // Updates the burn section display and chart
    function updateBurnSection() {
      document.getElementById('totalBurned').textContent = currentToken.totalBurned.toFixed(2);
      const remainingPercent = (currentToken.supply / currentToken.originalSupply * 100).toFixed(2);
      document.getElementById('supplyRemaining').textContent = remainingPercent;

      if (burnChart) burnChart.destroy();
      burnChart = new Chart(document.querySelector('#burnSection canvas').getContext('2d'), {
        type: 'bar',
        data: {
          labels: ['Tokens Burned'],
          datasets: [{
            label: 'Burn Progress',
            data: [currentToken.totalBurned],
            backgroundColor: '#ff4d4d',
            borderColor: '#ff4d4d',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              max: currentToken.originalSupply, // Max Y-axis is original total supply
              ticks: { color: '#fff' },
              grid: { color: 'rgba(255,255,255,0.1)' }
            },
            x: {
              ticks: { color: '#fff' },
              grid: { color: 'rgba(255,255,255,0.1)' }
            }
          },
          plugins: {
            legend: { display: false },
            title: { display: true, text: 'Token Burn Progress', color: '#fff' }
          }
        }
      });
    }

    // --- Airdrop Claim Logic ---
    document.getElementById('claimAirdropBtn').addEventListener('click', () => {
      if (!wallet) {
        showMessageBox('Please sign in by initializing the app.');
        return;
      }
      if (!currentToken.vestingStart) {
        showMessageBox('Airdrop vesting has not started yet.');
        return;
      }
      const gasFee = 0.01;

      const elapsed = Date.now() - currentToken.vestingStart;
      const totalAirdrop = currentToken.originalSupply * (currentToken.airdropPercentage / 100);
      const vestedAmount = (totalAirdrop * Math.min(elapsed / currentToken.vestingDuration, 1));
      const claimable = vestedAmount - currentToken.airdropClaimed;

      if (claimable <= 0.001) { // Small threshold to avoid claiming tiny amounts
        showMessageBox('No significant tokens available to claim yet.');
        return;
      }
      if (gasFee > parseFloat(avaxBalance)) {
        showMessageBox('Insufficient AVAX balance for gas fee to claim airdrop.');
        return;
      }

      showConfirmBox(`Confirm claiming ${claimable.toFixed(2)} ${currentToken.ticker} from airdrop? (Gas fee: ${gasFee} AVAX)`, (confirmed) => {
        if (confirmed) {
          tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) + claimable).toFixed(2);
          currentToken.airdropClaimed += claimable;
          avaxBalance = (parseFloat(avaxBalance) - gasFee).toFixed(2); // Deduct gas
          currentToken.transactions.push({
            type: 'Airdrop Claim',
            amount: `${claimable.toFixed(2)} ${currentToken.ticker}`,
            timestamp: new Date().toLocaleString()
          });
          updateAirdropSection();
          updateBalanceModal();
          updatePortfolio();
          notify(`Claimed ${claimable.toFixed(2)} ${currentToken.ticker} from airdrop.`);
          playSound();
        } else {
          notify('Airdrop claim cancelled.');
        }
      });
    });

    // Updates the airdrop section display
    function updateAirdropSection() {
      const totalAirdrop = currentToken.originalSupply * (currentToken.airdropPercentage / 100);
      const elapsed = currentToken.vestingStart ? (Date.now() - currentToken.vestingStart) : 0;
      const vestedPercent = currentToken.vestingStart ? Math.min(elapsed / currentToken.vestingDuration, 1) * 100 : 0;
      const claimable = (totalAirdrop * vestedPercent / 100) - currentToken.airdropClaimed;

      document.getElementById('airdropTotal').textContent = totalAirdrop.toFixed(2);
      document.getElementById('airdropClaimable').textContent = claimable.toFixed(2);
      document.getElementById('vestingProgress').textContent = vestedPercent.toFixed(2);

      // Disable claim button if nothing claimable or not started
      document.getElementById('claimAirdropBtn').disabled = (claimable <= 0.001 || !currentToken.vestingStart);
    }

    // --- Transaction History Page Logic ---
    document.getElementById('viewTransactionsBtn').addEventListener('click', () => {
      document.getElementById('tokenDetailsPage').classList.add('hidden'); // Hide token details
      document.getElementById('transactionPage').classList.remove('hidden'); // Show transaction page
      updateTransactionHistory(); // Populate history
      playSound();
    });
    document.getElementById('backTransactions').addEventListener('click', () => {
      document.getElementById('transactionPage').classList.add('hidden'); // Hide transaction page
      document.getElementById('tokenDetailsPage').classList.remove('hidden'); // Show token details
      playSound();
    });

    // Populates the transaction history display
    function updateTransactionHistory() {
      const historyElement = document.getElementById('transactionHistory');
      historyElement.innerHTML = '<h3 class="text-lg font-semibold mb-2">Transaction History</h3>';
      if (currentToken && currentToken.transactions.length > 0) {
        // Display transactions in reverse chronological order
        currentToken.transactions.slice().reverse().forEach(tx => {
          historyElement.innerHTML += `<p class="mb-1">${tx.timestamp}: <strong>${tx.type}</strong> - ${tx.amount} ${tx.token || ''}</p>`;
        });
      } else {
        historyElement.innerHTML += '<p>No transactions yet for this token.</p>';
      }
    }

    // --- Community Chat Page Logic ---
    document.getElementById('viewChatBtn').addEventListener('click', () => {
      document.getElementById('tokenDetailsPage').classList.add('hidden'); // Hide token details
      document.getElementById('chatPage').classList.remove('hidden'); // Show chat page
      updateChat(); // Populate chat messages
      playSound();
    });
    document.getElementById('backChat').addEventListener('click', () => {
      document.getElementById('chatPage').classList.add('hidden'); // Hide chat page
      document.getElementById('tokenDetailsPage').classList.remove('hidden'); // Show token details
      playSound();
    });

    // Sends a message to the simulated chat
    document.getElementById('sendChat').addEventListener('click', () => {
      if (!wallet) {
        showMessageBox('Please sign in by initializing the app.');
        return;
      }
      const message = document.getElementById('chatInput').value.trim();
      if (!message) {
        showMessageBox('Please enter a message.');
        return;
      }

      // Determine sentiment based on keywords
      const lowerCaseMessage = message.toLowerCase();
      const sentiment = lowerCaseMessage.includes('fud') || lowerCaseMessage.includes('bad') || lowerCaseMessage.includes('sell') || lowerCaseMessage.includes('scam') ? 'negative' :
                       lowerCaseMessage.includes('moon') || lowerCaseMessage.includes('great') || lowerCaseMessage.includes('buy') || lowerCaseMessage.includes('lfg') ? 'positive' : 'neutral';

      // Add user's message to chat history
      currentToken.chat.push({ address: wallet.address, message, sentiment, timestamp: new Date().toLocaleString() });

      // Simulate price impact based on user's message sentiment
      if (sentiment === 'negative' && parseFloat(currentToken.price) > 0) currentToken.price = (parseFloat(currentToken.price) * 0.95).toFixed(8); // 5% price drop
      else if (sentiment === 'positive') currentToken.price = (parseFloat(currentToken.price) * 1.05).toFixed(8); // 5% price increase
      currentToken.marketCap = (parseFloat(currentToken.price) * currentToken.supply * AVAX_PRICE).toFixed(2);
      currentToken.priceHistory.push({ price: parseFloat(currentToken.price), timestamp: new Date().toLocaleString(), type: sentiment });

      // Simulate bot replies
      if (Math.random() < 0.5) { // 50% chance for a bot reply
        const botMessages = {
          positive: ['This is going to the moon!', 'Great project, HODL!', 'Buying more!', 'LFG!'],
          negative: ['FUD alert, dumping now!', 'This is a scam!', 'Sell before it crashes!', 'Looks like a rug.'],
          neutral: ['Interesting project.', 'Watching this one.', 'Any updates?', 'What are your thoughts?']
        };
        // Bot sentiment can be similar to user's or random
        const botSentiment = Math.random() < 0.5 ? sentiment : ['positive', 'negative', 'neutral'][Math.floor(Math.random() * 3)];
        currentToken.chat.push({
          address: ethers.Wallet.createRandom().address, // Random bot address
          message: botMessages[botSentiment][Math.floor(Math.random() * botMessages[botSentiment].length)],
          sentiment: botSentiment,
          timestamp: new Date().toLocaleString()
        });
        // Simulate price impact from bot message
        if (botSentiment === 'negative' && parseFloat(currentToken.price) > 0) currentToken.price = (parseFloat(currentToken.price) * 0.95).toFixed(8);
        else if (botSentiment === 'positive') currentToken.price = (parseFloat(currentToken.price) * 1.05).toFixed(8);
        currentToken.marketCap = (parseFloat(currentToken.price) * currentToken.supply * AVAX_PRICE).toFixed(2);
        currentToken.priceHistory.push({ price: parseFloat(currentToken.price), timestamp: new Date().toLocaleString(), type: botSentiment });
      }

      updateChat(); // Refresh chat display
      updatePriceChart(); // Update price chart
      updateTokenLists(); // Update token lists (market cap changes)
      document.getElementById('chatInput').value = ''; // Clear input
      notify('Message sent!');
      playSound();
    });

    // Populates the chat messages and updates sentiment display
    function updateChat() {
      const sentimentCounts = { positive: 0, negative: 0, neutral: 0 };
      currentToken.chat.forEach(msg => sentimentCounts[msg.sentiment]++); // Count sentiments

      const total = sentimentCounts.positive + sentimentCounts.negative + sentimentCounts.neutral;
      // Determine overall sentiment
      const sentimentText = total === 0 ? 'Neutral' :
                       sentimentCounts.negative > sentimentCounts.positive ? 'Bearish' :
                       sentimentCounts.positive > sentimentCounts.negative ? 'Bullish' : 'Neutral';

      document.getElementById('chatSentiment').textContent = sentimentText;
      document.getElementById('chatSentiment').className = `font-semibold ${sentimentText === 'Bullish' ? 'text-green-400' : sentimentText === 'Bearish' ? 'text-red-400' : 'text-gray-400'}`;

      const chatMessagesDiv = document.getElementById('chatMessages');
      chatMessagesDiv.innerHTML = ''; // Clear existing messages
      // Display messages in chronological order
      currentToken.chat.forEach(msg => {
        const color = msg.sentiment === 'positive' ? 'text-green-400' : msg.sentiment === 'negative' ? 'text-red-400' : 'text-gray-400';
        chatMessagesDiv.innerHTML += `<p class="${color}">${msg.timestamp} [${msg.address.slice(0, 6)}...]: ${msg.message}</p>`;
      });
      chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight; // Scroll to bottom of chat
    }

    // --- Chart.js Instances and Update Functions ---
    // Updates or initializes the contribution bar chart
    function updateContributionChart() {
      const ctx = document.getElementById('contributionChart').getContext('2d');
      if (contributionChart) contributionChart.destroy(); // Destroy existing chart before creating new one
      if (currentToken.stage === 'whitelist') {
        contributionChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: ['Contributed AVAX'],
            datasets: [{
              label: 'Contribution Progress',
              data: [currentToken.totalContributed],
              backgroundColor: '#00ffaa',
              borderColor: '#00ffaa',
              borderWidth: 1
            }]
          },
          options: {
            responsive: true, // Make chart responsive
            maintainAspectRatio: false, // Allow height to be set by CSS
            scales: {
              y: {
                beginAtZero: true,
                max: currentToken.maxContribution, // Max contribution limit
                ticks: { color: '#fff' }, // Y-axis label color
                grid: { color: 'rgba(255,255,255,0.1)' } // Grid line color
              },
              x: {
                ticks: { color: '#fff' }, // X-axis label color
                grid: { color: 'rgba(255,255,255,0.1)' } // Grid line color
              }
            },
            plugins: {
                legend: { display: false }, // Hide legend
                title: { display: true, text: 'Whitelist Contribution', color: '#fff' } // Chart title
            }
          }
        });
      }
    }

    // Updates or initializes the price line chart
    function updatePriceChart() {
      const ctx = document.getElementById('priceChart').getContext('2d');
      if (priceChart) priceChart.destroy(); // Destroy existing chart before creating new one
      if (currentToken.stage === 'trading') {
        priceChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: currentToken.priceHistory.map(h => h.timestamp),
            datasets: [{
              label: 'Price (USD)',
              data: currentToken.priceHistory.map(h => parseFloat(h.price) * AVAX_PRICE), // Convert to USD for display
              borderColor: currentToken.priceHistory.slice(-1)[0]?.type === 'buy' || currentToken.priceHistory.slice(-1)[0]?.type === 'positive' ? '#00ffaa' : '#ff4d4d',
              backgroundColor: currentToken.priceHistory.slice(-1)[0]?.type === 'buy' || currentToken.priceHistory.slice(-1)[0]?.type === 'positive' ? 'rgba(0, 255, 170, 0.2)' : 'rgba(255, 77, 77, 0.2)',
              fill: true,
              tension: 0.4 // Smooth line
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: false,
                ticks: { color: '#fff' },
                grid: { color: 'rgba(255,255,255,0.1)' }
              },
              x: {
                ticks: { color: '#fff' },
                grid: { color: 'rgba(255,255,255,0.1)' }
              }
            },
            plugins: {
                legend: { display: false },
                title: { display: true, text: 'Token Price History (USD)', color: '#fff' }
            }
          }
        });
      }
    }

    // --- Token Lists Update ---
    // Populates the Whitelist, Trading, and Trending sections on the main page
    function updateTokenLists() {
      const whitelistTokensDiv = document.getElementById('whitelistTokens');
      const tradingTokensDiv = document.getElementById('tradingTokens');
      const trendingTokensDiv = document.getElementById('trendingTokens');
      // Clear existing content
      whitelistTokensDiv.innerHTML = '';
      tradingTokensDiv.innerHTML = '';
      trendingTokensDiv.innerHTML = '';

      // Populate Whitelist Tokens
      tokens.filter(t => t.stage === 'whitelist').forEach(token => {
        whitelistTokensDiv.innerHTML += `
          <div class="bg-gray-700 p-4 rounded-lg mb-2 cursor-pointer transition-transform transform hover:scale-105" data-ticker="${token.ticker}">
            <p><strong>${token.ticker}</strong> - ${token.name}</p>
            <p>Contributed: ${token.totalContributed.toFixed(2)}/500 AVAX</p>
            <p>Timer: <span id="timer-${token.ticker}"></span></p>
          </div>`;
      });

      // Populate Trading Tokens
      tokens.filter(t => t.stage === 'trading').forEach(token => {
        tradingTokensDiv.innerHTML += `
          <div class="bg-gray-700 p-4 rounded-lg mb-2 cursor-pointer transition-transform transform hover:scale-105" data-ticker="${token.ticker}">
            <p><strong>${token.ticker}</strong> - ${token.name}</p>
            <p>Price: $${parseFloat(token.price * AVAX_PRICE).toFixed(4)}</p>
            <p>Market Cap: $${parseFloat(token.marketCap).toFixed(2)}</p>
          </div>`;
      });

      // Populate Trending Tokens (sorted by boost level then market cap)
      const sortedTokens = [...tokens].sort((a, b) => {
        // Boosted tokens come first, higher boost level means higher rank (lower number)
        if (a.boostLevel > 0 && b.boostLevel > 0) return a.boostLevel - b.boostLevel;
        if (a.boostLevel > 0) return -1; // a is boosted, b is not
        if (b.boostLevel > 0) return 1;  // b is boosted, a is not
        // If neither are boosted, sort by market cap (descending)
        return b.marketCap - a.marketCap;
      });

      sortedTokens.forEach((token, index) => {
        trendingTokensDiv.innerHTML += `
          <div class="bg-gray-700 p-4 rounded-lg mb-2 cursor-pointer transition-transform transform hover:scale-105" data-ticker="${token.ticker}">
            <p><strong>#${index + 1} ${token.ticker}</strong> - ${token.name} ${token.boostLevel > 0 ? `(Boosted Rank ${token.boostLevel})` : ''}</p>
            <p>Market Cap: $${parseFloat(token.marketCap).toFixed(2)}</p>
            <p>Price: $${parseFloat(token.price * AVAX_PRICE).toFixed(4)}</p>
          </div>`;
      });

      // Add click listeners to newly added token divs to show details
      document.querySelectorAll('#whitelistTokens > div, #tradingTokens > div, #trendingTokens > div').forEach(div => {
        div.addEventListener('click', () => {
          showTokenDetails(div.dataset.ticker);
          playSound();
        });
      });

      // Update timers for whitelist tokens (if not currently viewed in detail)
      tokens.forEach(token => {
        if (token.stage === 'whitelist') {
          const timeLeft = token.whitelistEndTime - Date.now();
          if (timeLeft > 0) {
            const hours = Math.floor(timeLeft / 3600000);
            const minutes = Math.floor((timeLeft % 3600000) / 60000);
            const seconds = Math.floor((timeLeft % 60000) / 1000);
            const timerElement = document.getElementById(`timer-${token.ticker}`);
            if (timerElement) timerElement.textContent = `${hours}h ${minutes}m ${seconds}s`;
          }
        }
      });
    }

    // --- Bot Simulation Logic ---
    // Simulates the creation of initial bot-launched tokens
    function simulateBotTokens() {
      const botTokenNames = ['MoonCoin', 'StarToken', 'CryptoGem', 'HypeCoin', 'RocketToken', 'AlphaCoin', 'GemHunter', 'PumpToken'];
      for (let i = 0; i < 3; i++) { // Launch 3 bot tokens initially
        const tokenData = {
          name: botTokenNames[Math.floor(Math.random() * botTokenNames.length)],
          ticker: `BOT${Math.floor(Math.random() * 9000) + 1000}`, // Random 4-digit ticker
          supply: Math.floor(Math.random() * 90000000) + 10000000, // 10M to 100M supply
          originalSupply: Math.floor(Math.random() * 90000000) + 10000000,
          image: `https://placehold.co/150x150/${Math.floor(Math.random()*16777215).toString(16)}/ffffff?text=BOT`, // Random colored placeholder
          twitter: '',
          discord: '',
          duration: (Math.random() * 180000) + 60000, // 1 min to 3 min whitelist
          minContribution: 0.05,
          maxContribution: 50,
          airdropPercentage: Math.floor(Math.random() * 30) + 10, // 10-40% airdrop
          vestingDuration: (Math.random() * 2592000000) + 86400000, // 1 day to 1 month vesting
          vestingStart: null,
          airdropClaimed: 0,
          totalBurned: 0,
          creatorWallet: ethers.Wallet.createRandom().address,
          stage: Math.random() > 0.5 ? 'whitelist' : 'trading', // Randomly start in whitelist or trading
          totalContributed: 0,
          transactions: [],
          chat: [],
          price: 0,
          priceHistory: [],
          boostLevel: 0,
          marketCap: 0,
          liquidity: { avax: 0, token: 0, userShares: {}, fees: {} },
          whitelistEndTime: Date.now() + ((Math.random() * 180000) + 60000)
        };

        if (tokenData.stage === 'trading') {
          // If starting in trading, simulate a completed whitelist and initial liquidity
          tokenData.totalContributed = Math.random() * 500; // Random contribution up to max
          const liquidityTokenAmount = tokenData.supply * 0.5;
          tokenData.price = (tokenData.totalContributed / liquidityTokenAmount).toFixed(8);
          tokenData.marketCap = (parseFloat(tokenData.price) * tokenData.supply * AVAX_PRICE).toFixed(2);
          tokenData.priceHistory.push({ price: parseFloat(tokenData.price), timestamp: new Date().toLocaleString(), type: 'init' });
          tokenData.vestingStart = Date.now(); // Vesting starts immediately for trading tokens

          const pool = liquidityPools[tokenData.ticker];
          pool.avax = tokenData.totalContributed;
          pool.token = liquidityTokenAmount;
          pool.totalShares = Math.sqrt(pool.avax * pool.token);
          pool.userShares[tokenData.creatorWallet] = pool.totalShares;
          pool.fees[tokenData.creatorWallet] = 0;
        }
        tokens.push(tokenData);
        if (tokenData.stage === 'whitelist') startWhitelistTimer(tokenData); // Only start timer if in whitelist
      }
      updateTokenLists();
    }

    // Simulates ongoing bot activity (trading, FUD, rug pulls)
    function simulateBotActivity() {
      tokens.forEach(token => {
        // Continue bot contributions for whitelist tokens
        if (token.stage === 'whitelist' && token.totalContributed < 500) {
          const botAmount = Math.random() * (token.maxContribution - token.minContribution) / 5; // Smaller bot contributions
          if (token.totalContributed + botAmount > 500) {
              token.totalContributed = 500;
          } else {
              token.totalContributed += botAmount;
          }
          token.transactions.push({ type: 'Bot Contribution', amount: botAmount.toFixed(2), token: 'AVAX', timestamp: new Date().toLocaleString() });
        }
        // Simulate trading activity for tokens in trading stage
        if (token.stage === 'trading') {
          const action = Math.random();
          const pool = liquidityPools[token.ticker];

          if (action < 0.02 && parseFloat(token.price) > 0.0001) { // 2% chance for a "rug pull" (price crash)
            token.price = 0.000001; // Simulate near-zero value
            token.marketCap = 0;
            token.priceHistory.push({ price: token.price, timestamp: new Date().toLocaleString(), type: 'rug' });
            token.chat.push({ address: ethers.Wallet.createRandom().address.slice(0,6) + '...', message: 'Rug pull! Devs dumped everything!', sentiment: 'negative', timestamp: new Date().toLocaleString() });
            notify(`${token.ticker} has been rugged! Price crashed.`);
          } else if (action < 0.4) { // 38% chance to buy (price increase)
            const botAvaxBuyAmount = Math.random() * 10; // Simulate buying up to 10 AVAX worth
            if (pool.avax >= botAvaxBuyAmount) { // Ensure pool has enough AVAX
                const initialPoolToken = pool.token;
                pool.avax += botAvaxBuyAmount;
                const newTokenAmount = (pool.avax * initialPoolToken) / (pool.avax); // Simplified formula for new token amount
                const tokensReceived = initialPoolToken - newTokenAmount;

                pool.token = newTokenAmount;
                token.price = (pool.avax / pool.token).toFixed(8); // Price in AVAX
                token.marketCap = (parseFloat(token.price) * token.supply * AVAX_PRICE).toFixed(2);
                token.priceHistory.push({ price: parseFloat(token.price), timestamp: new Date().toLocaleString(), type: 'buy' });
                token.transactions.push({ type: 'Bot Swap (Buy)', amount: `${tokensReceived.toFixed(2)} ${token.ticker} for ${botAvaxBuyAmount.toFixed(2)} AVAX`, timestamp: new Date().toLocaleString() });
                token.chat.push({ address: ethers.Wallet.createRandom().address.slice(0,6) + '...', message: 'Buying the dip, let‚Äôs moon!', sentiment: 'positive', timestamp: new Date().toLocaleString() });
                // Simulate fees to LPs
                Object.keys(pool.userShares).forEach(user => {
                    pool.fees[user] = (pool.fees[user] || 0) + (botAvaxBuyAmount * 0.003 * (pool.userShares[user] / pool.totalShares));
                });
            }
          } else if (action < 0.75) { // 35% chance to sell/FUD (price decrease)
            const botTokenSellAmount = Math.random() * 1000; // Simulate selling up to 1000 tokens
            if (parseFloat(token.price) > 0.0001 && pool.token >= botTokenSellAmount) { // Only sell if price is not already near zero and pool has tokens
              const initialPoolAvax = pool.avax;
              pool.token += botTokenSellAmount;
              const newAvaxAmount = (initialPoolAvax * pool.token) / (pool.token); // Simplified formula
              const avaxReceived = initialPoolAvax - newAvaxAmount;

              pool.avax = newAvaxAmount;
              token.price = (pool.avax / pool.token).toFixed(8);
              token.marketCap = (parseFloat(token.price) * token.supply * AVAX_PRICE).toFixed(2);
              token.priceHistory.push({ price: parseFloat(token.price), timestamp: new Date().toLocaleString(), type: 'sell' });
              token.transactions.push({ type: 'Bot Swap (Sell)', amount: `${botTokenSellAmount.toFixed(2)} ${token.ticker} for ${avaxReceived.toFixed(2)} AVAX`, timestamp: new Date().toLocaleString() });
              token.chat.push({ address: ethers.Wallet.createRandom().address.slice(0,6) + '...', message: 'FUD! Selling before it crashes!', sentiment: 'negative', timestamp: new Date().toLocaleString() });
              // Simulate fees to LPs
              Object.keys(pool.userShares).forEach(user => {
                  pool.fees[user] = (pool.fees[user] || 0) + (avaxReceived * 0.003 * (pool.userShares[user] / pool.totalShares));
              });
            }
          }
          // Bot staking (small chance)
          if (stakingPools[token.ticker] && Math.random() < 0.1) {
            const botStake = Math.random() * 10;
            stakingPools[token.ticker].totalStaked += botStake;
            stakingPools[token.ticker].users += 1;
            stakingPools[token.ticker].rewards += botStake * (stakingPools[token.ticker].apr / 100) / 365;
          }
        }
      });
      updateTokenLists(); // Refresh all lists
      if (currentToken) { // If a token details page is open, refresh its charts and chat
        updateChat();
        updatePriceChart();
        updateLiquiditySection();
        updateBurnSection();
        updateAirdropSection();
      }
      updateStakingModal(); // Refresh staking pools
      updateBalanceModal(); // Refresh user's balance
      updatePortfolio(); // Refresh portfolio
    }

    // --- Initial App Load ---
    // Ensures the app initializes once the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', initialize);
  </script>
</body>
</html>
