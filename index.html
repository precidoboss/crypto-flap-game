<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WL LAUNCHER</title>
  <!-- Tailwind CSS CDN for styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Ethers.js for blockchain interaction simulation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" xintegrity="sha512-J3ZEBLi4nVWXLG7X2G2G6I8y5H2Z8g8cOsgcry1TyXBRcS3PXmRPW59Leverlyk5T3w29f4b0N0OQA9A77+RHVw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <!-- Chart.js for data visualization -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Font for consistent typography -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    /* Custom CSS for glowing effects and neon buttons */
    .glowing-box {
      border: 2px solid #00ffaa;
      box-shadow: 0 0 10px #00ffaa, 0 0 20px #00ffaa;
      background: rgba(0, 255, 170, 0.1);
      transition: all 0.3s ease;
    }
    .glowing-box:hover {
      box-shadow: 0 0 15px #00ffaa, 0 0 30px #00ffaa;
      transform: scale(1.02);
    }
    .neon-btn {
      background: linear-gradient(45deg, #00ffaa, #ff4d4d);
      border: none;
      box-shadow: 0 0 10px #00ffaa;
      transition: all 0.3s ease;
    }
    .neon-btn:hover {
      box-shadow: 0 0 15px #00ffaa, 0 0 25px #ff4d4d;
      transform: scale(1.05);
    }
    .chart-container {
      position: relative;
      max-height: 300px; /* Limits height for scrollability */
      overflow-y: auto; /* Enables vertical scrolling if content overflows */
      border: 2px solid #00ffaa;
      border-radius: 8px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
    }
    .candlestick-green {
      background-color: #00ffaa;
      border-color: #00ffaa;
    }
    .candlestick-red {
      background-color: #ff4d4d;
      border-color: #ff4d4d;
    }
    .animated-balance {
      animation: pulse 2s infinite; /* Animation for balance display */
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    /* New CSS for full-screen modals and scroll locking */
    #autoTradeModal, #launchPage {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem;
      box-sizing: border-box;
    }

    #autoTradeModal.hidden, #launchPage.hidden {
      display: none;
    }

    #autoTradeModal > div, #launchPage > div {
      max-width: 600px;
      width: 100%;
      background: #1a1a1a;
      border: 2px solid #00ffaa;
      border-radius: 8px;
      padding: 1.5rem;
      box-shadow: 0 0 20px rgba(0, 255, 170, 0.5);
    }

    body.modal-open {
      overflow: hidden; /* Prevents scrolling on the body when a modal is open */
    }
  </style>
</head>
<body class="min-h-screen text-white font-poppins bg-gradient-to-b from-gray-900 to-gray-700 transition-colors duration-300" id="app">
  <!-- Header Section -->
  <header class="w-full bg-gradient-to-r from-purple-600 to-blue-600 p-4 flex justify-between items-center sticky top-0 z-10 shadow-lg">
    <h1 class="text-3xl font-extrabold text-white">WL LAUNCHER</h1>
    <div class="flex items-center space-x-2">
      <!-- Notification Button -->
      <button id="notificationBtn" class="relative text-2xl">ðŸ””<span id="notificationCount" class="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-4 w-4 flex items-center justify-center hidden">0</span></button>
      <!-- Menu Button -->
      <button id="menuBtn" class="text-2xl">â˜°</button>
    </div>
  </header>

  <!-- Main Content Area -->
  <main class="container mx-auto p-4 space-y-6">
    <!-- Whitelist Tokens Section -->
    <section id="whitelistSection" class="glowing-box p-6 rounded-lg">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-2xl font-bold">Whitelist Tokens</h2>
        <button id="toggleWhitelist" class="neon-btn text-white px-2 py-1 rounded text-sm">Collapse</button>
      </div>
      <div id="whitelistTokens" class="space-y-4"></div>
    </section>
    <!-- Trading Tokens Section -->
    <section id="tradingSection" class="glowing-box p-6 rounded-lg">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-2xl font-bold">Trading Tokens</h2>
        <button id="toggleTrading" class="neon-btn text-white px-2 py-1 rounded text-sm">Collapse</button>
      </div>
      <div id="tradingTokens" class="space-y-4"></div>
    </section>
    <!-- Trending Tokens Section -->
    <section id="trendingSection" class="glowing-box p-6 rounded-lg">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-2xl font-bold">Trending Tokens</h2>
        <button id="toggleTrending" class="neon-btn text-white px-2 py-1 rounded text-sm">Collapse</button>
      </div>
      <div id="trendingTokens" class="space-y-4"></div>
    </section>
  </main>

  <!-- Menu Modal -->
  <div id="menuModal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Menu</h2>
      <button id="balanceBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Balances</button>
      <button id="portfolioBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Portfolio</button>
      <button id="stakingBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Staking</button>
      <button id="liquidityBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Liquidity</button>
      <button id="claimBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Claim Tokens</button>
      <button id="autoTradeBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Automated Trading</button>
      <button id="votingBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Voting</button>
      <button id="questsBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Quests</button>
      <button id="treasuryBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Platform Treasury</button>
      <button id="launchTokenBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Launch Token</button>
      <button id="swapBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Swap</button>
      <button id="settingsBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Settings</button>
      <button id="closeMenu" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded">Close</button>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Settings</h2>
      <label class="block mb-2">Theme</label>
      <select id="themeSelect" class="w-full bg-gray-700 text-white p-2 rounded mb-4">
        <option value="dark">Dark</option>
        <option value="light">Light</option>
        <option value="neon">Neon</option>
      </select>
      <label class="block mb-2"><input type="checkbox" id="soundEffects" checked> Sound Effects</label>
      <label class="block mb-2"><input type="checkbox" id="notifications" checked> Notifications</label>
      <button id="closeSettings" class="w-full neon-btn text-white px-4 py-2 rounded">Save & Close</button>
    </div>
  </div>

  <!-- Balance Modal -->
  <div id="balanceModal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Balances</h2>
      <div class="animated-balance">
        <p><strong>Total Value:</strong> $<span id="totalValue">0</span></p>
        <p><strong>AVAX:</strong> <span id="balanceAvax">0</span> (~$<span id="balanceAvaxValue">0</span>)</p>
        <div id="tokenBalances" class="space-y-2"></div>
      </div>
      <button id="closeBalance" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Close</button>
    </div>
  </div>

  <!-- Portfolio Page -->
  <div id="portfolioPage" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Portfolio</h2>
      <p><strong>Total Value:</strong> $<span id="portfolioValue">0</span></p>
      <p><strong>PnL:</strong> $<span id="portfolioPnL">0</span></p>
      <div class="chart-container">
        <canvas></canvas>
      </div>
      <div class="chart-container mt-4">
        <canvas></canvas>
      </div>
      <div id="portfolioHoldings" class="mt-4"></div>
      <button id="exportPortfolio" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Export CSV</button>
      <button id="backPortfolio" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded mt-2">Back</button>
    </div>
  </div>

  <!-- Staking Modal -->
  <div id="stakingModal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Staking</h2>
      <label class="block mb-2">Token</label>
      <select id="supplyToken" class="w-full bg-gray-700 text-white p-2 rounded mb-4"></select>
      <label class="block mb-2">Asset</label>
      <select id="supplyAsset" class="w-full bg-gray-700 text-white p-2 rounded mb-4"></select>
      <label class="block mb-2">Amount</label>
      <input id="supplyAmount" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0.0">
      <label class="block mb-2">APR (%)</label>
      <input id="supplyAPR" type="number" step="0.1" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0.0">
      <button id="supplyBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-4">Supply</button>
      <div id="stakePools" class="space-y-4"></div>
      <button id="closeStaking" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Close</button>
      <button id="backStaking" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded mt-2">Back</button>
    </div>
  </div>

  <!-- Liquidity Modal -->
  <div id="liquidityModal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Liquidity</h2>
      <label class="block mb-2">Token</label>
      <select id="liquidityToken" class="w-full bg-gray-700 text-white p-2 rounded mb-4"></select>
      <label class="block mb-2">Supply Type</label>
      <select id="supplyType" class="w-full bg-gray-700 text-white p-2 rounded mb-4">
        <option value="single">Single-Sided</option>
        <option value="dual">Dual-Sided</option>
      </select>
      <div id="singleSupply">
        <label class="block mb-2">AVAX Amount</label>
        <input id="avaxAmount" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0.0">
      </div>
      <div id="dualSupply" class="hidden">
        <label class="block mb-2">AVAX Amount</label>
        <input id="dualAvaxAmount" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0.0">
        <label class="block mb-2">Token Amount</label>
        <input id="dualTokenAmount" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0.0" readonly>
      </div>
      <button id="addLiquidityBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-4">Add Liquidity</button>
      <div id="poolAnalytics" class="mt-4">
        <p><strong>TVL:</strong> $<span id="poolTVL">0</span></p>
        <p><strong>Your Share:</strong> <span id="poolShare">0</span>%</p>
        <p><strong>Fees Earned:</strong> <span id="feesEarned">0</span> AVAX</p>
        <p><strong>APR:</strong> <span id="poolAPR">0</span>%</p>
        <p><strong>Impermanent Loss:</strong> <span id="impermanentLoss">0</span>%</p>
      </div>
      <button id="removeLiquidityBtn" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Remove Liquidity</button>
      <button id="closeLiquidity" class="w-full neon-btn text-white px-4 py-2 rounded mt-2">Close</button>
    </div>
  </div>

  <!-- Claim Tokens Modal -->
  <div id="claimModal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Claim Tokens</h2>
      <label class="block mb-2">Token</label>
      <select id="claimToken" class="w-full bg-gray-700 text-white p-2 rounded mb-4"></select>
      <button id="claimAirdropBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-4">Claim Airdrop</button>
      <div id="airdropInfo" class="mt-4">
        <p><strong>Total Airdrop:</strong> <span id="airdropTotal">0</span></p>
        <p><strong>Claimable:</strong> <span id="airdropClaimable">0</span></p>
        <p><strong>Vesting Progress:</strong> <span id="vestingProgress">0</span>%</p>
      </div>
      <button id="closeClaim" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Close</button>
    </div>
  </div>

  <!-- Voting Modal -->
  <div id="votingModal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Voting</h2>
      <label class="block mb-2">Token</label>
      <select id="voteToken" class="w-full bg-gray-700 text-white p-2 rounded mb-4"></select>
      <label class="block mb-2">Proposal</label>
      <input id="proposalText" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="Enter proposal">
      <label class="block mb-2">Options (comma-separated)</label>
      <input id="proposalOptions" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="Option1,Option2">
      <label class="block mb-2">Reward (AVAX)</label>
      <input id="proposalReward" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0.0">
      <button id="createProposalBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-4">Create Proposal</button>
      <div id="activeProposals" class="space-y-4"></div>
      <button id="closeVoting" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Close</button>
    </div>
  </div>

  <!-- Quests Modal -->
  <div id="questsModal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Quests</h2>
      <label class="block mb-2">Token</label>
      <select id="questToken" class="w-full bg-gray-700 text-white p-2 rounded mb-4"></select>
      <label class="block mb-2">Quest Description</label>
      <input id="questDescription" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="e.g., Buy 10 AVAX of token">
      <label class="block mb-2">Reward (Tokens)</label>
      <input id="questReward" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0.0">
      <button id="createQuestBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-4">Create Quest</button>
      <div id="activeQuests" class="space-y-4"></div>
      <button id="closeQuests" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Close</button>
    </div>
  </div>

  <!-- Treasury Modal -->
  <div id="treasuryModal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Platform Treasury</h2>
      <p><strong>Total Fees Collected:</strong> <span id="treasuryBalance">0</span> AVAX</p>
      <button id="closeTreasury" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Close</button>
    </div>
  </div>

  <!-- Swap Page -->
  <div id="swapPage" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Swap</h2>
      <label class="block mb-2">Token</label>
      <select id="swapToken" class="w-full bg-gray-700 text-white p-2 rounded mb-4"></select>
      <label class="block mb-2">AVAX Amount</label>
      <input id="tradeAvaxAmount" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4 animated-balance" placeholder="0.0">
      <label class="block mb-2">Token Amount</label>
      <input id="tradeTokenAmount" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4 animated-balance" placeholder="0.0" readonly>
      <label class="block mb-2">Slippage Tolerance (%)</label>
      <select id="slippageSelect" class="w-full bg-gray-700 text-white p-2 rounded mb-4">
        <option value="0.5">0.5%</option>
        <option value="1">1%</option>
        <option value="3">3%</option>
      </select>
      <button id="tradeBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-4">Swap</button>
      <button id="backSwap" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded mt-2">Back</button>
    </div>
  </div>

  <!-- Token Details Page -->
  <div id="tokenDetailsPage" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Token Details</h2>
      <div class="glowing-box p-4 rounded-lg mb-4">
        <img id="tokenImg" class="w-16 h-16 rounded-full mx-auto mb-2 border-2 border-neon-green">
        <table class="w-full text-sm">
          <tr><td class="font-bold">Name:</td><td id="displayTokenName"></td></tr>
          <tr><td class="font-bold">Ticker:</td><td id="displayTokenTicker"></td></tr>
          <tr><td class="font-bold">Supply:</td><td id="displayTokenSupply"></td></tr>
          <tr><td class="font-bold">Market Cap:</td><td>$<span id="marketCap">0</span></td></tr>
          <tr><td class="font-bold">Price:</td><td>$<span id="tokenPrice">0</span></td></tr>
          <tr><td class="font-bold">FDV:</td><td>$<span id="fdv">0</span></td></tr>
          <tr><td class="font-bold">Locked Liquidity:</td><td>$<span id="lockedLiquidity">0</span></td></tr>
          <tr><td class="font-bold">Creator Fee:</td><td><span id="creatorFee">0</span>%</td></tr>
          <tr><td class="font-bold">Stage:</td><td id="currentStage"></td></tr>
          <tr><td class="font-bold">Creator:</td><td id="displayCreatorWallet"></td></tr>
          <tr><td class="font-bold">Twitter:</td><td><a id="twitterLinkDisplay" class="text-blue-400"></a></td></tr>
          <tr><td class="font-bold">Discord:</td><td><a id="discordLinkDisplay" class="text-blue-400"></a></td></tr>
          <tr><td class="font-bold">Boost:</td><td id="boostStatus"></td></tr>
          <tr><td class="font-bold">Tokenomics:</td><td id="tokenomics"></td></tr>
        </table>
      </div>
      <div id="snipeSection" class="hidden">
        <h3 class="text-lg font-semibold mb-2">Snipe</h3>
        <label class="block mb-2">AVAX Amount</label>
        <input id="snipeAmount" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0.0">
        <button id="snipeBtn" class="w-full neon-btn text-white px-4 py-2 rounded">Snipe</button>
      </div>
      <div id="contributionSection" class="hidden">
        <h3 class="text-lg font-semibold mb-2">Contribution</h3>
        <p><strong>Total Contributed:</strong> <span id="totalContributed">0</span> AVAX (~$<span id="totalContributedValue">0</span>)</p>
        <p><strong>Timer:</strong> <span id="whitelistTimer"></span></p>
        <div class="chart-container mt-4">
          <canvas id="contributionChart"></canvas>
        </div>
      </div>
      <div id="tradingInterface" class="hidden">
        <h3 class="text-lg font-semibold mb-2">Price Chart</h3>
        <div class="chart-container mt-4">
          <canvas id="priceChart"></canvas>
        </div>
        <div class="mt-4 glowing-box p-4 rounded-lg">
          <p><strong>Price:</strong> $<span id="chartPrice">0</span></p>
          <p><strong>Market Cap:</strong> $<span id="chartMarketCap">0</span></p>
          <p><strong>FDV:</strong> $<span id="chartFdv">0</span></p>
          <p><strong>Locked Liquidity:</strong> $<span id="chartLockedLiquidity">0</span></p>
        </div>
      </div>
      <div id="burnSection" class="hidden">
        <h3 class="text-lg font-semibold mb-2">Burn <span id="burnTicker"></span></h3>
        <p><strong>Total Burned:</strong> <span id="totalBurned">0</span></p>
        <p><strong>Supply Remaining:</strong> <span id="supplyRemaining">100</span>%</p>
        <label class="block mb-2">Amount to Burn</label>
        <input id="burnAmount" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0.0">
        <button id="burnBtn" class="w-full neon-btn text-white px-4 py-2 rounded">Burn</button>
        <div class="chart-container mt-4">
          <canvas id="burnChart"></canvas>
        </div>
      </div>
      <button id="viewTransactionsBtn" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">View Transactions</button>
      <button id="viewChatBtn" class="w-full neon-btn text-white px-4 py-2 rounded mt-2">Community Chat</button>
      <button id="boostBtn" class="w-full neon-btn text-white px-4 py-2 rounded mt-2">Boost</button>
      <button id="backTokenDetails" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded mt-2">Back</button>
    </div>
  </div>

  <!-- Transaction Page -->
  <div id="transactionPage" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Transaction History</h2>
      <div id="transactionHistory" class="space-y-2 max-h-60 overflow-y-auto"></div>
      <button id="backTransactions" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Back</button>
    </div>
  </div>

  <!-- Community Chat Page -->
  <div id="chatPage" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Community Chat</h2>
      <p><strong>Sentiment:</strong> <span id="chatSentiment">Neutral</span></p>
      <div id="chatMessages" class="space-y-2 max-h-60 overflow-y-auto mb-4"></div>
      <input id="chatInput" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="Type a message...">
      <button id="sendChat" class="w-full neon-btn text-white px-4 py-2 rounded">Send</button>
      <button id="backChat" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded mt-2">Back</button>
    </div>
  </div>

  <!-- Boost Modal -->
  <div id="boostModal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Boost <span id="boostTokenTicker"></span></h2>
      <p>Boost <span id="boostToken"></span> to increase visibility!</p>
      <label class="block mb-2">Amount (<span id="boostToken2"></span>)</label>
      <input id="boostAmount" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0.0">
      <button id="confirmBoostBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Confirm</button>
      <button id="cancelBoostBtn" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded">Cancel</button>
    </div>
  </div>

  <!-- Trade Confirmation Modal -->
  <div id="tradeConfirmModal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Confirm Swap</h2>
      <p><strong>AVAX Amount:</strong> <span id="confirmAvaxAmount">0</span></p>
      <p><strong>Token Amount:</strong> <span id="confirmTokenAmount">0</span> <span id="confirmTokenTicker"></span></p>
      <p><strong>Slippage:</strong> <span id="confirmSlippage">0</span>%</p>
      <p><strong>Gas Fee:</strong> <span id="confirmGasFee">0</span> AVAX</p>
      <p><strong>Platform Fee (5%):</strong> <span id="confirmPlatformFee">0</span> AVAX</p>
      <button id="confirmTradeBtn" class="w-full neon-btn text-white px-4 py-2 rounded mb-2">Confirm</button>
      <button id="cancelTradeBtn" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded">Cancel</button>
    </div>
  </div>

  <!-- Notification Dropdown -->
  <div id="notificationDropdown" class="fixed top-16 right-4 bg-gray-800 p-4 rounded-lg w-80 max-h-80 overflow-y-auto hidden glowing-box z-20">
    <h2 class="text-lg font-bold mb-2">Notifications</h2>
    <div id="notificationsList" class="space-y-2"></div>
  </div>

  <!-- Launch Token Page -->
  <div id="launchPage" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Launch New Token</h2>
      <form id="launchForm">
        <label class="block mb-2">Token Name</label>
        <input id="tokenName" class="w-full bg-gray-700 text-white p-2 rounded mb-4" required>
        <label class="block mb-2">Ticker</label>
        <input id="tokenTicker" class="w-full bg-gray-700 text-white p-2 rounded mb-4" required>
        <label class="block mb-2">Total Supply</label>
        <input id="tokenSupply" type="number" class="w-full bg-gray-700 text-white p-2 rounded mb-4" required>
        <label class="block mb-2">Token Image URL</label>
        <input id="tokenImage" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="https://...">
        <label class="block mb-2">Twitter Link</label>
        <input id="twitterLink" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="https://twitter.com/...">
        <label class="block mb-2">Discord Link</label>
        <input id="discordLink" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="https://discord.gg/...">
        <label class="block mb-2">Whitelist Duration</label>
        <input id="whitelistDuration" type="number" class="w-full bg-gray-700 text-white p-2 rounded mb-4" required>
        <select id="durationUnit" class="w-full bg-gray-700 text-white p-2 rounded mb-4">
          <option value="seconds">Seconds</option>
          <option value="minutes">Minutes</option>
          <option value="hours">Hours</option>
        </select>
        <label class="block mb-2">Min Contribution (AVAX)</label>
        <input id="minContribution" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4" required>
        <label class="block mb-2">Max Contribution (AVAX)</label>
        <input id="maxContribution" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4" required>
        <label class="block mb-2">Airdrop Percentage (%)</label>
        <input id="airdropPercentage" type="number" step="0.1" class="w-full bg-gray-700 text-white p-2 rounded mb-4" required>
        <label class="block mb-2">Vesting Duration</label>
        <input id="vestingDuration" type="number" class="w-full bg-gray-700 text-white p-2 rounded mb-4" required>
        <select id="vestingUnit" class="w-full bg-gray-700 text-white p-2 rounded mb-4">
          <option value="seconds">Seconds</option>
          <option value="minutes">Minutes</option>
          <option value="hours">Hours</option>
          <option value="days">Days</option>
          <option value="months">Months</option>
        </select>
        <label class="block mb-2">Creator Fee (%)</label>
        <input id="creatorFeeInput" type="number" step="0.1" min="0" max="5" class="w-full bg-gray-700 text-white p-2 rounded mb-4" required>
        <label class="block mb-2">Pre-Whitelist Buy (% of Supply)</label>
        <input id="preBuyPercentage" type="number" step="0.1" min="0" max="50" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0">
        <label class="block mb-2">AVAX for Pre-Buy</label>
        <input id="preBuyAvax" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0.0">
        <button type="submit" class="w-full neon-btn text-white px-4 py-2 rounded mb-4">Launch Token</button>
      </form>
      <button id="backLaunch" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded">Back</button>
    </div>
  </div>

  <!-- Automated Trading Modal -->
  <div id="autoTradeModal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-11/12 max-w-md glowing-box">
      <h2 class="text-2xl font-bold mb-4">Automated Trading</h2>
      <h3 class="text-lg font-semibold mb-2">Auto Buy</h3>
      <label class="block mb-2">Token</label>
      <select id="autoBuyToken" class="w-full bg-gray-700 text-white p-2 rounded mb-4"></select>
      <label class="block mb-2">AVAX Amount</label>
      <input id="autoBuyAmount" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0.0">
      <label class="block mb-2">Interval</label>
      <input id="autoBuyInterval" type="number" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0">
      <select id="autoBuyUnit" class="w-full bg-gray-700 text-white p-2 rounded mb-4">
        <option value="seconds">Seconds</option>
        <option value="minutes">Minutes</option>
      </select>
      <button id="startAutoBuy" class="w-full neon-btn text-white px-4 py-2 rounded mb-4">Start Auto Buy</button>
      <h3 class="text-lg font-semibold mb-2">Auto Sell</h3>
      <label class="block mb-2">Token</label>
      <select id="autoSellToken" class="w-full bg-gray-700 text-white p-2 rounded mb-4"></select>
      <label class="block mb-2">Token Amount</label>
      <input id="autoSellAmount" type="number" step="0.01" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0.0">
      <label class="block mb-2">Interval</label>
      <input id="autoSellInterval" type="number" class="w-full bg-gray-700 text-white p-2 rounded mb-4" placeholder="0">
      <select id="autoSellUnit" class="w-full bg-gray-700 text-white p-2 rounded mb-4">
        <option value="seconds">Seconds</option>
        <option value="minutes">Minutes</option>
      </select>
      <button id="startAutoSell" class="w-full neon-btn text-white px-4 py-2 rounded mb-4">Start Auto Sell</button>
      <div id="activeAutoTrades" class="space-y-4"></div>
      <button id="closeAutoTrade" class="w-full neon-btn text-white px-4 py-2 rounded mt-4">Close</button>
      <button id="backAutoTrade" class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded mt-2">Back</button>
    </div>
  </div>

  <script>
    // Global state variables for the application
    let wallet = null; // Stores the simulated Ethereum wallet
    let avaxBalance = 0; // User's AVAX balance
    let tokens = []; // Array to store all launched tokens
    let tokenBalances = {}; // Object to store user's balances for each token
    let stakingPools = {}; // Object to manage staking pools
    let liquidityPools = {}; // Object to manage liquidity pools
    let autoTrades = []; // Array to store active automated trading bots
    let portfolioHistory = []; // History of portfolio value for charting
    let notifications = []; // Array to store application notifications
    let currentToken = null; // Currently selected token for detail view
    let platformTreasury = 0; // Accumulated platform fees
    let proposals = []; // Array to store active voting proposals
    let quests = []; // Array to store active quests
    const AVAX_PRICE = 30; // Simulated price of AVAX in USD
    // Sound effect for button clicks
    const clickSound = new Audio('https://freesound.org/data/previews/171/171671_2437358-lq.mp3');

    /**
     * Initializes the application state.
     * Creates a random wallet, sets initial AVAX balance, and starts simulations.
     */
    function initialize() {
      wallet = ethers.Wallet.createRandom(); // Simulate a new random wallet
      avaxBalance = (Math.random() * 990 + 10).toFixed(2); // Random initial AVAX balance
      // Record initial portfolio value
      portfolioHistory.push({ timestamp: new Date().toLocaleString(), value: avaxBalance * AVAX_PRICE, costBasis: 0 });
      // Update UI with initial AVAX balance
      document.getElementById('balanceAvax').textContent = avaxBalance;
      document.getElementById('balanceAvaxValue').textContent = (avaxBalance * AVAX_PRICE).toFixed(2);
      updateBalanceModal(); // Update the balance modal
      updatePortfolio(); // Update the portfolio display
      simulateBotTokens(); // Create some initial simulated tokens
      setInterval(simulateBotActivity, 30000); // Simulate bot trading activity every 30 seconds
      setInterval(updatePortfolio, 60000); // Update portfolio every minute
      console.log('Initialized wallet:', wallet.address, 'AVAX:', avaxBalance);
    }

    /**
     * Plays a click sound effect if sound effects are enabled in settings.
     */
    function playSound() {
      if (document.getElementById('soundEffects').checked) {
        clickSound.currentTime = 0; // Rewind to start for quick successive clicks
        clickSound.play();
      }
    }

    /**
     * Adds a new notification to the list and updates the notification count.
     * @param {string} message - The notification message.
     */
    function notify(message) {
      if (document.getElementById('notifications').checked) {
        notifications.push({ message, timestamp: new Date().toLocaleString() });
        updateNotifications();
      }
    }

    /**
     * Renders the list of notifications in the dropdown.
     */
    function updateNotifications() {
      const notificationsList = document.getElementById('notificationsList');
      notificationsList.innerHTML = ''; // Clear existing notifications
      notifications.forEach(n => {
        notificationsList.innerHTML += `<p class="text-sm text-gray-400 glowing-box p-2 rounded">${n.timestamp}: ${n.message}</p>`;
      });
      const count = notifications.length;
      document.getElementById('notificationCount').textContent = count;
      // Show/hide notification count badge
      document.getElementById('notificationCount').classList.toggle('hidden', count === 0);
    }

    // Event listener for Notification Button
    document.getElementById('notificationBtn').addEventListener('click', () => {
      document.getElementById('notificationDropdown').classList.toggle('hidden');
      playSound();
    });

    // Event listeners for Menu Navigation
    document.getElementById('menuBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.remove('hidden');
      playSound();
    });
    document.getElementById('closeMenu').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      playSound();
    });

    // Event listeners for Settings Modal
    document.getElementById('settingsBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      document.getElementById('settingsModal').classList.remove('hidden');
      playSound();
    });
    document.getElementById('closeSettings').addEventListener('click', () => {
      document.getElementById('settingsModal').classList.add('hidden');
      const theme = document.getElementById('themeSelect').value;
      // Apply selected theme classes to the body
      document.getElementById('app').classList.toggle('bg-gradient-to-b from-gray-900 to-gray-700', theme === 'dark');
      document.getElementById('app').classList.toggle('bg-gradient-to-b from-gray-100 to-gray-300', theme === 'light');
      document.getElementById('app').classList.toggle('bg-gradient-to-b from-purple-900 to-pink-700', theme === 'neon');
      document.getElementById('app').classList.toggle('text-white', theme !== 'light');
      document.getElementById('app').classList.toggle('text-black', theme === 'light');
      playSound();
    });

    // Event listeners for Balance Modal
    document.getElementById('balanceBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      updateBalanceModal();
      document.getElementById('balanceModal').classList.remove('hidden');
      playSound();
    });
    document.getElementById('closeBalance').addEventListener('click', () => {
      document.getElementById('balanceModal').classList.add('hidden');
      document.getElementById('portfolioPage').classList.add('hidden'); // Ensure portfolio is also hidden
      playSound();
    });

    /**
     * Updates the content of the balance modal with current AVAX and token balances.
     */
    function updateBalanceModal() {
      document.getElementById('balanceAvax').textContent = avaxBalance;
      document.getElementById('balanceAvaxValue').textContent = (avaxBalance * AVAX_PRICE).toFixed(2);
      let totalValue = avaxBalance * AVAX_PRICE;
      let tokenHtml = '<table class="w-full text-sm">';
      // Iterate through token balances and display them
      for (const [ticker, balance] of Object.entries(tokenBalances)) {
        const token = tokens.find(t => t.ticker === ticker);
        const value = (balance * (token ? token.price : 0)).toFixed(2);
        tokenHtml += `<tr><td class="font-bold">${ticker}:</td><td>${balance} (~$${value})</td></tr>`;
        totalValue += parseFloat(value);
      }
      tokenHtml += '</table>';
      document.getElementById('tokenBalances').innerHTML = tokenHtml;
      document.getElementById('totalValue').textContent = totalValue.toFixed(2);
    }

    // Event listeners for Portfolio Page
    document.getElementById('portfolioBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      updatePortfolio();
      document.getElementById('portfolioPage').classList.remove('hidden');
      playSound();
    });
    document.getElementById('backPortfolio').addEventListener('click', () => {
      document.getElementById('portfolioPage').classList.add('hidden');
      document.getElementById('menuModal').classList.remove('hidden');
      playSound();
    });

    let portfolioPieChart = null; // Chart.js instance for portfolio allocation
    let portfolioValueChart = null; // Chart.js instance for portfolio value history

    /**
     * Updates the portfolio display, including charts and holdings.
     * This function has been updated to correctly destroy and re-initialize Chart.js instances.
     */
    function updatePortfolio() {
      const labels = ['AVAX', ...Object.keys(tokenBalances)];
      const data = [avaxBalance * AVAX_PRICE, ...Object.keys(tokenBalances).map(ticker => {
        const token = tokens.find(t => t.ticker === ticker);
        return token ? tokenBalances[ticker] * token.price : 0;
      })];
      const totalValue = data.reduce((sum, val) => sum + val, 0).toFixed(2);
      const costBasis = portfolioHistory.length > 0 ? portfolioHistory[portfolioHistory.length - 1].costBasis : 0;
      const pnl = (totalValue - costBasis).toFixed(2);
      document.getElementById('portfolioValue').textContent = totalValue;
      document.getElementById('portfolioPnL').textContent = `${pnl >= 0 ? '+' : ''}${pnl}`;
      document.getElementById('portfolioPnL').className = `text-sm ${pnl >= 0 ? 'text-green-400' : 'text-red-400'}`;
      portfolioHistory.push({ timestamp: new Date().toLocaleString(), value: parseFloat(totalValue), costBasis });

      // Destroy existing charts if they exist
      if (portfolioPieChart) {
        portfolioPieChart.destroy();
        portfolioPieChart = null;
      }
      if (portfolioValueChart) {
        portfolioValueChart.destroy();
        portfolioValueChart = null;
      }

      // Create new pie chart
      const pieCanvas = document.querySelector('#portfolioPage canvas:first-child');
      if (pieCanvas) {
        portfolioPieChart = new Chart(pieCanvas.getContext('2d'), {
          type: 'pie',
          data: {
            labels,
            datasets: [{
              label: 'Portfolio Allocation',
              data,
              backgroundColor: ['#00ffaa', '#ff4d4d', '#4b6cb7', '#facc15', '#a855f7'],
              borderColor: ['#00ffaa', '#ff4d4d', '#4b6cb7', '#facc15', '#a855f7'],
              borderWidth: 2,
              hoverOffset: 20
            }]
          },
          options: {
            plugins: {
              legend: { position: 'top', labels: { font: { family: 'Inter', size: 14, weight: 'bold' } } }
            }
          }
        });
      }

      // Create new line chart
      const lineCanvas = document.querySelector('#portfolioPage canvas:last-child');
      if (lineCanvas) {
        portfolioValueChart = new Chart(lineCanvas.getContext('2d'), {
          type: 'line',
          data: {
            labels: portfolioHistory.map(h => h.timestamp),
            datasets: [{
              label: 'Portfolio Value (USD)',
              data: portfolioHistory.map(h => h.value),
              borderColor: '#00ffaa',
              backgroundColor: 'rgba(0, 255, 170, 0.2)',
              fill: true,
              tension: 0.4
            }]
          },
          options: {
            scales: {
              y: { beginAtZero: false, title: { display: true, text: 'Value (USD)', font: { family: 'Inter', size: 14, weight: 'bold' } } }
            }
          }
        });
      }

      const holdings = document.getElementById('portfolioHoldings');
      holdings.innerHTML = '<h3 class="text-lg font-semibold mb-2">Holdings</h3>';
      holdings.innerHTML += `<p class="glowing-box p-2 rounded"><strong>AVAX:</strong> ${avaxBalance} (~$${(avaxBalance * AVAX_PRICE).toFixed(2)})</p>`;
      for (const [ticker, balance] of Object.entries(tokenBalances)) {
        const token = tokens.find(t => t.ticker === ticker);
        const value = (balance * (token ? token.price : 0)).toFixed(2);
        holdings.innerHTML += `<p class="glowing-box p-2 rounded"><strong>${ticker}:</strong> ${balance} (~$${value})</p>`;
      }
    }

    // Event listener for Export Portfolio button
    document.getElementById('exportPortfolio').addEventListener('click', () => {
      const csv = ['Timestamp,Asset,Amount,Value (USD)'];
      csv.push(`${new Date().toLocaleString()},AVAX,${avaxBalance},${(avaxBalance * AVAX_PRICE).toFixed(2)}`);
      for (const [ticker, balance] of Object.entries(tokenBalances)) {
        const token = tokens.find(t => t.ticker === ticker);
        csv.push(`${new Date().toLocaleString()},${ticker},${balance},${(balance * (token ? token.price : 0)).toFixed(2)}`);
      }
      const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'portfolio.csv';
      a.click();
      URL.revokeObjectURL(url);
      notify('Portfolio exported as CSV.');
      playSound();
    });

    // Event listeners for Staking Modal
    document.getElementById('stakingBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      updateStakingModal();
      document.getElementById('stakingModal').classList.remove('hidden');
      playSound();
    });
    document.getElementById('closeStaking').addEventListener('click', () => {
      document.getElementById('stakingModal').classList.add('hidden');
      playSound();
    });
    document.getElementById('backStaking').addEventListener('click', () => {
      document.getElementById('stakingModal').classList.add('hidden');
      document.getElementById('menuModal').classList.remove('hidden');
      playSound();
    });

    /**
     * Updates the staking modal with available tokens and staking pools.
     */
    function updateStakingModal() {
      const supplyTokenSelect = document.getElementById('supplyToken');
      supplyTokenSelect.innerHTML = '<option value="">Select Token</option>';
      tokens.forEach(token => {
        supplyTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker}</option>`;
      });
      const supplyAssetSelect = document.getElementById('supplyAsset');
      supplyAssetSelect.innerHTML = '<option value="AVAX">AVAX</option>';
      Object.keys(tokenBalances).forEach(ticker => {
        supplyAssetSelect.innerHTML += `<option value="${ticker}">${ticker}</option>`;
      });
      const stakePoolsDiv = document.getElementById('stakePools');
      stakePoolsDiv.innerHTML = ''; // Clear existing pools
      Object.entries(stakingPools).forEach(([ticker, pool]) => {
        // Calculate APR, adjusting for number of users (simplified)
        const apr = pool.totalStaked > 0 ? pool.baseApr / Math.sqrt(pool.users) : pool.baseApr;
        stakePoolsDiv.innerHTML += `
          <div class="glowing-box p-4 rounded-lg mb-2">
            <p><strong>${ticker}</strong></p>
            <p>Total Staked: ${pool.totalStaked.toFixed(2)} ${pool.asset}</p>
            <p>Reward Pool: ${pool.rewards.toFixed(2)} ${pool.asset}</p>
            <p>APR: ${apr.toFixed(2)}%</p>
            <p>Users Staking: ${pool.users}</p>
            <button class="stakeBtn w-full neon-btn text-white px-4 py-2 rounded mt-2" data-ticker="${ticker}">Stake</button>
            <button class="unstakeBtn w-full neon-btn text-white px-4 py-2 rounded mt-2" data-ticker="${ticker}">Unstake</button>
            <button class="claimBtn w-full neon-btn text-white px-4 py-2 rounded mt-2" data-ticker="${ticker}">Claim</button>
          </div>`;
      });
      // Add event listeners for dynamically created stake/unstake/claim buttons
      document.querySelectorAll('.stakeBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          const ticker = btn.dataset.ticker;
          const amount = prompt(`Enter amount to stake for ${ticker}:`); // Using prompt for simplicity
          if (amount && !isNaN(amount) && parseFloat(amount) > 0 && parseFloat(amount) <= tokenBalances[ticker]) {
            tokenBalances[ticker] = (parseFloat(tokenBalances[ticker]) - parseFloat(amount)).toFixed(2);
            stakingPools[ticker].totalStaked += parseFloat(amount);
            stakingPools[ticker].users += 1;
            stakingPools[ticker].userStakes[wallet.address] = (stakingPools[ticker].userStakes[wallet.address] || 0) + parseFloat(amount);
            notify(`Staked ${amount} ${ticker} successfully!`);
            updateStakingModal();
            updateBalanceModal();
            updatePortfolio();
            playSound();
          } else {
            notify('Invalid amount or insufficient balance.');
          }
        });
      });
      document.querySelectorAll('.unstakeBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          const ticker = btn.dataset.ticker;
          const amount = stakingPools[ticker].userStakes[wallet.address] || 0;
          if (amount <= 0) {
            notify('No staked amount to unstake.');
            return;
          }
          tokenBalances[ticker] = (parseFloat(tokenBalances[ticker] || 0) + amount).toFixed(2);
          stakingPools[ticker].totalStaked -= amount;
          stakingPools[ticker].users -= 1;
          delete stakingPools[ticker].userStakes[wallet.address]; // Remove user's stake
          notify(`Unstaked ${amount} ${ticker} successfully!`);
          updateStakingModal();
          updateBalanceModal();
          updatePortfolio();
          playSound();
        });
      });
      document.querySelectorAll('.claimBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          const ticker = btn.dataset.ticker;
          const rewards = stakingPools[ticker].userRewards[wallet.address] || 0;
          if (rewards <= 0) {
            notify('No rewards to claim.');
            return;
          }
          tokenBalances[ticker] = (parseFloat(tokenBalances[ticker] || 0) + rewards).toFixed(2);
          stakingPools[ticker].rewards -= rewards; // Deduct claimed rewards from pool
          delete stakingPools[ticker].userRewards[wallet.address]; // Reset user's claimable rewards
          notify(`Claimed ${rewards.toFixed(2)} ${ticker} rewards!`);
          updateStakingModal();
          updateBalanceModal();
          updatePortfolio();
          playSound();
        });
      });
      // Simulate reward accumulation for staking pools
      Object.keys(stakingPools).forEach(ticker => {
        const pool = stakingPools[ticker];
        // Clear any existing interval to prevent multiple intervals for the same pool
        if (pool.intervalId) clearInterval(pool.intervalId);
        pool.intervalId = setInterval(() => {
          if (pool.users > 0) {
            const apr = pool.baseApr / Math.sqrt(pool.users);
            const rewardPerSecond = (pool.totalStaked * (apr / 100)) / (365 * 24 * 3600);
            pool.rewards += rewardPerSecond;
            Object.keys(pool.userStakes).forEach(user => {
              pool.userRewards[user] = (pool.userRewards[user] || 0) + (rewardPerSecond * (pool.userStakes[user] / pool.totalStaked));
            });
            updateStakingModal(); // Re-render to show updated rewards
          }
        }, 1000); // Update every second
      });
    }

    // Event listener for Supply button in Staking modal
    document.getElementById('supplyBtn').addEventListener('click', () => {
      const ticker = document.getElementById('supplyToken').value;
      const asset = document.getElementById('supplyAsset').value;
      const amount = parseFloat(document.getElementById('supplyAmount').value);
      const apr = parseFloat(document.getElementById('supplyAPR').value);
      if (!ticker || !asset || isNaN(amount) || amount <= 0 || isNaN(apr) || apr <= 0) {
        notify('Invalid input.');
        return;
      }
      // Check for sufficient balance
      if (asset === 'AVAX' && amount > avaxBalance) {
        notify('Insufficient AVAX balance.');
        return;
      }
      if (asset !== 'AVAX' && amount > tokenBalances[asset]) {
        notify(`Insufficient ${asset} balance.`);
        return;
      }
      const platformFee = amount * 0.05; // 5% platform fee
      if (asset === 'AVAX' && amount + platformFee + 0.02 > avaxBalance) { // 0.02 AVAX for gas fee simulation
        notify('Insufficient AVAX for fees.');
        return;
      }
      // Initialize staking pool if it doesn't exist
      if (!stakingPools[ticker]) {
        stakingPools[ticker] = { totalStaked: 0, baseApr: apr, users: 0, rewards: 0, asset, userStakes: {}, userRewards: {} };
      }
      stakingPools[ticker].totalStaked += amount;
      stakingPools[ticker].rewards += amount * (apr / 100) / 365; // Simulate daily reward
      // Deduct funds and apply fees
      if (asset === 'AVAX') {
        avaxBalance = (parseFloat(avaxBalance) - (amount + platformFee + 0.02)).toFixed(2);
        platformTreasury += platformFee;
      } else {
        tokenBalances[asset] = (parseFloat(tokenBalances[asset]) - amount).toFixed(2);
        avaxBalance = (parseFloat(avaxBalance) - (platformFee + 0.02)).toFixed(2);
        platformTreasury += platformFee;
      }
      notify(`Supplied ${amount} ${asset} to ${ticker} pool with ${apr}% APR.`);
      updateStakingModal();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      playSound();
    });

    // Event listeners for Liquidity Modal
    document.getElementById('liquidityBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      updateLiquidityModal();
      document.getElementById('liquidityModal').classList.remove('hidden');
      playSound();
    });
    document.getElementById('closeLiquidity').addEventListener('click', () => {
      document.getElementById('liquidityModal').classList.add('hidden');
      playSound();
    });

    /**
     * Updates the liquidity modal with available tokens for liquidity provision.
     */
    function updateLiquidityModal() {
      const liquidityTokenSelect = document.getElementById('liquidityToken');
      liquidityTokenSelect.innerHTML = '<option value="">Select Token</option>';
      tokens.filter(t => t.stage === 'trading').forEach(token => {
        liquidityTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker}</option>`;
      });
      // Update currentToken when a new token is selected
      liquidityTokenSelect.addEventListener('change', () => {
        currentToken = tokens.find(t => t.ticker === liquidityTokenSelect.value);
        updateLiquiditySection();
      });
      updateLiquiditySection(); // Initial update
    }

    // Event listener for Supply Type change (Single-Sided vs. Dual-Sided)
    document.getElementById('supplyType').addEventListener('change', () => {
      const supplyType = document.getElementById('supplyType').value;
      document.getElementById('singleSupply').classList.toggle('hidden', supplyType !== 'single');
      document.getElementById('dualSupply').classList.toggle('hidden', supplyType !== 'dual');
    });

    // Event listener to calculate dual-sided token amount based on AVAX amount
    document.getElementById('dualAvaxAmount').addEventListener('input', () => {
      const avaxAmount = parseFloat(document.getElementById('dualAvaxAmount').value);
      if (!isNaN(avaxAmount) && currentToken?.price > 0) {
        const tokenAmount = (avaxAmount / currentToken.price).toFixed(2);
        document.getElementById('dualTokenAmount').value = tokenAmount;
      } else {
        document.getElementById('dualTokenAmount').value = '';
      }
    });

    // Event listener for Add Liquidity button
    document.getElementById('addLiquidityBtn').addEventListener('click', () => {
      const supplyType = document.getElementById('supplyType').value;
      // Ensure currentToken is selected
      if (!currentToken) {
        notify('Please select a token.');
        return;
      }
      // Initialize liquidity pool if it doesn't exist for the current token
      if (!liquidityPools[currentToken.ticker]) {
        liquidityPools[currentToken.ticker] = { avax: 0, token: 0, totalShares: 0, userShares: {}, fees: {} };
      }
      const pool = liquidityPools[currentToken.ticker];
      let avaxAmount = parseFloat(document.getElementById('avaxAmount').value);
      let tokenAmount = supplyType === 'dual' ? parseFloat(document.getElementById('dualTokenAmount').value) : 0;
      const platformFee = avaxAmount * 0.05; // 5% platform fee

      // Validate amounts and balances
      if (isNaN(avaxAmount) || avaxAmount <= 0 || avaxAmount + platformFee + 0.02 > avaxBalance) {
        notify('Invalid AVAX amount or insufficient balance.');
        return;
      }
      if (supplyType === 'dual' && (isNaN(tokenAmount) || tokenAmount <= 0 || tokenAmount > (tokenBalances[currentToken.ticker] || 0))) {
        notify(`Invalid ${currentToken.ticker} amount or insufficient balance.`);
        return;
      }

      // Simulate liquidity pool share calculation (simplified)
      const shares = Math.sqrt(avaxAmount * (supplyType === 'dual' ? tokenAmount : avaxAmount / currentToken.price));
      pool.avax += avaxAmount;
      pool.token += supplyType === 'dual' ? tokenAmount : avaxAmount / currentToken.price;
      pool.totalShares += shares;
      pool.userShares[wallet.address] = (pool.userShares[wallet.address] || 0) + shares;
      pool.fees[wallet.address] = (pool.fees[wallet.address] || 0); // Initialize user fees

      // Deduct funds and update treasury
      avaxBalance = (parseFloat(avaxBalance) - (avaxAmount + platformFee + 0.02)).toFixed(2);
      platformTreasury += platformFee;
      if (supplyType === 'dual') {
        tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) - tokenAmount).toFixed(2);
      }
      // Record transaction
      currentToken.transactions.push({
        type: 'Add Liquidity',
        amount: `${avaxAmount} AVAX${supplyType === 'dual' ? ` + ${tokenAmount} ${currentToken.ticker}` : ''}`,
        timestamp: new Date().toLocaleString()
      });
      // Update portfolio cost basis
      portfolioHistory[portfolioHistory.length - 1].costBasis += avaxAmount * AVAX_PRICE;

      updateLiquiditySection();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      notify(`Added ${avaxAmount} AVAX${supplyType === 'dual' ? ` and ${tokenAmount} ${currentToken.ticker}` : ''} to liquidity pool.`);
      playSound();
    });

    // Event listener for Remove Liquidity button
    document.getElementById('removeLiquidityBtn').addEventListener('click', () => {
      if (!currentToken) {
        notify('Please select a token.');
        return;
      }
      const pool = liquidityPools[currentToken.ticker];
      const shares = pool.userShares[wallet.address] || 0;
      if (shares <= 0) {
        notify('No liquidity to remove.');
        return;
      }
      // Calculate share of AVAX and token
      const avaxShare = (pool.avax * shares / pool.totalShares).toFixed(2);
      const tokenShare = (pool.token * shares / pool.totalShares).toFixed(2);
      const fees = (pool.fees[wallet.address] || 0).toFixed(2);
      const platformFee = parseFloat(avaxShare) * 0.05; // 5% fee on AVAX portion

      // Return funds and update balances
      avaxBalance = (parseFloat(avaxBalance) + parseFloat(avaxShare) + parseFloat(fees) - platformFee - 0.02).toFixed(2);
      platformTreasury += platformFee;
      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) + parseFloat(tokenShare)).toFixed(2);

      // Update pool state
      pool.avax -= avaxShare;
      pool.token -= tokenShare;
      pool.totalShares -= shares;
      pool.fees[wallet.address] = 0; // Reset claimed fees
      delete pool.userShares[wallet.address]; // Remove user's shares

      // Record transaction
      currentToken.transactions.push({
        type: 'Remove Liquidity',
        amount: `${avaxShare} AVAX + ${tokenShare} ${currentToken.ticker}`,
        timestamp: new Date().toLocaleString()
      });
      updateLiquiditySection();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      notify(`Removed ${avaxShare} AVAX and ${tokenShare} ${currentToken.ticker} from liquidity pool. Claimed ${fees} AVAX fees.`);
      playSound();
    });

    /**
     * Updates the liquidity section of the token details page with pool analytics.
     */
    function updateLiquiditySection() {
      if (!currentToken) return;
      // Initialize pool if it doesn't exist (e.g., for newly launched tokens)
      if (!liquidityPools[currentToken.ticker]) {
        liquidityPools[currentToken.ticker] = { avax: 0, token: 0, totalShares: 0, userShares: {}, fees: {} };
      }
      const pool = liquidityPools[currentToken.ticker];
      // Calculate TVL, user share, fees earned, APR, and impermanent loss
      const tvl = (pool.avax * AVAX_PRICE + pool.token * currentToken.price).toFixed(2);
      const share = pool.userShares[wallet.address] || 0;
      const sharePercent = pool.totalShares > 0 ? (share / pool.totalShares * 100).toFixed(2) : 0;
      const fees = pool.fees[wallet.address] || 0;
      const apr = pool.totalShares > 0 ? (fees * 365 / (share * AVAX_PRICE) * 100).toFixed(2) : 0;
      // Simplified impermanent loss calculation (conceptual)
      const impermanentLoss = pool.avax > 0 && pool.token > 0 ? ((pool.avax / pool.token * currentToken.price) / AVAX_PRICE - 1).toFixed(2) : 0;

      document.getElementById('poolTVL').textContent = tvl;
      document.getElementById('poolShare').textContent = sharePercent;
      document.getElementById('feesEarned').textContent = fees.toFixed(2);
      document.getElementById('poolAPR').textContent = apr;
      document.getElementById('impermanentLoss').textContent = impermanentLoss;
    }

    // Event listeners for Claim Tokens Modal
    document.getElementById('claimBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      updateClaimModal();
      document.getElementById('claimModal').classList.remove('hidden');
      playSound();
    });
    document.getElementById('closeClaim').addEventListener('click', () => {
      document.getElementById('claimModal').classList.add('hidden');
      playSound();
    });

    /**
     * Updates the claim tokens modal with available tokens for claiming airdrops.
     */
    function updateClaimModal() {
      const claimTokenSelect = document.getElementById('claimToken');
      claimTokenSelect.innerHTML = '<option value="">Select Token</option>';
      tokens.filter(t => t.vestingStart).forEach(token => {
        claimTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker}</option>`;
      });
      claimTokenSelect.addEventListener('change', () => {
        currentToken = tokens.find(t => t.ticker === claimTokenSelect.value);
        updateAirdropSection();
      });
      updateAirdropSection(); // Initial update
    }

    // Event listener for Claim Airdrop button
    document.getElementById('claimAirdropBtn').addEventListener('click', () => {
      if (!currentToken || !currentToken.vestingStart) {
        notify('Airdrop not yet started or no token selected.');
        return;
      }
      const platformFee = 0.02 * 0.05; // Small platform fee for claiming
      if (platformFee + 0.02 > avaxBalance) {
        notify('Insufficient AVAX for fees.');
        return;
      }
      const elapsed = Date.now() - currentToken.vestingStart;
      const totalAirdrop = currentToken.originalSupply * (currentToken.airdropPercentage / 100);
      const vestedPercent = Math.min(elapsed / currentToken.vestingDuration, 1) * 100;
      const claimable = (totalAirdrop * vestedPercent / 100) - currentToken.airdropClaimed;
      if (claimable <= 0) {
        notify('No tokens available to claim.');
        return;
      }
      // Transfer claimable tokens to user balance
      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) + claimable).toFixed(2);
      currentToken.airdropClaimed += claimable;
      avaxBalance = (parseFloat(avaxBalance) - (platformFee + 0.02)).toFixed(2);
      platformTreasury += platformFee;
      // Record transaction
      currentToken.transactions.push({
        type: 'Airdrop Claim',
        amount: `${claimable} ${currentToken.ticker}`,
        timestamp: new Date().toLocaleString()
      });
      updateAirdropSection();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      notify(`Claimed ${claimable.toFixed(2)} ${currentToken.ticker} from airdrop.`);
      playSound();
    });

    /**
     * Updates the airdrop information section for the current token.
     */
    function updateAirdropSection() {
      if (!currentToken) return;
      const totalAirdrop = currentToken.originalSupply * (currentToken.airdropPercentage / 100);
      const elapsed = currentToken.vestingStart ? (Date.now() - currentToken.vestingStart) : 0;
      const vestedPercent = currentToken.vestingStart ? Math.min(elapsed / currentToken.vestingDuration, 1) * 100 : 0;
      document.getElementById('airdropTotal').textContent = totalAirdrop.toFixed(2);
      document.getElementById('airdropClaimable').textContent = (totalAirdrop * vestedPercent / 100 - currentToken.airdropClaimed).toFixed(2);
      document.getElementById('vestingProgress').textContent = vestedPercent.toFixed(2);
    }

    // Event listeners for Voting Modal
    document.getElementById('votingBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      updateVotingModal();
      document.getElementById('votingModal').classList.remove('hidden');
      playSound();
    });
    document.getElementById('closeVoting').addEventListener('click', () => {
      document.getElementById('votingModal').classList.add('hidden');
      playSound();
    });

    /**
     * Updates the voting modal with available tokens and active proposals.
     */
    function updateVotingModal() {
      const voteTokenSelect = document.getElementById('voteToken');
      voteTokenSelect.innerHTML = '<option value="">Select Token</option>';
      tokens.forEach(token => {
        voteTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker}</option>`;
      });
      const activeProposals = document.getElementById('activeProposals');
      activeProposals.innerHTML = '';
      // Filter proposals based on selected token or show all
      proposals.filter(p => p.ticker === voteTokenSelect.value || !voteTokenSelect.value).forEach(proposal => {
        let optionsHtml = '';
        proposal.options.forEach((option, index) => {
          const votes = proposal.votes[index] || 0;
          optionsHtml += `
            <div class="glowing-box p-2 rounded mb-2">
              <p>${option}: ${votes} votes</p>
              <button class="voteOptionBtn w-full neon-btn text-white px-4 py-2 rounded mt-2" data-proposal-id="${proposal.id}" data-option-index="${index}">Vote</button>
            </div>`;
        });
        activeProposals.innerHTML += `
          <div class="glowing-box p-4 rounded-lg mb-2">
            <p><strong>${proposal.text}</strong></p>
            <p>Reward: ${proposal.reward} AVAX</p>
            ${optionsHtml}
          </div>`;
      });
      // Add event listeners for dynamically created vote buttons
      document.querySelectorAll('.voteOptionBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          const proposalId = btn.dataset.proposalId;
          const optionIndex = btn.dataset.optionIndex;
          const proposal = proposals.find(p => p.id === proposalId);
          const voteWeight = tokenBalances[proposal.ticker] || 0; // User's token balance is vote weight
          if (voteWeight <= 0) {
            notify('You need tokens to vote.');
            return;
          }
          proposal.votes[optionIndex] = (proposal.votes[optionIndex] || 0) + voteWeight;
          avaxBalance = (parseFloat(avaxBalance) + parseFloat(proposal.reward)).toFixed(2); // Reward for voting
          notify(`Voted on "${proposal.text}" with ${voteWeight} ${proposal.ticker}. Received ${proposal.reward} AVAX.`);
          updateVotingModal();
          updateBalanceModal();
          playSound();
        });
      });
    }

    // Event listener for Create Proposal button
    document.getElementById('createProposalBtn').addEventListener('click', () => {
      const ticker = document.getElementById('voteToken').value;
      const text = document.getElementById('proposalText').value;
      const options = document.getElementById('proposalOptions').value.split(',').map(o => o.trim());
      const reward = parseFloat(document.getElementById('proposalReward').value);
      if (!ticker || !text || options.length < 2 || isNaN(reward) || reward <= 0 || reward + 0.02 > avaxBalance) {
        notify('Invalid proposal details or insufficient AVAX.');
        return;
      }
      proposals.push({
        id: `prop_${Date.now()}`,
        ticker,
        text,
        options,
        votes: new Array(options.length).fill(0), // Initialize votes for each option
        reward
      });
      avaxBalance = (parseFloat(avaxBalance) - (reward + 0.02)).toFixed(2); // Deduct reward and gas fee
      platformTreasury += 0.02 * 0.05; // Small fee for creating proposal
      updateVotingModal();
      updateBalanceModal();
      updateTreasury();
      notify(`Created proposal for ${ticker}: ${text}`);
      playSound();
    });

    // Event listeners for Quests Modal
    document.getElementById('questsBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      updateQuestsModal();
      document.getElementById('questsModal').classList.remove('hidden');
      playSound();
    });
    document.getElementById('closeQuests').addEventListener('click', () => {
      document.getElementById('questsModal').classList.add('hidden');
      playSound();
    });

    /**
     * Updates the quests modal with available quests.
     */
    function updateQuestsModal() {
      const questTokenSelect = document.getElementById('questToken');
      questTokenSelect.innerHTML = '<option value="">Select Token</option>';
      tokens.forEach(token => {
        questTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker}</option>`;
      });
      const activeQuests = document.getElementById('activeQuests');
      activeQuests.innerHTML = '';
      // Filter quests based on selected token or show all
      quests.filter(q => q.ticker === questTokenSelect.value || !questTokenSelect.value).forEach(quest => {
        activeQuests.innerHTML += `
          <div class="glowing-box p-4 rounded-lg mb-2">
            <p><strong>${quest.description}</strong></p>
            <p>Reward: ${quest.reward} ${quest.ticker}</p>
            <button class="completeQuestBtn w-full neon-btn text-white px-4 py-2 rounded mt-2" data-quest-id="${quest.id}">Complete</button>
          </div>`;
      });
      // Add event listeners for dynamically created complete quest buttons
      document.querySelectorAll('.completeQuestBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          const quest = quests.find(q => q.id === btn.dataset.questId);
          // Simulate quest completion (e.g., by instantly giving reward)
          tokenBalances[quest.ticker] = (parseFloat(tokenBalances[quest.ticker] || 0) + quest.reward).toFixed(2);
          quests = quests.filter(q => q.id !== quest.id); // Remove completed quest
          notify(`Completed quest: ${quest.description}. Received ${quest.reward} ${quest.ticker}.`);
          updateQuestsModal();
          updateBalanceModal();
          playSound();
        });
      });
    }

    // Event listener for Create Quest button
    document.getElementById('createQuestBtn').addEventListener('click', () => {
      const ticker = document.getElementById('questToken').value;
      const description = document.getElementById('questDescription').value;
      const reward = parseFloat(document.getElementById('questReward').value);
      if (!ticker || !description || isNaN(reward) || reward <= 0 || reward > (tokenBalances[ticker] || 0)) {
        notify('Invalid quest details or insufficient tokens.');
        return;
      }
      quests.push({
        id: `quest_${Date.now()}`,
        ticker,
        description,
        reward
      });
      tokenBalances[ticker] = (parseFloat(tokenBalances[ticker]) - reward).toFixed(2); // Deduct reward from creator's balance
      platformTreasury += 0.02 * 0.05; // Small fee for creating quest
      updateQuestsModal();
      updateBalanceModal();
      updateTreasury();
      notify(`Created quest for ${ticker}: ${description}`);
      playSound();
    });

    // Event listeners for Treasury Modal
    document.getElementById('treasuryBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      updateTreasury();
      document.getElementById('treasuryModal').classList.remove('hidden');
      playSound();
    });
    document.getElementById('closeTreasury').addEventListener('click', () => {
      document.getElementById('treasuryModal').classList.add('hidden');
      playSound();
    });

    /**
     * Updates the platform treasury balance display.
     */
    function updateTreasury() {
      document.getElementById('treasuryBalance').textContent = platformTreasury.toFixed(2);
    }

    // Event listeners for Swap Page
    document.getElementById('backSwap').addEventListener('click', () => {
      document.getElementById('swapPage').classList.add('hidden');
      document.getElementById('menuModal').classList.remove('hidden');
      playSound();
    });

    // Update currentToken when swap token is selected
    document.getElementById('swapToken').addEventListener('change', () => {
      currentToken = tokens.find(t => t.ticker === document.getElementById('swapToken').value);
      // No specific updateSwapSection function, rely on tradeAvaxAmount input event
    });

    // Calculate token amount when AVAX amount is input for swap
    document.getElementById('tradeAvaxAmount').addEventListener('input', () => {
      const avaxAmount = parseFloat(document.getElementById('tradeAvaxAmount').value);
      if (!isNaN(avaxAmount) && currentToken?.price > 0) {
        const tokenAmount = (avaxAmount / currentToken.price).toFixed(2);
        document.getElementById('tradeTokenAmount').value = tokenAmount;
      } else {
        document.getElementById('tradeTokenAmount').value = '';
      }
    });

    // Event listener for Swap button (opens confirmation modal)
    document.getElementById('tradeBtn').addEventListener('click', () => {
      if (!wallet) {
        notify('Please sign in by initializing the app.');
        return;
      }
      if (!currentToken) {
        notify('Please select a token to swap.');
        return;
      }
      const avaxAmount = parseFloat(document.getElementById('tradeAvaxAmount').value);
      const tokenAmount = parseFloat(document.getElementById('tradeTokenAmount').value);
      const slippage = parseFloat(document.getElementById('slippageSelect').value);
      const platformFee = avaxAmount * 0.05;
      if (isNaN(avaxAmount) || avaxAmount <= 0 || avaxAmount + platformFee + 0.02 > avaxBalance) {
        notify('Invalid AVAX amount or insufficient balance.');
        return;
      }
      // Populate confirmation modal
      document.getElementById('confirmAvaxAmount').textContent = avaxAmount.toFixed(2);
      document.getElementById('confirmTokenAmount').textContent = tokenAmount.toFixed(2);
      document.getElementById('confirmTokenTicker').textContent = currentToken.ticker;
      document.getElementById('confirmSlippage').textContent = slippage;
      document.getElementById('confirmGasFee').textContent = 0.02; // Simulated gas fee
      document.getElementById('confirmPlatformFee').textContent = platformFee.toFixed(2);
      document.getElementById('tradeConfirmModal').classList.remove('hidden');
      playSound();
    });

    // Event listener for Confirm Trade button
    document.getElementById('confirmTradeBtn').addEventListener('click', () => {
      const avaxAmount = parseFloat(document.getElementById('confirmAvaxAmount').textContent);
      const tokenAmount = parseFloat(document.getElementById('confirmTokenAmount').textContent);
      const platformFee = parseFloat(document.getElementById('confirmPlatformFee').textContent);
      // const creatorFee = (avaxAmount * currentToken.creatorFee / 100).toFixed(2); // Creator fee not directly used here for simplicity

      // Deduct AVAX, add tokens, update treasury
      avaxBalance = (parseFloat(avaxBalance) - (avaxAmount + platformFee + 0.02)).toFixed(2);
      platformTreasury += platformFee;
      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) + tokenAmount).toFixed(2);

      // Simulate liquidity pool changes and price impact
      const pool = liquidityPools[currentToken.ticker];
      pool.avax += avaxAmount;
      pool.token -= tokenAmount;
      currentToken.price = pool.avax / pool.token * AVAX_PRICE; // Recalculate token price
      currentToken.marketCap = currentToken.price * (currentToken.supply - currentToken.burned); // Update market cap
      currentToken.transactions.push({
        type: 'Buy',
        amount: `${tokenAmount} ${currentToken.ticker}`,
        timestamp: new Date().toLocaleString()
      });
      portfolioHistory[portfolioHistory.length - 1].costBasis += avaxAmount * AVAX_PRICE;
      currentToken.marketCap *= 1.02; // Simulate a 2% MC increase on buy for trending
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      updateTokenDetails(); // Update token details page if open
      document.getElementById('tradeConfirmModal').classList.add('hidden');
      notify(`Swapped ${avaxAmount.toFixed(2)} AVAX for ${tokenAmount.toFixed(2)} ${currentToken.ticker}.`);
      playSound();
    });

    // Event listener for Cancel Trade button
    document.getElementById('cancelTradeBtn').addEventListener('click', () => {
      document.getElementById('tradeConfirmModal').classList.add('hidden');
      playSound();
    });

    // Token Details Page related variables and functions
    let contributionChart = null; // Chart.js instance for whitelist contributions
    let priceChart = null; // Chart.js instance for token price chart
    let burnChart = null; // Chart.js instance for token burn chart

    /**
     * Updates the token details page with information about the currentToken.
     */
    function updateTokenDetails() {
      if (!currentToken) return; // Exit if no token is selected

      // Populate static token details
      document.getElementById('displayTokenName').textContent = currentToken.name;
      document.getElementById('displayTokenTicker').textContent = currentToken.ticker;
      document.getElementById('displayTokenSupply').textContent = currentToken.supply.toFixed(2);
      document.getElementById('marketCap').textContent = currentToken.marketCap.toFixed(2);
      document.getElementById('tokenPrice').textContent = currentToken.price.toFixed(4);
      document.getElementById('fdv').textContent = (currentToken.price * currentToken.originalSupply).toFixed(2);
      // Ensure liquidityPools[currentToken.ticker] exists before accessing
      if (!liquidityPools[currentToken.ticker]) {
        liquidityPools[currentToken.ticker] = { avax: 0, token: 0, totalShares: 0, userShares: {}, fees: {} };
      }
      document.getElementById('lockedLiquidity').textContent = (liquidityPools[currentToken.ticker].avax * AVAX_PRICE).toFixed(2);
      document.getElementById('creatorFee').textContent = currentToken.creatorFee;
      document.getElementById('currentStage').textContent = currentToken.stage;
      document.getElementById('displayCreatorWallet').textContent = currentToken.creatorWallet.slice(0, 6) + '...' + currentToken.creatorWallet.slice(-4);
      document.getElementById('twitterLinkDisplay').textContent = currentToken.twitterLink || 'N/A';
      document.getElementById('twitterLinkDisplay').href = currentToken.twitterLink || '#';
      document.getElementById('discordLinkDisplay').textContent = currentToken.discordLink || 'N/A';
      document.getElementById('discordLinkDisplay').href = currentToken.discordLink || '#';
      document.getElementById('boostStatus').textContent = currentToken.boost ? `Boosted (${currentToken.boost} ${currentToken.ticker})` : 'Not Boosted';
      document.getElementById('tokenomics').textContent = `Airdrop: ${currentToken.airdropPercentage}%, Vesting: ${currentToken.vestingDuration / (1000 * 60 * 60 * 24)} days`;
      document.getElementById('tokenImg').src = currentToken.image || 'https://placehold.co/64x64/00ffaa/ffffff?text=Token'; // Placeholder image

      // Show/hide sections based on token stage
      document.getElementById('snipeSection').classList.toggle('hidden', currentToken.stage !== 'whitelist');
      document.getElementById('contributionSection').classList.toggle('hidden', currentToken.stage !== 'whitelist');
      document.getElementById('tradingInterface').classList.toggle('hidden', currentToken.stage !== 'trading');
      document.getElementById('burnSection').classList.toggle('hidden', currentToken.stage !== 'trading');

      if (currentToken.stage === 'whitelist') {
        const totalContributed = currentToken.contributors.reduce((sum, c) => sum + c.amount, 0);
        document.getElementById('totalContributed').textContent = totalContributed.toFixed(2);
        document.getElementById('totalContributedValue').textContent = (totalContributed * AVAX_PRICE).toFixed(2);

        // Clear existing timer to prevent multiple timers for the same token
        if (currentToken.whitelistTimerId) clearInterval(currentToken.whitelistTimerId);

        currentToken.whitelistTimerId = setInterval(() => {
          const timeLeft = currentToken.whitelistEnd - Date.now();
          if (timeLeft <= 0) {
            clearInterval(currentToken.whitelistTimerId);
            currentToken.stage = 'trading'; // Transition to trading stage
            // Calculate initial price based on total contributions and 50% supply for liquidity
            currentToken.price = totalContributed / (currentToken.supply * 0.5);
            currentToken.marketCap = currentToken.price * currentToken.supply;
            // Initialize liquidity pool for trading
            liquidityPools[currentToken.ticker] = { avax: totalContributed, token: currentToken.supply * 0.5, totalShares: Math.sqrt(totalContributed * currentToken.supply * 0.5), userShares: {}, fees: {} };
            liquidityPools[currentToken.ticker].userShares[wallet.address] = 0; // User starts with no liquidity shares
            // Distribute tokens to contributors based on their contribution
            currentToken.contributors.forEach(c => {
              const tokensReceived = (c.amount / totalContributed) * (currentToken.supply * 0.5);
              tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker] || 0) + tokensReceived).toFixed(2);
            });
            currentToken.vestingStart = Date.now(); // Start vesting timer
            notify(`${currentToken.ticker} whitelist ended. Trading started!`);
            updateTokenLists();
            updateTokenDetails();
            updateBalanceModal();
            updatePortfolio();
            playSound();
          } else {
            document.getElementById('whitelistTimer').textContent = `${Math.floor(timeLeft / 1000)}s`;
          }
        }, 1000);

        if (contributionChart) contributionChart.destroy();
        contributionChart = new Chart(document.getElementById('contributionChart').getContext('2d'), {
          type: 'bar',
          data: {
            labels: currentToken.contributors.map(c => c.wallet.slice(0, 6)),
            datasets: [{
              label: 'Contributions (AVAX)',
              data: currentToken.contributors.map(c => c.amount),
              backgroundColor: '#00ffaa',
              borderColor: '#00ffaa',
              borderWidth: 2
            }]
          },
          options: {
            scales: {
              y: { beginAtZero: true, title: { display: true, text: 'AVAX', font: { family: 'Inter', size: 14, weight: 'bold' } } }
            }
          }
        });
      }

      if (currentToken.stage === 'trading') {
        if (priceChart) priceChart.destroy();
        // Prepare data for candlestick-like chart (simplified bar chart)
        const priceData = currentToken.transactions
          .filter(t => t.type === 'Buy' || t.type === 'Sell')
          .map(t => ({
            x: new Date(t.timestamp).getTime(),
            o: currentToken.price, // Open price (simplified to current price)
            h: currentToken.price * (t.type === 'Buy' ? 1.02 : 0.98), // High (simplified)
            l: currentToken.price * (t.type === 'Buy' ? 0.98 : 0.95), // Low (simplified)
            c: currentToken.price * (t.type === 'Buy' ? 1.02 : 0.95) // Close (simplified)
          }));
        priceChart = new Chart(document.getElementById('priceChart').getContext('2d'), {
          type: 'bar', // Using bar chart to simulate candlesticks visually
          data: {
            datasets: [{
              label: 'Price (USD)',
              data: priceData,
              backgroundColor: priceData.map(d => d.c >= d.o ? '#00ffaa' : '#ff4d4d'), // Green for up, Red for down
              borderColor: priceData.map(d => d.c >= d.o ? '#00ffaa' : '#ff4d4d'),
              borderWidth: 2
            }]
          },
          options: {
            scales: {
              x: { type: 'time', time: { unit: 'minute' } }, // Time scale for X-axis
              y: { beginAtZero: false, title: { display: true, text: 'Price (USD)', font: { family: 'Inter', size: 14, weight: 'bold' } } }
            }
          }
        });
        // Update trading interface details
        document.getElementById('chartPrice').textContent = currentToken.price.toFixed(4);
        document.getElementById('chartMarketCap').textContent = currentToken.marketCap.toFixed(2);
        document.getElementById('chartFdv').textContent = (currentToken.price * currentToken.originalSupply).toFixed(2);
        document.getElementById('chartLockedLiquidity').textContent = (liquidityPools[currentToken.ticker].avax * AVAX_PRICE).toFixed(2);
      }

      // Update burn section details and chart
      document.getElementById('burnTicker').textContent = currentToken.ticker;
      document.getElementById('totalBurned').textContent = currentToken.burned.toFixed(2);
      document.getElementById('supplyRemaining').textContent = ((currentToken.supply / currentToken.originalSupply) * 100).toFixed(2);
      if (burnChart) burnChart.destroy();
      burnChart = new Chart(document.getElementById('burnChart').getContext('2d'), {
        type: 'line',
        data: {
          labels: currentToken.transactions.filter(t => t.type === 'Burn').map(t => t.timestamp),
          datasets: [{
            label: 'Burned Tokens',
            data: currentToken.transactions.filter(t => t.type === 'Burn').map(t => parseFloat(t.amount.split(' ')[0])),
            borderColor: '#ff4d4d',
            backgroundColor: 'rgba(255, 77, 77, 0.2)',
            fill: true,
            tension: 0.4
          }]
        },
        options: {
          scales: {
            y: { beginAtZero: true, title: { display: true, text: 'Tokens Burned', font: { family: 'Inter', size: 14, weight: 'bold' } } }
          }
        }
      });
    }

    // Event listener for Snipe button (for whitelist contributions)
    document.getElementById('snipeBtn').addEventListener('click', () => {
      const amount = parseFloat(document.getElementById('snipeAmount').value);
      const platformFee = amount * 0.05;
      if (isNaN(amount) || amount < currentToken.minContribution || amount > currentToken.maxContribution || amount + platformFee + 0.02 > avaxBalance) {
        notify('Invalid contribution amount or insufficient AVAX.');
        return;
      }
      // Deduct AVAX and update treasury
      avaxBalance = (parseFloat(avaxBalance) - (amount + platformFee + 0.02)).toFixed(2);
      platformTreasury += platformFee;
      currentToken.contributors.push({ wallet: wallet.address, amount }); // Record contributor
      currentToken.transactions.push({
        type: 'Contribution',
        amount: `${amount} AVAX`,
        timestamp: new Date().toLocaleString()
      });
      portfolioHistory[portfolioHistory.length - 1].costBasis += amount * AVAX_PRICE;
      updateTokenDetails();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      notify(`Contributed ${amount} AVAX to ${currentToken.ticker} whitelist.`);
      playSound();
    });

    // Event listener for Burn button
    document.getElementById('burnBtn').addEventListener('click', () => {
      const amount = parseFloat(document.getElementById('burnAmount').value);
      const platformFee = 0.02 * 0.05; // Small platform fee for burning
      if (isNaN(amount) || amount <= 0 || amount > (tokenBalances[currentToken.ticker] || 0) || platformFee + 0.02 > avaxBalance) {
        notify('Invalid burn amount or insufficient balance.');
        return;
      }
      // Deduct tokens from user, update supply and burned amounts
      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker]) - amount).toFixed(2);
      currentToken.supply -= amount;
      currentToken.burned += amount;
      currentToken.marketCap = currentToken.price * currentToken.supply; // Update market cap after burn
      avaxBalance = (parseFloat(avaxBalance) - (platformFee + 0.02)).toFixed(2);
      platformTreasury += platformFee;
      currentToken.transactions.push({
        type: 'Burn',
        amount: `${amount} ${currentToken.ticker}`,
        timestamp: new Date().toLocaleString()
      });
      updateTokenDetails();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      notify(`Burned ${amount} ${currentToken.ticker}.`);
      playSound();
    });

    // Event listeners for Transaction Page
    document.getElementById('viewTransactionsBtn').addEventListener('click', () => {
      document.getElementById('tokenDetailsPage').classList.add('hidden');
      updateTransactionHistory();
      document.getElementById('transactionPage').classList.remove('hidden');
      playSound();
    });

    document.getElementById('backTransactions').addEventListener('click', () => {
      document.getElementById('transactionPage').classList.add('hidden');
      document.getElementById('tokenDetailsPage').classList.remove('hidden');
      playSound();
    });

    /**
     * Updates the transaction history display for the current token.
     */
    function updateTransactionHistory() {
      const transactionHistory = document.getElementById('transactionHistory');
      transactionHistory.innerHTML = '';
      currentToken.transactions.forEach(t => {
        transactionHistory.innerHTML += `<p class="glowing-box p-2 rounded">${t.timestamp}: ${t.type} - ${t.amount}</p>`;
      });
    }

    // Event listeners for Community Chat Page
    document.getElementById('viewChatBtn').addEventListener('click', () => {
      document.getElementById('tokenDetailsPage').classList.add('hidden');
      updateChat();
      document.getElementById('chatPage').classList.remove('hidden');
      playSound();
    });

    document.getElementById('backChat').addEventListener('click', () => {
      document.getElementById('chatPage').classList.add('hidden');
      document.getElementById('tokenDetailsPage').classList.remove('hidden');
      playSound();
    });

    /**
     * Updates the community chat display and calculates sentiment.
     */
    function updateChat() {
      const chatMessages = document.getElementById('chatMessages');
      chatMessages.innerHTML = '';
      currentToken.chatMessages.forEach(m => {
        chatMessages.innerHTML += `
          <div class="glowing-box p-2 rounded mb-2">
            <p><strong>${m.sender.slice(0, 6)}:</strong> ${m.message}</p>
            <p class="text-sm text-gray-400">${m.reactions.join(' ')}</p>
          </div>`;
      });
      // Simple sentiment analysis based on reactions
      const sentimentScore = currentToken.chatMessages.reduce((score, m) => score + m.reactions.filter(r => r === 'ðŸš€').length - m.reactions.filter(r => r === 'ðŸ‘Ž').length, 0);
      document.getElementById('chatSentiment').textContent = sentimentScore > 0 ? 'Bullish' : sentimentScore < 0 ? 'Bearish' : 'Neutral';
      // Simulate price impact based on sentiment
      if (sentimentScore !== 0) {
        currentToken.price *= (1 + sentimentScore * 0.01);
        currentToken.marketCap = currentToken.price * currentToken.supply;
        updateTokenDetails();
      }
    }

    // Event listener for Send Chat message button
    document.getElementById('sendChat').addEventListener('click', () => {
      const message = document.getElementById('chatInput').value;
      if (!message) return;
      currentToken.chatMessages.push({ sender: wallet.address, message, reactions: [] }); // Add new message
      document.getElementById('chatInput').value = ''; // Clear input
      updateChat();
      notify('Message sent to community chat.');
      playSound();
    });

    // Event listeners for Boost Modal
    document.getElementById('boostBtn').addEventListener('click', () => {
      if (!currentToken) {
        notify('Please select a token to boost.');
        return;
      }
      document.getElementById('boostToken').textContent = currentToken.ticker;
      document.getElementById('boostToken2').textContent = currentToken.ticker;
      document.getElementById('boostTokenTicker').textContent = currentToken.ticker;
      document.getElementById('boostModal').classList.remove('hidden');
      playSound();
    });

    document.getElementById('confirmBoostBtn').addEventListener('click', () => {
      const amount = parseFloat(document.getElementById('boostAmount').value);
      const platformFee = 0.02 * 0.05; // Small platform fee for boosting
      if (isNaN(amount) || amount <= 0 || amount > (tokenBalances[currentToken.ticker] || 0) || platformFee + 0.02 > avaxBalance) {
        notify('Invalid boost amount or insufficient balance.');
        return;
      }
      // Deduct tokens from user and add to token's boost value
      tokenBalances[currentToken.ticker] = (parseFloat(tokenBalances[currentToken.ticker]) - amount).toFixed(2);
      currentToken.boost = (currentToken.boost || 0) + amount;
      avaxBalance = (parseFloat(avaxBalance) - (platformFee + 0.02)).toFixed(2);
      platformTreasury += platformFee;
      updateTokenDetails();
      updateTokenLists(); // Update token lists to reflect new trending order
      updateBalanceModal();
      updateTreasury();
      document.getElementById('boostModal').classList.add('hidden');
      notify(`Boosted ${currentToken.ticker} with ${amount} tokens.`);
      playSound();
    });

    document.getElementById('cancelBoostBtn').addEventListener('click', () => {
      document.getElementById('boostModal').classList.add('hidden');
      playSound();
    });

    /**
     * Updates the main token lists (Whitelist, Trading, Trending).
     */
    function updateTokenLists() {
      const whitelistTokens = document.getElementById('whitelistTokens');
      const tradingTokens = document.getElementById('tradingTokens');
      const trendingTokens = document.getElementById('trendingTokens');
      whitelistTokens.innerHTML = '';
      tradingTokens.innerHTML = '';
      trendingTokens.innerHTML = '';

      // Populate Whitelist Tokens section
      tokens.filter(t => t.stage === 'whitelist').forEach(token => {
        whitelistTokens.innerHTML += `
          <div class="glowing-box p-4 rounded-lg mb-2 cursor-pointer" onclick="showTokenDetails('${token.ticker}')">
            <img src="${token.image || 'https://placehold.co/32x32/00ffaa/ffffff?text=WL'}" class="w-8 h-8 rounded-full inline-block mr-2">
            <span>${token.name} (${token.ticker})</span>
            <p class="text-sm">Min: ${token.minContribution} AVAX, Max: ${token.maxContribution} AVAX</p>
          </div>`;
      });

      // Populate Trading Tokens section
      tokens.filter(t => t.stage === 'trading').forEach(token => {
        tradingTokens.innerHTML += `
          <div class="glowing-box p-4 rounded-lg mb-2 cursor-pointer" onclick="showTokenDetails('${token.ticker}')">
            <img src="${token.image || 'https://placehold.co/32x32/ff4d4d/ffffff?text=TR'}" class="w-8 h-8 rounded-full inline-block mr-2">
            <span>${token.name} (${token.ticker})</span>
            <p class="text-sm">Price: $${token.price.toFixed(4)}, MC: $${token.marketCap.toFixed(2)}</p>
          </div>`;
      });

      // Populate Trending Tokens section (top 5 by boost)
      tokens.sort((a, b) => (b.boost || 0) - (a.boost || 0)).slice(0, 5).forEach(token => {
        trendingTokens.innerHTML += `
          <div class="glowing-box p-4 rounded-lg mb-2 cursor-pointer" onclick="showTokenDetails('${token.ticker}')">
            <img src="${token.image || 'https://placehold.co/32x32/4b6cb7/ffffff?text=TD'}" class="w-8 h-8 rounded-full inline-block mr-2">
            <span>${token.name} (${token.ticker})</span>
            <p class="text-sm">Boost: ${token.boost || 0} ${token.ticker}</p>
          </div>`;
      });
    }

    /**
     * Global function to display token details when a token is clicked.
     * @param {string} ticker - The ticker symbol of the token to display.
     */
    window.showTokenDetails = function(ticker) {
      currentToken = tokens.find(t => t.ticker === ticker);
      updateTokenDetails();
      document.getElementById('tokenDetailsPage').classList.remove('hidden');
      playSound();
    };

    // Event listener for Back button on Token Details page
    document.getElementById('backTokenDetails').addEventListener('click', () => {
      document.getElementById('tokenDetailsPage').classList.add('hidden');
      playSound();
    });

    // Event listener for Launch Token Form submission
    document.getElementById('launchForm').addEventListener('submit', e => {
      e.preventDefault(); // Prevent default form submission
      if (!wallet) {
        notify('Please sign in by initializing the app.');
        return;
      }
      // Retrieve form values
      const name = document.getElementById('tokenName').value;
      const ticker = document.getElementById('tokenTicker').value.toUpperCase();
      let supply = parseFloat(document.getElementById('tokenSupply').value);
      const image = document.getElementById('tokenImage').value;
      const twitterLink = document.getElementById('twitterLink').value;
      const discordLink = document.getElementById('discordLink').value;
      const whitelistDuration = parseFloat(document.getElementById('whitelistDuration').value);
      const durationUnit = document.getElementById('durationUnit').value;
      const minContribution = parseFloat(document.getElementById('minContribution').value);
      const maxContribution = parseFloat(document.getElementById('maxContribution').value);
      const airdropPercentage = parseFloat(document.getElementById('airdropPercentage').value);
      const vestingDuration = parseFloat(document.getElementById('vestingDuration').value);
      const vestingUnit = document.getElementById('vestingUnit').value;
      const creatorFee = parseFloat(document.getElementById('creatorFeeInput').value);
      const preBuyPercentage = parseFloat(document.getElementById('preBuyPercentage').value) || 0;
      const preBuyAvax = parseFloat(document.getElementById('preBuyAvax').value) || 0;
      const platformFee = preBuyAvax * 0.05;

      // Basic input validation
      if (!name || !ticker || isNaN(supply) || supply <= 0 || isNaN(whitelistDuration) || whitelistDuration <= 0 ||
          isNaN(minContribution) || minContribution <= 0 || isNaN(maxContribution) || maxContribution < minContribution ||
          isNaN(airdropPercentage) || airdropPercentage < 0 || airdropPercentage > 100 ||
          isNaN(vestingDuration) || vestingDuration <= 0 || isNaN(creatorFee) || creatorFee < 0 || creatorFee > 5 ||
          (preBuyPercentage > 0 && (isNaN(preBuyAvax) || preBuyAvax <= 0 || preBuyAvax + platformFee + 0.02 > avaxBalance))) {
        notify('Invalid input or insufficient AVAX for pre-buy.');
        return;
      }

      // Calculate duration in milliseconds
      const durationMultipliers = { seconds: 1000, minutes: 60 * 1000, hours: 3600 * 1000, days: 24 * 3600 * 1000, months: 30 * 24 * 3600 * 1000 };
      const token = {
        name,
        ticker,
        originalSupply: supply,
        supply,
        burned: 0,
        price: 0, // Initial price is 0 during whitelist
        marketCap: 0, // Initial market cap is 0 during whitelist
        stage: 'whitelist',
        whitelistEnd: Date.now() + whitelistDuration * durationMultipliers[durationUnit],
        minContribution,
        maxContribution,
        airdropPercentage,
        vestingDuration: vestingDuration * durationMultipliers[vestingUnit],
        airdropClaimed: 0,
        contributors: [],
        transactions: [],
        chatMessages: [],
        creatorWallet: wallet.address,
        image,
        twitterLink,
        discordLink,
        boost: 0,
        creatorFee
      };
      tokens.push(token); // Add new token to the global tokens array

      // Handle pre-whitelist buy if specified
      if (preBuyPercentage > 0) {
        const preBuyTokens = supply * (preBuyPercentage / 100);
        supply -= preBuyTokens; // Reduce supply available for whitelist
        token.supply = supply;
        tokenBalances[ticker] = (parseFloat(tokenBalances[ticker] || 0) + preBuyTokens).toFixed(2);
        avaxBalance = (parseFloat(avaxBalance) - (preBuyAvax + platformFee + 0.02)).toFixed(2);
        platformTreasury += platformFee;
        token.transactions.push({
          type: 'Pre-Buy',
          amount: `${preBuyTokens} ${ticker} for ${preBuyAvax} AVAX`,
          timestamp: new Date().toLocaleString()
        });
        portfolioHistory[portfolioHistory.length - 1].costBasis += preBuyAvax * AVAX_PRICE;
      }
      updateTokenLists();
      updateBalanceModal();
      updatePortfolio();
      updateTreasury();
      document.getElementById('launchPage').classList.add('hidden');
      notify(`Launched ${ticker} token.`);
      playSound();
    });

    // Event listener for Back button on Launch Token page
    document.getElementById('backLaunch').addEventListener('click', () => {
      document.getElementById('launchPage').classList.add('hidden');
      document.getElementById('menuModal').classList.remove('hidden');
      playSound();
    });

    // Event listeners for Automated Trading Modal
    // Replaced with new toggleModalScroll implementation
    document.getElementById('autoTradeBtn').addEventListener('click', () => {
      toggleModalScroll('menuModal', false);
      toggleModalScroll('autoTradeModal', true);
      updateAutoTradeModal();
      playSound();
    });

    document.getElementById('closeAutoTrade').addEventListener('click', () => {
      toggleModalScroll('autoTradeModal', false);
      playSound();
    });

    document.getElementById('backAutoTrade').addEventListener('click', () => {
      toggleModalScroll('autoTradeModal', false);
      toggleModalScroll('menuModal', true);
      playSound();
    });

    /**
     * Updates the automated trading modal with available tokens and active auto trades.
     */
    function updateAutoTradeModal() {
      const autoBuyTokenSelect = document.getElementById('autoBuyToken');
      const autoSellTokenSelect = document.getElementById('autoSellToken');
      autoBuyTokenSelect.innerHTML = '<option value="">Select Token</option>';
      autoSellTokenSelect.innerHTML = '<option value="">Select Token</option>';
      tokens.filter(t => t.stage === 'trading').forEach(token => {
        autoBuyTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker}</option>`;
        autoSellTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker}</option>`;
      });
      const activeAutoTrades = document.getElementById('activeAutoTrades');
      activeAutoTrades.innerHTML = '';
      autoTrades.forEach(trade => {
        activeAutoTrades.innerHTML += `
          <div class="glowing-box p-4 rounded-lg mb-2">
            <p><strong>${trade.type} ${trade.amount} ${trade.ticker}</strong></p>
            <p>Interval: ${trade.interval} ${trade.unit}</p>
            <button class="stopAutoTradeBtn w-full neon-btn text-white px-4 py-2 rounded mt-2" data-id="${trade.id}">Stop</button>
          </div>`;
      });
      // Add event listeners for dynamically created stop buttons
      document.querySelectorAll('.stopAutoTradeBtn').forEach(btn => {
        btn.addEventListener('click', () => {
          const id = btn.dataset.id;
          clearInterval(autoTrades.find(t => t.id === id).intervalId); // Clear the interval
          autoTrades = autoTrades.filter(t => t.id !== id); // Remove from active trades
          updateAutoTradeModal();
          notify(`Stopped auto trade ${id}.`);
          playSound();
        });
      });
    }

    // Event listener for Start Auto Buy button
    document.getElementById('startAutoBuy').addEventListener('click', () => {
      const ticker = document.getElementById('autoBuyToken').value;
      const amount = parseFloat(document.getElementById('autoBuyAmount').value);
      const interval = parseInt(document.getElementById('autoBuyInterval').value);
      const unit = document.getElementById('autoBuyUnit').value;
      if (!ticker || isNaN(amount) || amount <= 0 || isNaN(interval) || interval <= 0) {
        notify('Invalid auto buy settings.');
        return;
      }
      const intervalMs = unit === 'seconds' ? interval * 1000 : interval * 60 * 1000;
      const intervalId = setInterval(() => {
        const platformFee = amount * 0.05;
        if (amount + platformFee + 0.02 > avaxBalance) {
          clearInterval(intervalId); // Stop if insufficient funds
          autoTrades = autoTrades.filter(t => t.id !== `buy_${ticker}_${Date.now()}`); // Remove from list
          notify(`Auto buy for ${ticker} stopped due to insufficient AVAX.`);
          updateAutoTradeModal();
          return;
        }
        const token = tokens.find(t => t.ticker === ticker);
        const tokenAmount = (amount / token.price).toFixed(2);
        avaxBalance = (parseFloat(avaxBalance) - (amount + platformFee + 0.02)).toFixed(2);
        platformTreasury += platformFee;
        tokenBalances[ticker] = (parseFloat(tokenBalances[ticker] || 0) + parseFloat(tokenAmount)).toFixed(2);
        const pool = liquidityPools[ticker];
        pool.avax += amount;
        pool.token -= tokenAmount;
        token.price = pool.avax / pool.token * AVAX_PRICE;
        token.marketCap = token.price * token.supply;
        token.transactions.push({
          type: 'Buy',
          amount: `${tokenAmount} ${ticker}`,
          timestamp: new Date().toLocaleString()
        });
        portfolioHistory[portfolioHistory.length - 1].costBasis += amount * AVAX_PRICE;
        updateBalanceModal();
        updatePortfolio();
        updateTreasury();
        notify(`Auto bought ${tokenAmount} ${ticker} for ${amount} AVAX.`);
        playSound();
      }, intervalMs);
      autoTrades.push({ id: `buy_${ticker}_${Date.now()}`, type: 'Auto Buy', ticker, amount, interval, unit, intervalId });
      updateAutoTradeModal();
      notify(`Started auto buy for ${ticker}: ${amount} AVAX every ${interval} ${unit}.`);
      playSound();
    });

    // Event listener for Start Auto Sell button
    document.getElementById('startAutoSell').addEventListener('click', () => {
      const ticker = document.getElementById('autoSellToken').value;
      const amount = parseFloat(document.getElementById('autoSellAmount').value);
      const interval = parseInt(document.getElementById('autoSellInterval').value);
      const unit = document.getElementById('autoSellUnit').value;
      if (!ticker || isNaN(amount) || amount <= 0 || amount > (tokenBalances[ticker] || 0) || isNaN(interval) || interval <= 0) {
        notify('Invalid auto sell settings.');
        return;
      }
      const intervalMs = unit === 'seconds' ? interval * 1000 : interval * 60 * 1000;
      const intervalId = setInterval(() => {
        if (amount > (tokenBalances[ticker] || 0)) {
          clearInterval(intervalId); // Stop if insufficient tokens
          autoTrades = autoTrades.filter(t => t.id !== `sell_${ticker}_${Date.now()}`); // Remove from list
          notify(`Auto sell for ${ticker} stopped due to insufficient tokens.`);
          updateAutoTradeModal();
          return;
        }
        const token = tokens.find(t => t.ticker === ticker);
        const avaxAmount = (amount * token.price).toFixed(2);
        const platformFee = avaxAmount * 0.05;
        // const creatorFee = (avaxAmount * token.creatorFee / 100).toFixed(2); // Creator fee not directly used here for simplicity
        tokenBalances[ticker] = (parseFloat(tokenBalances[ticker]) - amount).toFixed(2);
        avaxBalance = (parseFloat(avaxBalance) + parseFloat(avaxAmount) - platformFee - 0.02).toFixed(2);
        platformTreasury += platformFee;
        const pool = liquidityPools[ticker];
        pool.avax -= avaxAmount;
        pool.token += amount;
        token.price = pool.avax / pool.token * AVAX_PRICE;
        token.marketCap = token.price * token.supply * 0.98; // Simulate 2% MC decrease on sell
        token.transactions.push({
          type: 'Sell',
          amount: `${amount} ${ticker}`,
          timestamp: new Date().toLocaleString()
        });
        updateBalanceModal();
        updatePortfolio();
        updateTreasury();
        notify(`Auto sold ${amount} ${ticker} for ${avaxAmount} AVAX.`);
        playSound();
      }, intervalMs);
      autoTrades.push({ id: `sell_${ticker}_${Date.now()}`, type: 'Auto Sell', ticker, amount, interval, unit, intervalId });
      updateAutoTradeModal();
      notify(`Started auto sell for ${ticker}: ${amount} tokens every ${interval} ${unit}.`);
      playSound();
    });

    /**
     * Simulates bot trading activity for existing tokens.
     */
    function simulateBotActivity() {
      tokens.filter(t => t.stage === 'trading').forEach(token => {
        const pool = liquidityPools[token.ticker];
        // Ensure pool exists and has liquidity before simulating trades
        if (!pool || pool.avax <= 0 || pool.token <= 0) return;

        const isBuy = Math.random() > 0.5; // Randomly decide between buy or sell
        const amount = (Math.random() * 10 + 1).toFixed(2); // Random trade amount

        if (isBuy) {
          pool.avax += parseFloat(amount);
          const tokenAmount = (parseFloat(amount) / token.price).toFixed(2);
          pool.token -= parseFloat(tokenAmount);
          token.transactions.push({
            type: 'Buy',
            amount: `${tokenAmount} ${token.ticker}`,
            timestamp: new Date().toLocaleString()
          });
          token.marketCap *= 1.02; // Simulate 2% MC increase on bot buy
        } else {
          const tokenAmount = (parseFloat(amount) / token.price).toFixed(2);
          if (pool.token >= parseFloat(tokenAmount)) { // Ensure enough tokens in pool to sell
            pool.avax -= parseFloat(amount);
            pool.token += parseFloat(tokenAmount);
            token.transactions.push({
              type: 'Sell',
              amount: `${tokenAmount} ${token.ticker}`,
              timestamp: new Date().toLocaleString()
            });
            token.marketCap *= 0.98; // Simulate 2% MC decrease on bot sell
          }
        }
        // Recalculate price based on new pool state
        token.price = pool.avax / pool.token * AVAX_PRICE;
        notify(`Bot ${isBuy ? 'bought' : 'sold'} ${amount} ${isBuy ? 'AVAX' : token.ticker} for ${token.ticker}.`);
      });
      updateTokenLists(); // Update lists to reflect price/MC changes
      updateTokenDetails(); // Update details if a token is currently viewed
      playSound();
    }

    /**
     * Creates some initial simulated tokens for demonstration purposes.
     */
    function simulateBotTokens() {
      const botTokens = [
        { name: 'MoonCoin', ticker: 'MOON', supply: 1000000, image: 'https://placehold.co/32x32/00ffaa/ffffff?text=MOON', minContribution: 1, maxContribution: 100, airdropPercentage: 10, vestingDuration: 30 * 24 * 3600 * 1000, creatorFee: 2 },
        { name: 'StarToken', ticker: 'STAR', supply: 500000, image: 'https://placehold.co/32x32/ff4d4d/ffffff?text=STAR', minContribution: 0.5, maxContribution: 50, airdropPercentage: 5, vestingDuration: 15 * 24 * 3600 * 1000, creatorFee: 1 }
      ];
      botTokens.forEach(t => {
        const token = {
          name: t.name,
          ticker: t.ticker,
          originalSupply: t.supply,
          supply: t.supply,
          burned: 0,
          price: 0.1, // Initial price for simulated tokens
          marketCap: 0.1 * t.supply,
          stage: 'trading', // Start directly in trading stage
          whitelistEnd: Date.now(), // Not applicable for trading stage, but kept for structure
          minContribution: t.minContribution,
          maxContribution: t.maxContribution,
          airdropPercentage: t.airdropPercentage,
          vestingDuration: t.vestingDuration,
          airdropClaimed: 0,
          contributors: [],
          transactions: [],
          chatMessages: [],
          creatorWallet: ethers.Wallet.createRandom().address, // Random creator wallet for bots
          image: t.image,
          twitterLink: '',
          discordLink: '',
          boost: 0,
          creatorFee: t.creatorFee
        };
        tokens.push(token);
        // Initialize liquidity pool for simulated tokens
        liquidityPools[token.ticker] = { avax: 1000, token: token.supply * 0.5, totalShares: Math.sqrt(1000 * token.supply * 0.5), userShares: {}, fees: {} };
        liquidityPools[token.ticker].userShares[wallet.address] = 0;
        token.vestingStart = Date.now(); // Start vesting immediately for simulated tokens
      });
      updateTokenLists(); // Update the main token lists after adding bot tokens
    }

    // Launch Token Button
    // Replaced with new toggleModalScroll implementation
    document.getElementById('launchTokenBtn').addEventListener('click', () => {
      toggleModalScroll('menuModal', false);
      toggleModalScroll('launchPage', true);
      playSound();
    });

    // Swap Button
    document.getElementById('swapBtn').addEventListener('click', () => {
      document.getElementById('menuModal').classList.add('hidden');
      updateSwapSection();
      document.getElementById('swapPage').classList.remove('hidden');
      playSound();
    });

    // Collapse Section Buttons
    document.getElementById('toggleWhitelist').addEventListener('click', () => {
      const content = document.getElementById('whitelistTokens');
      content.classList.toggle('hidden');
      document.getElementById('toggleWhitelist').textContent = content.classList.contains('hidden') ? 'Expand' : 'Collapse';
      playSound();
    });

    document.getElementById('toggleTrading').addEventListener('click', () => {
      const content = document.getElementById('tradingTokens');
      content.classList.toggle('hidden');
      document.getElementById('toggleTrading').textContent = content.classList.contains('hidden') ? 'Expand' : 'Collapse';
      playSound();
    });

    document.getElementById('toggleTrending').addEventListener('click', () => {
      const content = document.getElementById('trendingTokens');
      content.classList.toggle('hidden');
      document.getElementById('toggleTrending').textContent = content.classList.contains('hidden') ? 'Expand' : 'Collapse';
      playSound();
    });

    // Update Swap Section
    function updateSwapSection() {
      const swapTokenSelect = document.getElementById('swapToken');
      swapTokenSelect.innerHTML = '<option value="">Select Token</option>';
      tokens.filter(t => t.stage === 'trading').forEach(token => {
        swapTokenSelect.innerHTML += `<option value="${token.ticker}">${token.ticker}</option>`;
      });
    }

    // Function to toggle modal-open class on body and modal visibility
    function toggleModalScroll(modalId, isOpen) {
      document.body.classList.toggle('modal-open', isOpen);
      document.getElementById(modalId).classList.toggle('hidden', !isOpen);
    }

    // Initialize App when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', initialize);
  </script>
</body>
</html>
