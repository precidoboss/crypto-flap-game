<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Precido DEX Simulation</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Google Fonts - Inter & Poppins -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Custom CSS for glowing effects and animations */
    body {
      font-family: 'Inter', sans-serif;
      background-color: #0a0a0a; /* Deep charcoal/black */
      color: #e0e0e0; /* Light gray for text */
      overflow-x: hidden; /* Prevent horizontal scroll */
    }

    /* Base glow for cards/sections */
    .glow-border {
      position: relative;
      overflow: hidden;
      border-radius: 12px; /* Consistent rounded corners */
      background-color: #1a1a1a; /* Darker background for content inside glow */
    }
    .glow-border::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, #00eaff, #8a2be2, #00eaff); /* Electric blue to vibrant purple */
      background-size: 400% 400%;
      animation: glowing-border 8s linear infinite;
      z-index: -1;
      filter: blur(8px);
      opacity: 0.7;
      border-radius: 12px;
    }
    /* Subtle glow for inner cards/sub-sections */
    .glow-border-subtle {
      position: relative;
      overflow: hidden;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.05); /* Very subtle border */
    }
    .glow-border-subtle::before {
      content: '';
      position: absolute;
      top: -1px;
      left: -1px;
      right: -1px;
      bottom: -1px;
      background: linear-gradient(45deg, rgba(0,234,255,0.2), rgba(138,43,226,0.2), rgba(0,234,255,0.2));
      background-size: 400% 400%;
      animation: glowing-border 12s linear infinite;
      z-index: -1;
      filter: blur(4px);
      opacity: 0.5;
      border-radius: 12px;
    }

    /* Hover effect for clickable pool cards */
    .clickable-pool-card {
      transition: all 0.3s ease-in-out;
      cursor: pointer;
    }
    .clickable-pool-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 20px rgba(0, 234, 255, 0.3);
    }
    .clickable-pool-card:hover .glow-border::before,
    .clickable-pool-card:hover .glow-border-subtle::before {
      animation: glowing-border-hover 2s linear infinite; /* Faster glow on hover */
      filter: blur(12px);
      opacity: 1;
    }

    /* Moving glow effect inside cards */
    .moving-glow-effect {
      opacity: 0.1;
      background: linear-gradient(45deg, transparent, #00eaff, transparent);
      background-size: 200% 200%;
      animation: moving-glow 5s linear infinite;
      filter: blur(8px);
      pointer-events: none; /* Ensure it doesn't block clicks */
    }
    @keyframes moving-glow {
      0% { background-position: 0% 0%; }
      100% { background-position: 100% 100%; }
    }

    /* Button specific glows */
    .glow-button {
      position: relative;
      overflow: hidden;
      z-index: 1;
      transition: all 0.3s ease;
    }
    .glow-button::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(0,234,255,0.5) 0%, rgba(138,43,226,0.5) 50%, transparent 100%);
      transform: rotate(0deg);
      animation: rotate-glow 4s linear infinite;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: -1;
    }
    .glow-button:hover::before {
      opacity: 1;
    }
    .glow-button:active::before {
      animation: none; /* Stop rotation on click */
      opacity: 1;
      transform: scale(1.5); /* Quick burst effect */
      transition: transform 0.1s ease-out;
    }

    @keyframes glowing-border {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    @keyframes glowing-border-hover {
      0% { background-position: 0% 50%; }
      100% { background-position: 100% 50%; }
    }
    @keyframes rotate-glow {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    /* Specific styles for animated swap route */
    .swap-route-animation {
        position: relative;
        height: 40px; /* Adjust height as needed */
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-top: 1rem;
        padding: 0 10px; /* Padding for nodes */
    }
    .swap-route-animation::before {
        content: '';
        position: absolute;
        left: 0;
        right: 0;
        height: 2px;
        background: linear-gradient(90deg, transparent, #00eaff, #8a2be2, transparent);
        background-size: 200% 100%;
        animation: route-flow 3s linear infinite;
        z-index: 0;
    }
    .swap-route-node {
        width: 24px;
        height: 24px;
        background-color: #1a1a1a;
        border: 2px solid #00eaff;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        font-weight: bold;
        color: #00eaff;
        z-index: 1;
        box-shadow: 0 0 8px #00eaff;
    }
    .swap-route-node.active {
        border-color: #8a2be2;
        color: #8a2be2;
        box-shadow: 0 0 12px #8a2be2;
    }
    @keyframes route-flow {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
    }

    /* Custom scrollbar for a futuristic feel */
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #1a1a1a;
    }
    ::-webkit-scrollbar-thumb {
      background: #00eaff;
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #8a2be2;
    }

    /* Confirmation Modal */
    .modal {
      display: none; /* Hidden by default, JS toggles flex */
      position: fixed; /* Stay in place */
      z-index: 1000; /* Sit on top */
      left: 0;
      top: 0;
      width: 100%; /* Full width */
      height: 100%; /* Full height */
      overflow: auto; /* Enable scroll if needed */
      background-color: rgba(0,0,0,0.7); /* Black w/ opacity */
      backdrop-filter: blur(5px); /* Blurred background */
      -webkit-backdrop-filter: blur(5px);
      align-items: center;
      justify-content: center;
    }
    .modal-content {
      background-color: #1a1a1a;
      margin: auto;
      padding: 2.5rem;
      border-radius: 1rem;
      box-shadow: 0 0 20px rgba(0, 234, 255, 0.5);
      max-width: 500px;
      width: 90%;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    .modal-content::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(0,234,255,0.1) 0%, transparent 70%);
      transform: rotate(0deg);
      animation: rotate-glow 10s linear infinite;
      z-index: -1;
    }

    /* Message Box */
    #messageBox {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #28a745; /* Green for success */
        color: white;
        padding: 15px 30px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        z-index: 1100;
        opacity: 0;
        transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
        min-width: 250px;
        text-align: center;
    }
    #messageBox.error {
        background-color: #dc3545; /* Red for error */
    }
    #messageBox.show {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
  </style>
</head>
<body class="min-h-screen flex flex-col">

  <!-- Confirmation Modal Structure -->
  <div id="confirmationModal" class="modal">
    <div class="modal-content">
      <p id="modalMessage" class="text-xl mb-6 text-white"></p>
      <div class="flex justify-center space-x-4">
        <button id="modalConfirmBtn" class="glow-button bg-gradient-to-r from-green-500 to-teal-500 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:from-green-600 hover:to-teal-600 transition-all duration-300">Confirm</button>
        <button id="modalCancelBtn" class="glow-button bg-gradient-to-r from-gray-600 to-gray-700 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:from-gray-700 hover:to-gray-800 transition-all duration-300">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Message Box -->
  <div id="messageBox"></div>

  <!-- Header -->
  <header class="bg-gray-900 text-white p-4 shadow-lg flex justify-between items-center relative z-10">
    <div class="text-3xl font-bold font-poppins text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-600">PRECIDO DEX</div>
    <button id="hamburgerMenu" class="text-white focus:outline-none">
      <svg class="w-8 h-8 glowing-svg" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path>
      </svg>
    </button>
  </header>

  <!-- Navigation Sidebar -->
  <nav id="sidebar" class="fixed top-0 right-0 h-full w-64 bg-gray-900 text-white shadow-xl transform translate-x-full transition-transform duration-300 ease-in-out z-20 p-6 flex flex-col">
    <button id="closeSidebar" class="self-end text-white text-3xl mb-8 focus:outline-none">&times;</button>
    <ul class="space-y-4 text-xl font-semibold">
      <li><a href="#" id="navHome" class="block py-2 px-4 rounded-lg hover:bg-gray-700 transition-colors duration-200">Home</a></li>
      <li><a href="#" id="navDexTrade" class="block py-2 px-4 rounded-lg hover:bg-gray-700 transition-colors duration-200">DEX Trade</a></li>
      <li><a href="#" id="navLiquidity" class="block py-2 px-4 rounded-lg hover:bg-gray-700 transition-colors duration-200">Liquidity</a></li>
      <li><a href="#" id="navFarming" class="block py-2 px-4 rounded-lg hover:bg-gray-700 transition-colors duration-200">Farming</a></li>
      <li><a href="#" id="navLaunchToken" class="block py-2 px-4 rounded-lg hover:bg-gray-700 transition-colors duration-200">Launch Token</a></li>
      <li><a href="#" id="navPresaleStage" class="block py-2 px-4 rounded-lg hover:bg-gray-700 transition-colors duration-200">Presale Stage</a></li>
      <li><a href="#" id="navGame" class="block py-2 px-4 rounded-lg hover:bg-gray-700 transition-colors duration-200">Game</a></li>
      <li><a href="#" id="navGovernance" class="block py-2 px-4 rounded-lg hover:bg-gray-700 transition-colors duration-200">Governance (Display)</a></li>
      <li><a href="#" id="navAdmin" class="block py-2 px-4 rounded-lg hover:bg-gray-700 transition-colors duration-200">Admin</a></li>
      <li><a href="#" id="navPlatformWallet" class="block py-2 px-4 rounded-lg hover:bg-gray-700 transition-colors duration-200">Platform Wallet</a></li>
      <li><a href="#" id="navBlackMarket" class="block py-2 px-4 rounded-lg hover:bg-gray-700 transition-colors duration-200">Black Market</a></li>
    </ul>
  </nav>

  <!-- Main Content Area -->
  <main id="mainContent" class="flex-grow p-6 transition-all duration-300 ease-in-out">
    <!-- Pages will be dynamically loaded here -->
  </main>

  <script>
    // --- Global State Variables ---
    const state = {
      // Platform Core
      tokens: {}, // Stores all token data: { ticker: { name, total_supply, circulating_supply, decimals, price_usd, market_cap_usd, is_base_asset, is_stablecoin, creator_id, launch_details, dev_team_holdings_percent, dev_team_holdings_amount } }
      liquidityPools: {}, // { poolId: { tokenA, tokenB, balanceA, balanceB, k, lpTokenSupply, feesEarnedLP, incentivesAdded: {token: amount}, type, volumeUSD } }
      farmingPools: {}, // { poolId: { stakedToken, rewardToken, totalStakedAmount, rewardRatePerSecond, durationSeconds, lockupDurationSeconds, type, availableRewards, startTime, endTime, stakers: {userId: {stakedAmount, stakeTime, claimableRewards, unstakeAvailableTimestamp}}, creator_id } }
      users: {}, // { userId: { isBot, balances: { token: amount }, liquidityPositions: [], farmingStakes: [], gameRewardsPending: [], totalUsdValue } }
      presaleProjects: {}, // { projectId: { tokenDetails, creatorId, status, hardCapUsdt, softCapUsdt, usdtRaised, tokensForSale, tokensSold, buyersList, progressPercent, initialDexLiquidityUsdt, initial_dex_liquidity_tokens } }
      platformWallet: {
        id: 'platform_owner',
        isBot: false,
        balances: {
          USDT: 0, BTC: 0, ETH: 0, AVAX: 0, SOL: 0, USDC: 0, PDEX: 0, // Will be set to $10k equivalent dynamically
        },
        liquidityPositions: [], // LP positions owned by the platform owner
        farmingStakes: [], // Farming stakes owned by the platform owner
        gameRewardsPending: [], // Game rewards pending for the platform owner
        totalUsdValue: 0, // Calculated dynamically
        revenueTracker: { // Specific revenue tracking for the platform owner
          lpRewards: 0,
          farmingRewards: 0,
          gamingWins: 0,
          platformFees: 0,
        }
      },
      platformSettings: {
        transactionFeePercentage: 5, // Reduced to 5%
        feeDistributionLPRewardsPercent: 80, // 80% of 5% = 4% of transaction value
        feeDistributionPlatformWalletPercent: 10, // 10% of 5% = 0.5% of transaction value
        feeDistributionPdexBurnPercent: 10, // 10% of 5% = 0.5% of transaction value
        botActivityEnabled: true,
        botTradingFrequencyMin: 10000, // ms
        botTradingFrequencyMax: 60000, // ms
        botLpActivityFrequencyMin: 30000, // ms
        botLpActivityFrequencyMax: 120000, // ms
        botFarmingFrequencyMin: 30000, // ms
        botFarmingFrequencyMax: 120000, // ms
        botPresaleBuyFrequencyMin: 5000, // ms
        botPresaleBuyFrequencyMax: 15000, // ms
        minLiquidityForLaunch: 5000, // USDT equivalent
        maxLiquidityPercentLaunch: 60,
        maxBurnPercentLaunch: 15,
        maxPlatformPercentLaunch: 10,
        maxPresalePercentLaunch: 20,
        maxTeamPercentLaunch: 30,
        botTradingAggressiveness: 0.05, // % of balance bots trade
        botLpAddAggressiveness: 0.05, // % of balance bots add to LP
        botFarmingAggressiveness: 0.1, // % of balance bots stake in farming
      },
      pdexToken: {
        ticker: 'PDEX',
        name: 'Precido DEX Token',
        total_supply: 1000000000,
        circulating_supply: 900000000, // 10% burnt at launch
        price_usd: 0.001111, // Initial MC $1M / 900M circulating
        total_burnt_from_fees: 0,
        burn_cap_reached: false,
        burn_cap_amount: 100000000, // 10% of initial total supply
      },
      gameRewardsPool: {
        availableRewards: { // Initial rewards for the game pool - now empty, manually supplied
        },
        totalUsdValue: 0, // Calculated dynamically
        rewardProbabilities: [ // { token: tokenTicker, probability: chance, minAmount: min, maxAmount: max, isUsdValue: bool }
          { token: 'USDT', probability: 0.5, minAmount: 0.1, maxAmount: 5, isUsdValue: true },
          { token: 'ETH', probability: 0.1, minAmount: 0.0001, maxAmount: 0.001, isUsdValue: false },
          { token: 'BTC', probability: 0.02, minAmount: 0.000001, maxAmount: 0.00001, isUsdValue: false },
        ],
        last5Transactions: [], // { timestamp, userId, action, paidToken, paidAmountUsd, outcome, rewardsWon }
      },
      appStats: {
        totalRevenue: 0, // Total fees collected by platform
        totalRevenueGivenBackToUsers: 0, // Total fees distributed to LPs + farming rewards + game wins
        topEarners: [], // { userId, totalUsdEarned } - calculated dynamically
        totalUsersOnline: 100000, // Simulated
        totalVolumeUSD: 0, // Total trading volume on DEX
      },
      // Simulation specific
      simulationTime: 0, // In seconds, for tracking epoch, etc.
      lastBotApplicationTime: Date.now(), // Track when last bot app was submitted
      epochStartTime: Date.now(), // For governance epoch tracking
      lastLPFeeDistributionTime: Date.now(), // Track last time LP fees were distributed
    };

    // --- Utility Functions ---

    function generateUniqueId() {
      return 'id_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function formatUSD(amount) {
      return `$${amount.toFixed(2)}`;
    }

    function formatTokenAmount(amount, decimals = 4) { // Increased decimals for better precision display
      return amount.toFixed(decimals);
    }

    function calculateTokenUSDValue(tokenTicker, amount) {
      if (!state.tokens[tokenTicker] || !state.tokens[tokenTicker].price_usd) return 0;
      return amount * state.tokens[tokenTicker].price_usd;
    }

    // Message Box Function
    function showMessageBox(message, isError = false) {
        const messageBox = document.getElementById('messageBox');
        messageBox.textContent = message;
        messageBox.className = 'messageBox show'; // Reset classes
        if (isError) {
            messageBox.classList.add('error');
        } else {
            messageBox.classList.remove('error');
        }

        setTimeout(() => {
            messageBox.classList.remove('show');
        }, 3000); // Hide after 3 seconds
    }

    function showConfirmationModal(message) {
      const modal = document.getElementById('confirmationModal');
      const modalMessage = document.getElementById('modalMessage');
      const modalConfirmBtn = document.getElementById('modalConfirmBtn');
      const modalCancelBtn = document.getElementById('modalCancelBtn');

      modalMessage.textContent = message;
      modal.style.display = 'flex'; // Show modal

      return new Promise((resolve) => {
        const confirmHandler = () => {
          modal.style.display = 'none';
          modalConfirmBtn.removeEventListener('click', confirmHandler);
          modalCancelBtn.removeEventListener('click', cancelHandler);
          resolve(true);
        };
        const cancelHandler = () => {
          modal.style.display = 'none';
          modalConfirmBtn.removeEventListener('click', confirmHandler);
          modalCancelBtn.removeEventListener('click', cancelHandler);
          resolve(false);
        };

        modalConfirmBtn.addEventListener('click', confirmHandler);
        modalCancelBtn.addEventListener('click', cancelHandler);
      });
    }

    // --- Core Financial & AMM Logic ---

    /**
     * Calculates the output amount and slippage for a swap using x*y=k.
     * @param {number} inputAmount Amount of token to sell.
     * @param {number} inputReserve Current reserve of input token in pool.
     * @param {number} outputReserve Current reserve of output token in pool.
     * @returns {{outputAmount: number, slippage: number}}
     */
    function calculateSwapOutput(inputAmount, inputReserve, outputReserve) {
      if (inputReserve <= 0 || outputReserve <= 0 || inputAmount <= 0) {
          return { outputAmount: 0, slippage: 0 };
      }
      const k = inputReserve * outputReserve;
      const newInputReserve = inputReserve + inputAmount;
      const newOutputReserve = k / newInputReserve;
      const outputAmount = outputReserve - newOutputReserve;

      // Calculate slippage
      const currentPrice = outputReserve / inputReserve;
      const expectedOutput = inputAmount * currentPrice;
      const slippage = ((expectedOutput - outputAmount) / expectedOutput) * 100;

      return { outputAmount, slippage };
    }

    /**
     * Applies the transaction fee and distributes it.
     * @param {string} userId The ID of the user/bot performing the action.
     * @param {number} usdValue The USD value of the transaction (funds issued).
     * @param {string} type The type of transaction (e.g., 'Swap', 'AddLiquidity').
     * @param {string} poolId Optional: The ID of the pool involved.
     * @returns {boolean} True if fee successfully deducted, false otherwise.
     */
    function applyTransactionFee(userId, usdValue, type, poolId = null) {
      const user = state.users[userId];
      if (!user) {
          console.error(`User ${userId} not found for fee application.`);
          return false;
      }

      const feePercentage = state.platformSettings.transactionFeePercentage / 100;
      const totalFeeUsdt = usdValue * feePercentage;

      if (user.balances.USDT < totalFeeUsdt) {
        showMessageBox(`Insufficient USDT for fee: ${formatUSD(totalFeeUsdt)}. Action cancelled.`, true);
        return false;
      }

      user.balances.USDT -= totalFeeUsdt;
      state.appStats.totalRevenue += totalFeeUsdt;
      state.platformWallet.revenueTracker.platformFees += totalFeeUsdt; // Track for platform owner

      // Distribute fee
      const lpShare = totalFeeUsdt * (state.platformSettings.feeDistributionLPRewardsPercent / 100);
      const platformShare = totalFeeUsdt * (state.platformSettings.feeDistributionPlatformWalletPercent / 100);
      let pdexBurnShare = totalFeeUsdt * (state.platformSettings.feeDistributionPdexBurnPercent / 100);

      // Handle PDEX burn cap
      if (state.pdexToken.burn_cap_reached) {
        state.platformWallet.balances.USDT += pdexBurnShare; // Redirect to platform wallet
      } else {
        // Simulate buy back PDEX with pdexBurnShare USDT and burn
        const pdexToBurn = pdexBurnShare / state.pdexToken.price_usd;
        state.pdexToken.total_burnt_from_fees += pdexToBurn;
        state.pdexToken.circulating_supply -= pdexToBurn; // Reduce circulating supply
        if (state.pdexToken.total_burnt_from_fees >= state.pdexToken.burn_cap_amount) {
          state.pdexToken.burn_cap_reached = true;
          console.log("PDEX burn cap reached! 1% fee now redirects to platform wallet.");
        }
      }

      state.platformWallet.balances.USDT += platformShare;
      state.appStats.totalRevenueGivenBackToUsers += lpShare; // LPs get this share

      // For LP fees, they are accumulated on the pool and distributed periodically by volume
      if (poolId && state.liquidityPools[poolId]) {
          state.liquidityPools[poolId].feesEarnedLP += lpShare;
      }

      // Update app stats total volume
      state.appStats.totalVolumeUSD += usdValue;

      addRecentActivity(`${user.isBot ? 'Bot ' + user.id.split('_')[1] : 'You'} paid ${formatUSD(totalFeeUsdt)} fee for ${type} of ${formatUSD(usdValue)}.`);

      return true;
    }

    /**
     * Calculates the current total USD value of a user's wallet.
     * @param {string} userId
     * @returns {number}
     */
    function calculateUserTotalUsdValue(userId) {
      let total = 0;
      const user = state.users[userId];
      if (!user) return 0;

      for (const tokenTicker in user.balances) {
        total += calculateTokenUSDValue(tokenTicker, user.balances[tokenTicker]);
      }
      return total;
    }

    /**
     * Calculates APR for a farming pool.
     * APR = (Annualized Rewards / Total Staked Value) * 100
     * Annualized Rewards = (Total Reward Amount / Pool Duration in Seconds) * (Seconds in a Year)
     * @param {string} poolId
     * @returns {number} APR percentage
     */
    function calculateFarmingAPR(poolId) {
      const pool = state.farmingPools[poolId];
      if (!pool || pool.totalStakedAmount === 0 || pool.durationSeconds === 0 || pool.rewardRatePerSecond === 0) return 0;

      const totalStakedUsd = calculateTokenUSDValue(pool.stakedToken.ticker, pool.totalStakedAmount);
      if (totalStakedUsd === 0) return 0;

      const annualRewardsUsd = calculateTokenUSDValue(pool.rewardToken.ticker, pool.rewardRatePerSecond * (365 * 24 * 60 * 60));

      return (annualRewardsUsd / totalStakedUsd) * 100;
    }

    /**
     * Calculates APR for a liquidity pool.
     * APR = (Annualized Fees Earned / TVL) * 100
     * Annualized Fees Earned = (Pool's Volume * LP Fee Share) * Annualization Factor
     * @param {string} poolId
     * @returns {number} APR percentage
     */
    function calculateLiquidityAPR(poolId) {
      const pool = state.liquidityPools[poolId];
      if (!pool || pool.volumeUSD === 0) return 0;

      const tvlUsd = calculateTokenUSDValue(pool.tokenA.ticker, pool.balanceA) + calculateTokenUSDValue(pool.tokenB.ticker, pool.balanceB);
      if (tvlUsd === 0) return 0;

      // Assuming pool.volumeUSD is daily volume for simplicity in this simulation
      const feesToLPsFromVolume = pool.volumeUSD * (state.platformSettings.feeDistributionLPRewardsPercent / 100);
      const annualizedFees = feesToLPsFromVolume * 365; // Annualize daily volume fees

      return (annualizedFees / tvlUsd) * 100;
    }

    // --- Data Initialization ---

    function initializeTokens() {
      // Real-time prices as of July 19, 2025 (approximate)
      state.tokens = {
        USDT: { ticker: 'USDT', name: 'Tether', total_supply: Infinity, circulating_supply: Infinity, decimals: 6, price_usd: 1, is_base_asset: true, is_stablecoin: true, market_cap_usd: Infinity },
        USDC: { ticker: 'USDC', name: 'USD Coin', total_supply: Infinity, circulating_supply: Infinity, decimals: 6, price_usd: 1, is_base_asset: true, is_stablecoin: true, market_cap_usd: Infinity },
        BTC: { ticker: 'BTC', name: 'Bitcoin', total_supply: Infinity, circulating_supply: Infinity, decimals: 8, price_usd: 118031.60, is_base_asset: true, is_stablecoin: false, market_cap_usd: Infinity },
        ETH: { ticker: 'ETH', name: 'Ethereum', total_supply: Infinity, circulating_supply: Infinity, decimals: 18, price_usd: 3579.08, is_base_asset: true, is_stablecoin: false, market_cap_usd: Infinity },
        AVAX: { ticker: 'AVAX', name: 'Avalanche', total_supply: Infinity, circulating_supply: Infinity, decimals: 18, price_usd: 23.50, is_base_asset: true, is_stablecoin: false, market_cap_usd: Infinity },
        SOL: { ticker: 'SOL', name: 'Solana', total_supply: Infinity, circulating_supply: Infinity, decimals: 9, price_usd: 177.21, is_base_asset: true, is_stablecoin: false, market_cap_usd: Infinity },
        PDEX: state.pdexToken, // PDEX token data is already in state.pdexToken
      };
      // Update PDEX market cap
      state.tokens.PDEX.market_cap_usd = state.tokens.PDEX.circulating_supply * state.tokens.PDEX.price_usd;
    }

    function initializeLiquidityPools() {
      const initialPoolLiquidityUsd = 10000; // $10,000 equivalent per side

      // Initial PDEX/USDT pool
      const pdexInitialLiquidityPDEX = initialPoolLiquidityUsd / state.pdexToken.price_usd;
      state.liquidityPools['PDEX-USDT'] = {
        id: 'PDEX-USDT',
        tokenA: state.tokens.PDEX,
        tokenB: state.tokens.USDT,
        balanceA: pdexInitialLiquidityPDEX,
        balanceB: initialPoolLiquidityUsd,
        k: pdexInitialLiquidityPDEX * initialPoolLiquidityUsd,
        lpTokenSupply: Math.sqrt(pdexInitialLiquidityPDEX * initialPoolLiquidityUsd),
        feesEarnedLP: 0,
        incentivesAdded: {},
        type: 'Volatile',
        volumeUSD: 0,
      };

      // Other base asset pools ($10,000 equivalent per side)
      state.liquidityPools['BTC-USDT'] = {
        id: 'BTC-USDT',
        tokenA: state.tokens.BTC,
        tokenB: state.tokens.USDT,
        balanceA: initialPoolLiquidityUsd / state.tokens.BTC.price_usd,
        balanceB: initialPoolLiquidityUsd,
        k: (initialPoolLiquidityUsd / state.tokens.BTC.price_usd) * initialPoolLiquidityUsd,
        lpTokenSupply: Math.sqrt((initialPoolLiquidityUsd / state.tokens.BTC.price_usd) * initialPoolLiquidityUsd),
        feesEarnedLP: 0,
        incentivesAdded: {},
        type: 'Volatile',
        volumeUSD: 0,
      };
      state.liquidityPools['ETH-USDT'] = {
        id: 'ETH-USDT',
        tokenA: state.tokens.ETH,
        tokenB: state.tokens.USDT,
        balanceA: initialPoolLiquidityUsd / state.tokens.ETH.price_usd,
        balanceB: initialPoolLiquidityUsd,
        k: (initialPoolLiquidityUsd / state.tokens.ETH.price_usd) * initialPoolLiquidityUsd,
        lpTokenSupply: Math.sqrt((initialPoolLiquidityUsd / state.tokens.ETH.price_usd) * initialPoolLiquidityUsd),
        feesEarnedLP: 0,
        incentivesAdded: {},
        type: 'Volatile',
        volumeUSD: 0,
      };
      state.liquidityPools['USDC-USDT'] = {
        id: 'USDC-USDT',
        tokenA: state.tokens.USDC,
        tokenB: state.tokens.USDT,
        balanceA: initialPoolLiquidityUsd / state.tokens.USDC.price_usd,
        balanceB: initialPoolLiquidityUsd,
        k: (initialPoolLiquidityUsd / state.tokens.USDC.price_usd) * initialPoolLiquidityUsd,
        lpTokenSupply: Math.sqrt((initialPoolLiquidityUsd / state.tokens.USDC.price_usd) * initialPoolLiquidityUsd),
        feesEarnedLP: 0,
        incentivesAdded: {},
        type: 'Stable',
        volumeUSD: 0,
      };
      // Add other initial pools as needed...
    }

    function initializeUsersAndBots() {
      const initialUserBalanceUsd = 10000; // $10,000 equivalent for platform owner

      // Platform owner balances
      state.platformWallet.balances.USDT = initialUserBalanceUsd;
      state.platformWallet.balances.BTC = initialUserBalanceUsd / state.tokens.BTC.price_usd;
      state.platformWallet.balances.ETH = initialUserBalanceUsd / state.tokens.ETH.price_usd;
      state.platformWallet.balances.AVAX = initialUserBalanceUsd / state.tokens.AVAX.price_usd;
      state.platformWallet.balances.SOL = initialUserBalanceUsd / state.tokens.SOL.price_usd;
      state.platformWallet.balances.USDC = initialUserBalanceUsd;
      // PDEX is already set from initial allocation

      state.users[state.platformWallet.id] = state.platformWallet;
      state.platformWallet.totalUsdValue = calculateUserTotalUsdValue(state.platformWallet.id);

      // Initialize a few bots
      for (let i = 1; i <= 5; i++) {
        const botId = `bot_${i}`;
        const botInitialUsd = 5000 + Math.random() * 5000; // $5k-$10k equivalent
        state.users[botId] = {
          id: botId,
          isBot: true,
          balances: {
            USDT: botInitialUsd,
            BTC: (botInitialUsd * 0.1) / state.tokens.BTC.price_usd,
            ETH: (botInitialUsd * 0.1) / state.tokens.ETH.price_usd,
            PDEX: (botInitialUsd * 0.1) / state.tokens.PDEX.price_usd,
          },
          liquidityPositions: [],
          farmingStakes: [],
          gameRewardsPending: [],
          totalUsdValue: 0,
          lastBotTradeTime: Date.now() + Math.random() * 10000, // Stagger initial trade times
          lastBotLpTime: Date.now() + Math.random() * 30000, // Stagger initial LP times
          lastBotAppTime: Date.now() + Math.random() * 600000, // Stagger initial app times
          lastBotBuildTime: Date.now() + Math.random() * 3600000, // Stagger initial build times
          lastBotFarmingTime: Date.now() + Math.random() * 30000,
          lastBotPresaleBuyTime: Date.now() + Math.random() * 5000,
        };
        state.users[botId].totalUsdValue = calculateUserTotalUsdValue(botId);
      }
    }

    // --- Page Rendering Functions ---

    const mainContentDiv = document.getElementById('mainContent');

    function renderHomePage() {
      mainContentDiv.innerHTML = `
        <div class="p-8 bg-gray-800 rounded-xl shadow-2xl glow-border">
          <h2 class="text-4xl font-bold font-poppins text-center mb-10 text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-500">Platform Overview</h2>

          <div class="grid grid-cols-1 md:grid-cols-3 gap-8 mb-12">
            <div class="bg-gray-900 p-6 rounded-xl text-center glow-border-subtle">
              <p class="text-lg text-gray-400">Total Revenue</p>
              <p id="statTotalRevenue" class="text-4xl font-bold text-teal-400 mt-2">${formatUSD(state.appStats.totalRevenue)}</p>
            </div>
            <div class="bg-gray-900 p-6 rounded-xl text-center glow-border-subtle">
              <p class="text-lg text-gray-400">Revenue to Users</p>
              <p id="statRevenueToUsers" class="text-4xl font-bold text-purple-400 mt-2">${formatUSD(state.appStats.totalRevenueGivenBackToUsers)}</p>
            </div>
            <div class="bg-gray-900 p-6 rounded-xl text-center glow-border-subtle">
              <p class="text-lg text-gray-400">Total Volume (24h)</p>
              <p id="statTotalVolume" class="text-4xl font-bold text-blue-400 mt-2">${formatUSD(state.appStats.totalVolumeUSD)}</p>
            </div>
          </div>

          <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
            <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle">
              <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Top 3 Earners</h3>
              <ul id="topEarnersList" class="space-y-3">
                <!-- Dynamically populated -->
              </ul>
            </div>
            <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle">
              <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Top 3 Tokens by MC</h3>
              <ul id="topTokensList" class="space-y-3">
                <!-- Dynamically populated -->
              </ul>
            </div>
          </div>

          <div class="mt-8 bg-gray-900 p-6 rounded-xl text-center glow-border-subtle">
              <p class="text-lg text-gray-400">Users Online</p>
              <p id="statUsersOnline" class="text-3xl font-bold text-green-400 mt-2">${state.appStats.totalUsersOnline.toLocaleString()}</p>
          </div>

          <div class="mt-8 bg-gray-900 p-6 rounded-xl glow-border-subtle">
              <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Recent Platform Activity</h3>
              <ul id="recentActivityList" class="space-y-3 text-sm text-gray-300 max-h-48 overflow-y-auto">
                  <!-- Dynamically populated -->
              </ul>
          </div>
        </div>
      `;
      updateHomePageStats();
    }

    function updateHomePageStats() {
      document.getElementById('statTotalRevenue').textContent = formatUSD(state.appStats.totalRevenue);
      document.getElementById('statRevenueToUsers').textContent = formatUSD(state.appStats.totalRevenueGivenBackToUsers);
      document.getElementById('statTotalVolume').textContent = formatUSD(state.appStats.totalVolumeUSD);
      document.getElementById('statUsersOnline').textContent = state.appStats.totalUsersOnline.toLocaleString();

      // Update Top Earners (simplified for now, just using totalUsdValue from users)
      const sortedEarners = Object.values(state.users)
        .sort((a, b) => b.totalUsdValue - a.totalUsdValue)
        .slice(0, 3);
      const topEarnersList = document.getElementById('topEarnersList');
      topEarnersList.innerHTML = sortedEarners.map(user => `
        <li class="flex justify-between items-center text-lg">
          <span>${user.id.startsWith('bot_') ? 'Bot ' + user.id.split('_')[1] : 'You'}</span>
          <span class="text-teal-300">${formatUSD(user.totalUsdValue)}</span>
        </li>
      `).join('');

      // Update Top Tokens by MC
      const sortedTokens = Object.values(state.tokens)
        .filter(token => token.market_cap_usd !== Infinity && token.market_cap_usd > 0)
        .sort((a, b) => b.market_cap_usd - a.market_cap_usd)
        .slice(0, 3);
      const topTokensList = document.getElementById('topTokensList');
      topTokensList.innerHTML = sortedTokens.map(token => `
        <li class="flex justify-between items-center text-lg">
          <span>${token.ticker}</span>
          <span class="text-blue-300">${formatUSD(token.price_usd)}</span>
          <span class="text-gray-400">${formatUSD(token.market_cap_usd)} MC</span>
        </li>
      `).join('');

      // Update Recent Activity
      const recentActivityList = document.getElementById('recentActivityList');
      recentActivityList.innerHTML = state.appStats.recentActivity.map(activity => `
          <li>[${new Date(activity.timestamp).toLocaleTimeString()}] ${activity.message}</li>
      `).reverse().join(''); // Show most recent first
    }

    function addRecentActivity(message) {
        state.appStats.recentActivity.push({
            timestamp: Date.now(),
            message: message
        });
        if (state.appStats.recentActivity.length > 10) { // Keep last 10 activities
            state.appStats.recentActivity.shift();
        }
    }


    function renderDexTradePage() {
      // Only show tokens that have been listed on DEX
      const listedTokens = Object.values(state.tokens).filter(t => t.launch_details?.status === 'Listed on DEX' || t.is_base_asset);
      const tokenOptions = listedTokens.map(t => `<option value="${t.ticker}">${t.ticker}</option>`).join('');

      mainContentDiv.innerHTML = `
        <div class="p-8 bg-gray-800 rounded-xl shadow-2xl glow-border">
          <h2 class="text-4xl font-bold font-poppins text-center mb-10 text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-500">DEX Trade</h2>

          <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- Swap Module -->
            <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle">
              <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Swap Tokens</h3>
              <div class="space-y-6">
                <div>
                  <label for="swapFromToken" class="block text-gray-400 text-sm mb-2">You Pay</label>
                  <div class="flex items-center space-x-2">
                    <input type="number" id="swapFromAmount" placeholder="0.0" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400 focus:ring focus:ring-blue-400 focus:ring-opacity-50 transition-all duration-200">
                    <select id="swapFromToken" class="p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400 focus:ring focus:ring-blue-400 focus:ring-opacity-50 transition-all duration-200">
                      ${tokenOptions}
                    </select>
                  </div>
                  <p class="text-gray-500 text-sm mt-1">Balance: <span id="swapFromBalance">0.0</span></p>
                </div>

                <div class="flex justify-center">
                  <button id="swapDirectionBtn" class="p-2 rounded-full bg-gray-700 text-white hover:bg-gray-600 transition-colors duration-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m-4 4H4m0 0l4 4m-4-4l4-4"></path></svg>
                  </button>
                </div>

                <div>
                  <label for="swapToToken" class="block text-gray-400 text-sm mb-2">You Receive</label>
                  <div class="flex items-center space-x-2">
                    <input type="number" id="swapToAmount" placeholder="0.0" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400 focus:ring focus:ring-blue-400 focus:ring-opacity-50 transition-all duration-200" readonly>
                    <select id="swapToToken" class="p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400 focus:ring focus:ring-blue-400 focus:ring-opacity-50 transition-all duration-200">
                      ${tokenOptions}
                    </select>
                  </div>
                  <p class="text-gray-500 text-sm mt-1">Balance: <span id="swapToBalance">0.0</span></p>
                </div>

                <div class="text-sm text-gray-400">
                  <p>Estimated Slippage: <span id="slippageDisplay" class="text-yellow-400">0.00%</span></p>
                  <p>Pool: <span id="swapPoolDisplay">N/A</span></p>
                </div>

                <div id="swapRouteAnimation" class="swap-route-animation hidden">
                    <div class="swap-route-node">1</div>
                    <div class="swap-route-node">2</div>
                    <div class="swap-route-node">3</div>
                </div>

                <button id="swapBtn" class="glow-button w-full bg-gradient-to-r from-blue-500 to-purple-600 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:from-blue-600 hover:to-purple-700 transition-all duration-300">Swap</button>
              </div>
            </div>

            <!-- Token Info & Chart -->
            <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle">
              <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Selected Token Info</h3>
              <div id="tokenInfoDisplay" class="space-y-4">
                <p class="text-gray-400">Select a token to view its details.</p>
                <!-- Dynamic content for selected token -->
              </div>
              <div class="mt-6">
                <h4 class="text-xl font-semibold text-white mb-2">Price Chart (Conceptual)</h4>
                <div class="bg-gray-700 h-48 rounded-lg flex items-center justify-center text-gray-500">
                  <p>Chart data would be displayed here.</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
      attachDexTradeListeners();
    }

    function attachDexTradeListeners() {
      const swapFromAmountInput = document.getElementById('swapFromAmount');
      const swapFromTokenSelect = document.getElementById('swapFromToken');
      const swapToTokenSelect = document.getElementById('swapToToken');
      const swapDirectionBtn = document.getElementById('swapDirectionBtn');
      const swapBtn = document.getElementById('swapBtn');
      const swapFromBalanceSpan = document.getElementById('swapFromBalance');
      const swapToBalanceSpan = document.getElementById('swapToBalance');
      const slippageDisplay = document.getElementById('slippageDisplay');
      const swapPoolDisplay = document.getElementById('swapPoolDisplay');
      const swapToAmountInput = document.getElementById('swapToAmount');
      const tokenInfoDisplay = document.getElementById('tokenInfoDisplay');
      const swapRouteAnimation = document.getElementById('swapRouteAnimation');

      let selectedFromToken = swapFromTokenSelect.value;
      let selectedToToken = swapToTokenSelect.value;

      const updateBalances = () => {
        swapFromBalanceSpan.textContent = formatTokenAmount(state.users.platform_owner.balances[selectedFromToken] || 0, state.tokens[selectedFromToken]?.decimals || 2);
        swapToBalanceSpan.textContent = formatTokenAmount(state.users.platform_owner.balances[selectedToToken] || 0, state.tokens[selectedToToken]?.decimals || 2);
      };

      const updateSwapCalculation = () => {
        const fromAmount = parseFloat(swapFromAmountInput.value);
        if (isNaN(fromAmount) || fromAmount <= 0) {
          swapToAmountInput.value = '';
          slippageDisplay.textContent = '0.00%';
          slippageDisplay.className = 'text-yellow-400';
          swapPoolDisplay.textContent = 'N/A';
          tokenInfoDisplay.innerHTML = '<p class="text-gray-400">Select a token to view its details.</p>';
          return;
        }

        const poolId = `${selectedFromToken}-${selectedToToken}`;
        const reversePoolId = `${selectedToToken}-${selectedFromToken}`;
        let pool = state.liquidityPools[poolId] || state.liquidityPools[reversePoolId];

        if (!pool) {
          swapToAmountInput.value = '';
          slippageDisplay.textContent = 'No Pool';
          slippageDisplay.className = 'text-red-400';
          swapPoolDisplay.textContent = 'No Pool';
          tokenInfoDisplay.innerHTML = `<p class="text-red-400">No liquidity pool found for ${selectedFromToken}/${selectedToToken}.</p>`;
          return;
        }

        let inputReserve, outputReserve;
        let isReversed = false;
        if (pool.tokenA.ticker === selectedFromToken) {
          inputReserve = pool.balanceA;
          outputReserve = pool.balanceB;
        } else {
          inputReserve = pool.balanceB;
          outputReserve = pool.balanceA;
          isReversed = true;
        }

        const { outputAmount, slippage } = calculateSwapOutput(fromAmount, inputReserve, outputReserve);
        swapToAmountInput.value = formatTokenAmount(outputAmount, state.tokens[selectedToToken]?.decimals || 4);
        slippageDisplay.textContent = `${slippage.toFixed(2)}%`;
        slippageDisplay.className = slippage < 0.5 ? 'text-green-400' : slippage < 2 ? 'text-yellow-400' : 'text-red-400';
        swapPoolDisplay.textContent = pool.id;

        // Update token info display
        const displayToken = state.tokens[selectedToToken];
        const initialPrice = displayToken.launch_details ? displayToken.launch_details.initial_price_usd : displayToken.price_usd;
        const priceChange = ((displayToken.price_usd - initialPrice) / initialPrice) * 100;
        const priceChangeClass = priceChange >= 0 ? 'text-green-400' : 'text-red-400';
        const priceChangeSign = priceChange >= 0 ? '+' : '';

        const devTeamHoldings = displayToken.launch_details ?
            `<p class="text-gray-300">Dev/Team Holdings: <span class="text-purple-400">${formatTokenAmount(displayToken.launch_details.team_wallet_balance, displayToken.decimals)} ${displayToken.ticker}</span> (${(displayToken.launch_details.team_wallet_balance / displayToken.total_supply * 100).toFixed(2)}%)</p>` : '';

        const buildBookHtml = displayToken.launch_details && displayToken.launch_details.build_log && displayToken.launch_details.build_log.length > 0 ? `
            <h4 class="text-xl font-semibold text-white mt-6 mb-2">Build Book</h4>
            <ul class="space-y-1 text-sm text-gray-300 max-h-32 overflow-y-auto bg-gray-800 p-2 rounded-md">
                ${displayToken.launch_details.build_log.map(log => `<li>[${new Date(log.timestamp).toLocaleTimeString()}] ${log.message}</li>`).reverse().join('')}
            </ul>
        ` : '';


        tokenInfoDisplay.innerHTML = `
          <p class="text-lg text-white font-semibold">${displayToken.name} (${displayToken.ticker})</p>
          <p class="text-gray-300">Price: <span class="text-blue-400">${formatUSD(displayToken.price_usd)}</span></p>
          <p class="text-gray-300">Market Cap: <span class="text-blue-400">${formatUSD(displayToken.market_cap_usd)}</span></p>
          <p class="text-gray-300">Liquidity: <span class="text-blue-400">${formatTokenAmount(pool.balanceA, pool.tokenA.decimals)} ${pool.tokenA.ticker} / ${formatTokenAmount(pool.balanceB, pool.tokenB.decimals)} ${pool.tokenB.ticker}</span></p>
          <p class="text-gray-300">Volume (24h): <span class="text-blue-400">${formatUSD(pool.volumeUSD)}</span></p>
          <p class="text-gray-300">Holders: <span class="text-blue-400">${Object.keys(state.users).length} (Simulated)</span></p>
          <p class="text-gray-300">Price Change (from initial): <span class="${priceChangeClass}">${priceChangeSign}${priceChange.toFixed(2)}%</span></p>
          ${devTeamHoldings}
          ${buildBookHtml}
        `;
      };

      const animateSwapRoute = (fromToken, toToken) => {
          swapRouteAnimation.innerHTML = `
              <div class="swap-route-node">${fromToken}</div>
              <div class="swap-route-node active">DEX</div>
              <div class="swap-route-node">${toToken}</div>
          `;
          swapRouteAnimation.classList.remove('hidden');
          setTimeout(() => {
              swapRouteAnimation.classList.add('hidden'); // Hide after animation
          }, 3000); // Match animation duration
      };

      swapFromAmountInput.addEventListener('input', updateSwapCalculation);
      swapFromTokenSelect.addEventListener('change', (e) => {
        selectedFromToken = e.target.value;
        updateBalances();
        updateSwapCalculation();
      });
      swapToTokenSelect.addEventListener('change', (e) => {
        selectedToToken = e.target.value;
        updateBalances();
        updateSwapCalculation();
      });

      swapDirectionBtn.addEventListener('click', () => {
        [swapFromTokenSelect.value, swapToTokenSelect.value] = [swapToTokenSelect.value, swapFromTokenSelect.value];
        selectedFromToken = swapFromTokenSelect.value;
        selectedToToken = swapToTokenSelect.value;
        updateBalances();
        updateSwapCalculation();
      });

      swapBtn.addEventListener('click', async () => {
        const fromAmount = parseFloat(swapFromAmountInput.value);
        if (isNaN(fromAmount) || fromAmount <= 0) {
          showMessageBox('Please enter a valid amount to swap.', true);
          return;
        }

        const fromToken = selectedFromToken;
        const toToken = selectedToToken;
        const user = state.users.platform_owner;

        if (user.balances[fromToken] < fromAmount) {
          showMessageBox(`Insufficient ${fromToken} balance.`, true);
          return;
        }

        const poolId = `${fromToken}-${toToken}`;
        const reversePoolId = `${toToken}-${fromToken}`;
        let pool = state.liquidityPools[poolId] || state.liquidityPools[reversePoolId];

        if (!pool) {
          showMessageBox(`No liquidity pool found for ${fromToken}/${toToken}.`, true);
          return;
        }

        let inputReserve, outputReserve;
        if (pool.tokenA.ticker === fromToken) {
          inputReserve = pool.balanceA;
          outputReserve = pool.balanceB;
        } else {
          inputReserve = pool.balanceB;
          outputReserve = pool.balanceA;
        }

        const { outputAmount, slippage } = calculateSwapOutput(fromAmount, inputReserve, outputReserve);
        if (outputAmount <= 0) {
          showMessageBox('Swap amount too small or pool depleted.', true);
          return;
        }

        const confirmSwap = await showConfirmationModal(
          `Confirm Swap: Pay ${formatTokenAmount(fromAmount, state.tokens[fromToken].decimals)} ${fromToken} to receive ${formatTokenAmount(outputAmount, state.tokens[toToken].decimals)} ${toToken}? Slippage: ${slippage.toFixed(2)}%.`
        );

        if (confirmSwap) {
          const swapUsdValue = calculateTokenUSDValue(fromToken, fromAmount);
          if (!applyTransactionFee(user.id, swapUsdValue, 'Swap', pool.id)) { // Fee is now applied based on USD value of input
            // applyTransactionFee already shows message
            return;
          }

          // Perform the swap
          user.balances[fromToken] -= fromAmount;
          user.balances[toToken] = (user.balances[toToken] || 0) + outputAmount;

          if (pool.tokenA.ticker === fromToken) {
            pool.balanceA += fromAmount;
            pool.balanceB -= outputAmount;
          } else {
            pool.balanceB += fromAmount;
            pool.balanceA -= outputAmount;
          }

          // Update token prices based on new pool ratio
          state.tokens[pool.tokenA.ticker].price_usd = pool.balanceB / pool.balanceA;
          state.tokens[pool.tokenB.ticker].price_usd = pool.balanceA / pool.balanceB; // Inverse price

          // Update market caps
          state.tokens[pool.tokenA.ticker].market_cap_usd = state.tokens[pool.tokenA.ticker].circulating_supply * state.tokens[pool.tokenA.ticker].price_usd;
          state.tokens[pool.tokenB.ticker].market_cap_usd = state.tokens[pool.tokenB.ticker].circulating_supply * state.tokens[pool.tokenB.ticker].price_usd;


          // Creator fee for bot-launched tokens
          const creatorToken = state.tokens[toToken];
          if (creatorToken.creator_id && creatorToken.creator_id.startsWith('bot_')) {
              const creatorBot = state.users[creatorToken.creator_id];
              const creatorFeeAmount = outputAmount * 0.01; // 1% of received token
              creatorBot.balances[toToken] = (creatorBot.balances[toToken] || 0) + creatorFeeAmount;
              addRecentActivity(`${creatorBot.id} earned ${formatTokenAmount(creatorFeeAmount, creatorToken.decimals)} ${toToken} creator fee from swap.`);
          }

          showMessageBox(`Successfully swapped ${formatTokenAmount(fromAmount, state.tokens[fromToken].decimals)} ${fromToken} for ${formatTokenAmount(outputAmount, state.tokens[toToken].decimals)} ${toToken}.`);
          addRecentActivity(`You swapped ${formatTokenAmount(fromAmount, state.tokens[fromToken].decimals)} ${fromToken} for ${formatTokenAmount(outputAmount, state.tokens[toToken].decimals)} ${toToken}.`);
          animateSwapRoute(fromToken, toToken);
          updateBalances();
          updateSwapCalculation(); // Recalculate after swap
          // No redirect here, stay on DEX Trade page
        }
      });

      // Initial update
      updateBalances();
      updateSwapCalculation();
    }

    function renderLiquidityPage(selectedPoolId = null) {
        mainContentDiv.innerHTML = `
            <div class="p-8 bg-gray-800 rounded-xl shadow-2xl glow-border">
                <h2 class="text-4xl font-bold font-poppins text-center mb-10 text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-500">Liquidity Pools</h2>

                <div class="mb-8">
                    <button id="createPoolBtn" class="glow-button bg-gradient-to-r from-green-500 to-teal-500 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:from-green-600 hover:to-teal-600 transition-all duration-300">Create New Pool</button>
                </div>

                <div id="createPoolForm" class="hidden bg-gray-900 p-6 rounded-xl glow-border-subtle mb-8">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Create New Liquidity Pool</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="newPoolTokenA" class="block text-gray-400 text-sm mb-2">Token A</label>
                            <select id="newPoolTokenA" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400"></select>
                        </div>
                        <div>
                            <label for="newPoolTokenB" class="block text-gray-400 text-sm mb-2">Token B</label>
                            <select id="newPoolTokenB" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400"></select>
                        </div>
                        <div>
                            <label for="newPoolAmountA" class="block text-gray-400 text-sm mb-2">Amount A</label>
                            <input type="number" id="newPoolAmountA" placeholder="0.0" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div>
                            <label for="newPoolAmountB" class="block text-gray-400 text-sm mb-2">Amount B</label>
                            <input type="number" id="newPoolAmountB" placeholder="0.0" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div class="md:col-span-2">
                            <label for="newPoolType" class="block text-gray-400 text-sm mb-2">Pool Type</label>
                            <select id="newPoolType" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                                <option value="Volatile">Volatile</option>
                                <option value="Stable">Stable</option>
                            </select>
                        </div>
                    </div>
                    <button id="submitCreatePoolBtn" class="glow-button w-full bg-gradient-to-r from-blue-500 to-purple-600 text-white px-6 py-3 rounded-lg font-semibold text-lg mt-6">Confirm Create Pool</button>
                </div>

                <h3 class="text-3xl font-semibold font-poppins mb-6 text-white text-center">Stable Pools</h3>
                <div id="stablePoolsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-10">
                    <!-- Stable pools will be rendered here -->
                </div>

                <h3 class="text-3xl font-semibold font-poppins mb-6 text-white text-center">Volatile Pools</h3>
                <div id="volatilePoolsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <!-- Volatile pools will be rendered here -->
                </div>
            </div>
        `;

        const createPoolBtn = document.getElementById('createPoolBtn');
        const createPoolForm = document.getElementById('createPoolForm');
        const submitCreatePoolBtn = document.getElementById('submitCreatePoolBtn');
        const newPoolTokenASelect = document.getElementById('newPoolTokenA');
        const newPoolTokenBSelect = document.getElementById('newPoolTokenB');

        const populateTokenSelects = () => {
            const allTokens = Object.values(state.tokens).map(t => `<option value="${t.ticker}">${t.ticker}</option>`).join('');
            newPoolTokenASelect.innerHTML = allTokens;
            newPoolTokenBSelect.innerHTML = allTokens;
        };
        populateTokenSelects();

        createPoolBtn.addEventListener('click', () => {
            createPoolForm.classList.toggle('hidden');
        });

        submitCreatePoolBtn.addEventListener('click', async () => {
            const tokenATicker = newPoolTokenASelect.value;
            const tokenBTicker = newPoolTokenBSelect.value;
            const amountA = parseFloat(document.getElementById('newPoolAmountA').value);
            const amountB = parseFloat(document.getElementById('newPoolAmountB').value);
            const poolType = document.getElementById('newPoolType').value;

            if (!tokenATicker || !tokenBTicker || isNaN(amountA) || amountA <= 0 || isNaN(amountB) || amountB <= 0 || tokenATicker === tokenBTicker) {
                showMessageBox('Please select two different tokens and enter valid positive amounts.', true);
                return;
            }

            const user = state.users.platform_owner;
            if (user.balances[tokenATicker] < amountA || user.balances[tokenBTicker] < amountB) {
                showMessageBox('Insufficient balance for one or both tokens.', true);
                return;
            }

            const poolId = `${tokenATicker}-${tokenBTicker}`;
            if (state.liquidityPools[poolId] || state.liquidityPools[`${tokenBTicker}-${tokenATicker}`]) {
                showMessageBox('A pool for these tokens already exists.', true);
                return;
            }

            const confirmCreate = await showConfirmationModal(`Create new pool ${poolId} with ${formatTokenAmount(amountA)} ${tokenATicker} and ${formatTokenAmount(amountB)} ${tokenBTicker}?`);
            if (confirmCreate) {
                const usdValue = calculateTokenUSDValue(tokenATicker, amountA) + calculateTokenUSDValue(tokenBTicker, amountB);
                if (!applyTransactionFee(user.id, usdValue, 'CreateLiquidityPool', null)) {
                    // applyTransactionFee already shows message
                    return;
                }

                user.balances[tokenATicker] -= amountA;
                user.balances[tokenBTicker] -= amountB;

                state.liquidityPools[poolId] = {
                    id: poolId,
                    tokenA: state.tokens[tokenATicker],
                    tokenB: state.tokens[tokenBTicker],
                    balanceA: amountA,
                    balanceB: amountB,
                    k: amountA * amountB,
                    lpTokenSupply: Math.sqrt(amountA * amountB),
                    feesEarnedLP: 0,
                    incentivesAdded: {},
                    type: poolType,
                    volumeUSD: 0,
                };
                showMessageBox(`Successfully created new liquidity pool: ${poolId}.`);
                addRecentActivity(`You created a new liquidity pool: ${poolId}.`);
                renderLiquidityPage(); // Re-render to show new pool
            }
        });

        updateLiquidityPoolsDisplay();
        if (selectedPoolId) {
            // If a specific pool was selected, open its sub-page
            showPoolSubPage(selectedPoolId);
        }
    }

    function updateLiquidityPoolsDisplay() {
        const stableList = document.getElementById('stablePoolsList');
        const volatileList = document.getElementById('volatilePoolsList');
        stableList.innerHTML = '';
        volatileList.innerHTML = '';

        Object.values(state.liquidityPools).forEach(pool => {
            const tvlUsd = calculateTokenUSDValue(pool.tokenA.ticker, pool.balanceA) + calculateTokenUSDValue(pool.tokenB.ticker, pool.balanceB);
            const apr = calculateLiquidityAPR(pool.id);

            const poolCard = document.createElement('div');
            poolCard.className = `clickable-pool-card bg-gray-900 p-6 rounded-xl shadow-lg glow-border-subtle relative overflow-hidden`;
            poolCard.innerHTML = `
                <div class="moving-glow-effect absolute inset-0"></div>
                <h3 class="text-xl font-semibold text-white mb-2">${pool.id}</h3>
                <p class="text-gray-400">TVL: <span class="text-teal-300">${formatUSD(tvlUsd)}</span></p>
                <p class="text-gray-400">Volume (24h): <span class="text-blue-300">${formatUSD(pool.volumeUSD)}</span></p>
                <p class="text-gray-400">APR: <span class="text-green-400">${apr.toFixed(2)}%</span></p>
                <p class="text-gray-400">Fees Earned: <span class="text-purple-300">${formatUSD(pool.feesEarnedLP)}</span></p>
                ${Object.keys(pool.incentivesAdded).length > 0 ? `<p class="text-yellow-400 mt-2">Incentives Available!</p>` : ''}
            `;
            poolCard.addEventListener('click', () => showPoolSubPage(pool.id));

            if (pool.type === 'Stable') {
                stableList.appendChild(poolCard);
            } else {
                volatileList.appendChild(poolCard);
            }
        });
    }

    function showPoolSubPage(poolId) {
        const pool = state.liquidityPools[poolId];
        if (!pool) {
            showMessageBox('Pool not found!', true);
            renderLiquidityPage();
            return;
        }

        const tvlUsd = calculateTokenUSDValue(pool.tokenA.ticker, pool.balanceA) + calculateTokenUSDValue(pool.tokenB.ticker, pool.balanceB);
        const apr = calculateLiquidityAPR(pool.id);

        const incentivesHtml = Object.keys(pool.incentivesAdded).length > 0 ?
            `<h4 class="text-xl font-semibold text-white mt-6 mb-2">Incentives</h4>
             <ul class="space-y-2">
                 ${Object.entries(pool.incentivesAdded).map(([token, amount]) => `
                     <li>${formatTokenAmount(amount, state.tokens[token]?.decimals || 2)} ${token}</li>
                 `).join('')}
             </ul>` : '';

        mainContentDiv.innerHTML = `
            <div class="p-8 bg-gray-800 rounded-xl shadow-2xl glow-border">
                <button id="backToLiquidityBtn" class="glow-button bg-gray-700 text-white px-4 py-2 rounded-lg mb-6">← Back to Pools</button>
                <h2 class="text-4xl font-bold font-poppins text-center mb-10 text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-500">${pool.id} Pool Details</h2>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle mb-8">
                    <p class="text-gray-400 text-lg">Type: <span class="text-white">${pool.type}</span></p>
                    <p class="text-gray-400 text-lg">TVL: <span class="text-teal-300">${formatUSD(tvlUsd)}</span></p>
                    <p class="text-gray-400 text-lg">Current Reserves: <span class="text-white">${formatTokenAmount(pool.balanceA, pool.tokenA.decimals)} ${pool.tokenA.ticker} / ${formatTokenAmount(pool.balanceB, pool.tokenB.decimals)} ${pool.tokenB.ticker}</span></p>
                    <p class="text-gray-400 text-lg">Volume (24h): <span class="text-blue-300">${formatUSD(pool.volumeUSD)}</span></p>
                    <p class="text-gray-400 text-lg">APR: <span class="text-green-400">${apr.toFixed(2)}%</span></p>
                    <p class="text-gray-400 text-lg">Fees Earned for LPs: <span class="text-purple-300">${formatUSD(pool.feesEarnedLP)}</span></p>
                    ${incentivesHtml}
                </div>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle mb-8">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Manage Your Liquidity</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="addLpAmountA" class="block text-gray-400 text-sm mb-2">Add ${pool.tokenA.ticker} Amount</label>
                            <input type="number" id="addLpAmountA" placeholder="0.0" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                            <p class="text-gray-500 text-sm mt-1">Balance: ${formatTokenAmount(state.users.platform_owner.balances[pool.tokenA.ticker] || 0, state.tokens[pool.tokenA.ticker]?.decimals || 2)} ${pool.tokenA.ticker}</p>
                        </div>
                        <div>
                            <label for="addLpAmountB" class="block text-gray-400 text-sm mb-2">Add ${pool.tokenB.ticker} Amount</label>
                            <input type="number" id="addLpAmountB" placeholder="0.0" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                            <p class="text-gray-500 text-sm mt-1">Balance: ${formatTokenAmount(state.users.platform_owner.balances[pool.tokenB.ticker] || 0, state.tokens[pool.tokenB.ticker]?.decimals || 2)} ${pool.tokenB.ticker}</p>
                        </div>
                        <button id="addLiquidityBtn" class="glow-button w-full bg-gradient-to-r from-blue-500 to-purple-600 text-white px-6 py-3 rounded-lg font-semibold text-lg">Add Liquidity</button>
                    </div>
                    <div class="mt-6 space-y-4">
                        <button id="removeLiquidityBtn" class="glow-button w-full bg-gradient-to-r from-red-500 to-orange-600 text-white px-6 py-3 rounded-lg font-semibold text-lg">Remove Liquidity (Placeholder)</button>
                        <button id="claimLpFeesBtn" class="glow-button w-full bg-gradient-to-r from-green-500 to-teal-500 text-white px-6 py-3 rounded-lg font-semibold text-lg">Claim LP Fees (Placeholder)</button>
                    </div>
                </div>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Add Incentives to Pool</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="incentiveToken" class="block text-gray-400 text-sm mb-2">Incentive Token</label>
                            <select id="incentiveToken" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                                ${Object.values(state.tokens).map(t => `<option value="${t.ticker}">${t.ticker}</option>`).join('')}
                            </select>
                        </div>
                        <div>
                            <label for="incentiveAmount" class="block text-gray-400 text-sm mb-2">Amount</label>
                            <input type="number" id="incentiveAmount" placeholder="0.0" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                            <p class="text-gray-500 text-sm mt-1">Platform Balance: <span id="incentivePlatformBalance"></span></p>
                        </div>
                        <button id="addIncentiveBtn" class="glow-button w-full bg-gradient-to-r from-purple-500 to-pink-600 text-white px-6 py-3 rounded-lg font-semibold text-lg">Add Incentive</button>
                    </div>
                </div>
            </div>
        `;

        document.getElementById('backToLiquidityBtn').addEventListener('click', () => renderLiquidityPage());

        const addLpAmountA = document.getElementById('addLpAmountA');
        const addLpAmountB = document.getElementById('addLpAmountB');
        const addLiquidityBtn = document.getElementById('addLiquidityBtn');
        const removeLiquidityBtn = document.getElementById('removeLiquidityBtn');
        const claimLpFeesBtn = document.getElementById('claimLpFeesBtn');
        const incentiveTokenSelect = document.getElementById('incentiveToken');
        const incentiveAmountInput = document.getElementById('incentiveAmount');
        const addIncentiveBtn = document.getElementById('addIncentiveBtn');
        const incentivePlatformBalanceSpan = document.getElementById('incentivePlatformBalance');

        const updateIncentiveBalance = () => {
            incentivePlatformBalanceSpan.textContent = `${formatTokenAmount(state.platformWallet.balances[incentiveTokenSelect.value] || 0, state.tokens[incentiveTokenSelect.value]?.decimals || 2)} ${incentiveTokenSelect.value}`;
        };
        incentiveTokenSelect.addEventListener('change', updateIncentiveBalance);
        updateIncentiveBalance(); // Initial update

        addLiquidityBtn.addEventListener('click', async () => {
            const amountA = parseFloat(addLpAmountA.value);
            const amountB = parseFloat(addLpAmountB.value);
            if (isNaN(amountA) || amountA <= 0 || isNaN(amountB) || amountB <= 0) {
                showMessageBox('Please enter valid amounts for liquidity.', true);
                return;
            }

            const user = state.users.platform_owner;
            if (user.balances[pool.tokenA.ticker] < amountA || user.balances[pool.tokenB.ticker] < amountB) {
                showMessageBox('Insufficient balance for one or both tokens.', true);
                return;
            }

            const confirmAdd = await showConfirmationModal(`Add ${formatTokenAmount(amountA)} ${pool.tokenA.ticker} and ${formatTokenAmount(amountB)} ${pool.tokenB.ticker} to ${pool.id} pool?`);
            if (confirmAdd) {
                const usdValue = calculateTokenUSDValue(pool.tokenA.ticker, amountA) + calculateTokenUSDValue(pool.tokenB.ticker, amountB);
                if (!applyTransactionFee(user.id, usdValue, 'AddLiquidity', pool.id)) {
                    // applyTransactionFee already shows message
                    return;
                }

                user.balances[pool.tokenA.ticker] -= amountA;
                user.balances[pool.tokenB.ticker] -= amountB;
                pool.balanceA += amountA;
                pool.balanceB += amountB;
                pool.k = pool.balanceA * pool.balanceB; // Update K
                pool.lpTokenSupply += Math.sqrt(amountA * amountB); // Simplified LP token minting

                // Update token prices based on new pool ratio (important for accurate MC)
                state.tokens[pool.tokenA.ticker].price_usd = pool.balanceB / pool.balanceA;
                state.tokens[pool.tokenB.ticker].price_usd = pool.balanceA / pool.balanceB;
                state.tokens[pool.tokenA.ticker].market_cap_usd = state.tokens[pool.tokenA.ticker].circulating_supply * state.tokens[pool.tokenA.ticker].price_usd;
                state.tokens[pool.tokenB.ticker].market_cap_usd = state.tokens[pool.tokenB.ticker].circulating_supply * state.tokens[pool.tokenB.ticker].price_usd;


                showMessageBox(`Successfully added liquidity to ${pool.id}.`);
                addRecentActivity(`You added liquidity to ${pool.id}.`);
                renderLiquidityPage(pool.id); // Re-render sub-page
            }
        });

        removeLiquidityBtn.addEventListener('click', async () => {
            const confirmRemove = await showConfirmationModal(`Remove liquidity from ${pool.id}? (Placeholder: This will remove a small amount for demonstration)`);
            if (confirmRemove) {
                const lpAmountToRemove = pool.lpTokenSupply * 0.01; // Remove 1% of LP tokens for demo
                if (lpAmountToRemove <= 0) {
                    showMessageBox('No liquidity to remove.', true);
                    return;
                }
                const tokenARemoved = pool.balanceA * (lpAmountToRemove / pool.lpTokenSupply);
                const tokenBRemoved = pool.balanceB * (lpAmountToRemove / pool.lpTokenSupply);

                const usdValue = calculateTokenUSDValue(pool.tokenA.ticker, tokenARemoved) + calculateTokenUSDValue(pool.tokenB.ticker, tokenBRemoved);
                if (!applyTransactionFee(state.users.platform_owner.id, usdValue, 'RemoveLiquidity', pool.id)) {
                    // applyTransactionFee already shows message
                    return;
                }

                pool.balanceA -= tokenARemoved;
                pool.balanceB -= tokenBRemoved;
                pool.lpTokenSupply -= lpAmountToRemove;
                state.users.platform_owner.balances[pool.tokenA.ticker] = (state.users.platform_owner.balances[pool.tokenA.ticker] || 0) + tokenARemoved;
                state.users.platform_owner.balances[pool.tokenB.ticker] = (state.users.platform_owner.balances[pool.tokenB.ticker] || 0) + tokenBRemoved;

                // Update token prices based on new pool ratio (important for accurate MC)
                state.tokens[pool.tokenA.ticker].price_usd = pool.balanceB / pool.balanceA;
                state.tokens[pool.tokenB.ticker].price_usd = pool.balanceA / pool.balanceB;
                state.tokens[pool.tokenA.ticker].market_cap_usd = state.tokens[pool.tokenA.ticker].circulating_supply * state.tokens[pool.tokenA.ticker].price_usd;
                state.tokens[pool.tokenB.ticker].market_cap_usd = state.tokens[pool.tokenB.ticker].circulating_supply * state.tokens[pool.tokenB.ticker].price_usd;

                showMessageBox(`Successfully removed liquidity from ${pool.id}.`);
                addRecentActivity(`You removed liquidity from ${pool.id}.`);
                renderLiquidityPage(pool.id);
            }
        });

        claimLpFeesBtn.addEventListener('click', async () => {
            const confirmClaim = await showConfirmationModal(`Claim LP fees from ${pool.id}? (This will claim all accumulated fees)`);
            if (confirmClaim) {
                const feesToClaim = pool.feesEarnedLP;
                if (feesToClaim <= 0) {
                    showMessageBox('No fees to claim.', true);
                    return;
                }
                if (!applyTransactionFee(state.users.platform_owner.id, feesToClaim, 'ClaimLpFees', pool.id)) {
                    // applyTransactionFee already shows message
                    return;
                }
                // For simplicity, claiming LP fees will be in USDT. In a real DEX, it's often a mix of the pool's tokens.
                state.users.platform_owner.balances.USDT += feesToClaim;
                state.platformWallet.revenueTracker.lpRewards += feesToClaim; // Track for platform owner
                pool.feesEarnedLP = 0; // Reset fees for this pool
                showMessageBox(`Successfully claimed ${formatUSD(feesToClaim)} LP fees from ${pool.id}.`);
                addRecentActivity(`You claimed ${formatUSD(feesToClaim)} LP fees from ${pool.id}.`);
                renderLiquidityPage(pool.id);
            }
        });

        addIncentiveBtn.addEventListener('click', async () => {
            const incentiveToken = incentiveTokenSelect.value;
            const incentiveAmount = parseFloat(incentiveAmountInput.value);
            if (isNaN(incentiveAmount) || incentiveAmount <= 0) {
                showMessageBox('Please enter a valid incentive amount.', true);
                return;
            }
            if (state.platformWallet.balances[incentiveToken] < incentiveAmount) {
                showMessageBox(`Insufficient ${incentiveToken} in Platform Wallet.`, true);
                return;
            }

            const confirmIncentive = await showConfirmationModal(`Add ${formatTokenAmount(incentiveAmount, state.tokens[incentiveToken]?.decimals || 2)} ${incentiveToken} as incentive to ${pool.id} pool?`);
            if (confirmIncentive) {
                state.platformWallet.balances[incentiveToken] -= incentiveAmount;
                pool.incentivesAdded[incentiveToken] = (pool.incentivesAdded[incentiveToken] || 0) + incentiveAmount;
                showMessageBox(`Successfully added ${formatTokenAmount(incentiveAmount, state.tokens[incentiveToken]?.decimals || 2)} ${incentiveToken} as incentive to ${pool.id}.`);
                addRecentActivity(`You added ${formatTokenAmount(incentiveAmount, state.tokens[incentiveToken]?.decimals || 2)} ${incentiveToken} as incentive to ${pool.id}.`);
                renderLiquidityPage(pool.id);
            }
        });
    }


    function renderFarmingPage(selectedPoolId = null) {
        mainContentDiv.innerHTML = `
            <div class="p-8 bg-gray-800 rounded-xl shadow-2xl glow-border">
                <h2 class="text-4xl font-bold font-poppins text-center mb-10 text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-500">Farming Pools</h2>

                <div class="mb-8">
                    <button id="createFarmingPoolBtn" class="glow-button bg-gradient-to-r from-green-500 to-teal-500 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:from-green-600 hover:to-teal-600 transition-all duration-300">Create New Farming Pool</button>
                </div>

                <div id="createFarmingPoolForm" class="hidden bg-gray-900 p-6 rounded-xl glow-border-subtle mb-8">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Create New Farming Pool</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="newFarmStakedToken" class="block text-gray-400 text-sm mb-2">Staked Token</label>
                            <select id="newFarmStakedToken" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                                ${Object.values(state.tokens).map(t => `<option value="${t.ticker}">${t.ticker}</option>`).join('')}
                            </select>
                        </div>
                        <div>
                            <label for="newFarmRewardToken" class="block text-gray-400 text-sm mb-2">Reward Token</label>
                            <select id="newFarmRewardToken" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                                ${Object.values(state.tokens).map(t => `<option value="${t.ticker}">${t.ticker}</option>`).join('')}
                            </select>
                        </div>
                        <div class="md:col-span-2">
                            <label for="newFarmRewardAmount" class="block text-gray-400 text-sm mb-2">Total Reward Amount</label>
                            <input type="number" id="newFarmRewardAmount" placeholder="0.0" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                            <p class="text-gray-500 text-sm mt-1">Platform Balance: <span id="newFarmRewardPlatformBalance"></span></p>
                        </div>
                        <div>
                            <label for="newFarmDuration" class="block text-gray-400 text-sm mb-2">Duration</label>
                            <input type="number" id="newFarmDuration" placeholder="e.g., 7" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div>
                            <label for="newFarmDurationUnit" class="block text-gray-400 text-sm mb-2">Duration Unit</label>
                            <select id="newFarmDurationUnit" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                                <option value="minutes">Minutes</option>
                                <option value="hours">Hours</option>
                                <option value="days">Days</option>
                            </select>
                        </div>
                        <div>
                            <label for="newFarmLockup" class="block text-gray-400 text-sm mb-2">Lock-up Duration</label>
                            <input type="number" id="newFarmLockup" placeholder="e.g., 0 (no lock)" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div>
                            <label for="newFarmLockupUnit" class="block text-gray-400 text-sm mb-2">Lock-up Unit</label>
                            <select id="newFarmLockupUnit" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                                <option value="minutes">Minutes</option>
                                <option value="hours">Hours</option>
                                <option value="days">Days</option>
                            </select>
                        </div>
                        <div class="md:col-span-2">
                            <label for="newFarmPoolType" class="block text-gray-400 text-sm mb-2">Pool Type</label>
                            <select id="newFarmPoolType" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                                <option value="Volatile">Volatile</option>
                                <option value="Stable">Stable</option>
                                <option value="Platform">Platform ($PDEX Stake)</option>
                            </select>
                        </div>
                    </div>
                    <button id="submitCreateFarmingPoolBtn" class="glow-button w-full bg-gradient-to-r from-blue-500 to-purple-600 text-white px-6 py-3 rounded-lg font-semibold text-lg mt-6">Confirm Create Farming Pool</button>
                </div>

                <h3 class="text-3xl font-semibold font-poppins mb-6 text-white text-center">Platform Pools</h3>
                <div id="platformFarmingPoolsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-10">
                    <!-- Platform pools will be rendered here -->
                </div>

                <h3 class="text-3xl font-semibold font-poppins mb-6 text-white text-center">Stable Pools</h3>
                <div id="stableFarmingPoolsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-10">
                    <!-- Stable pools will be rendered here -->
                </div>

                <h3 class="text-3xl font-semibold font-poppins mb-6 text-white text-center">Volatile Pools</h3>
                <div id="volatileFarmingPoolsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <!-- Volatile pools will be rendered here -->
                </div>
            </div>
        `;

        const createFarmingPoolBtn = document.getElementById('createFarmingPoolBtn');
        const createFarmingPoolForm = document.getElementById('createFarmingPoolForm');
        const submitCreateFarmingPoolBtn = document.getElementById('submitCreateFarmingPoolBtn');
        const newFarmStakedTokenSelect = document.getElementById('newFarmStakedToken');
        const newFarmRewardTokenSelect = document.getElementById('newFarmRewardToken');
        const newFarmRewardAmountInput = document.getElementById('newFarmRewardAmount');
        const newFarmDurationInput = document.getElementById('newFarmDuration');
        const newFarmDurationUnitSelect = document.getElementById('newFarmDurationUnit');
        const newFarmLockupInput = document.getElementById('newFarmLockup');
        const newFarmLockupUnitSelect = document.getElementById('newFarmLockupUnit');
        const newFarmPoolTypeSelect = document.getElementById('newFarmPoolType');
        const newFarmRewardPlatformBalanceSpan = document.getElementById('newFarmRewardPlatformBalance');

        const updateRewardPlatformBalance = () => {
            newFarmRewardPlatformBalanceSpan.textContent = `${formatTokenAmount(state.platformWallet.balances[newFarmRewardTokenSelect.value] || 0, state.tokens[newFarmRewardTokenSelect.value]?.decimals || 2)} ${newFarmRewardTokenSelect.value}`;
        };
        newFarmRewardTokenSelect.addEventListener('change', updateRewardPlatformBalance);
        updateRewardPlatformBalance(); // Initial update

        createFarmingPoolBtn.addEventListener('click', () => {
            createFarmingPoolForm.classList.toggle('hidden');
        });

        submitCreateFarmingPoolBtn.addEventListener('click', async () => {
            const stakedTokenTicker = newFarmStakedTokenSelect.value;
            const rewardTokenTicker = newFarmRewardTokenSelect.value;
            const rewardAmount = parseFloat(newFarmRewardAmountInput.value);
            const duration = parseFloat(newFarmDurationInput.value);
            const durationUnit = newFarmDurationUnitSelect.value;
            const lockup = parseFloat(newFarmLockupInput.value);
            const lockupUnit = newFarmLockupUnitSelect.value;
            const poolType = newFarmPoolTypeSelect.value;

            if (!stakedTokenTicker || !rewardTokenTicker || isNaN(rewardAmount) || rewardAmount <= 0 || isNaN(duration) || duration <= 0 || isNaN(lockup) || lockup < 0) {
                showMessageBox('Please fill all fields correctly.', true);
                return;
            }
            if (state.platformWallet.balances[rewardTokenTicker] < rewardAmount) {
                showMessageBox(`Insufficient ${rewardTokenTicker} in Platform Wallet to fund rewards.`, true);
                return;
            }

            let durationSeconds = duration;
            if (durationUnit === 'minutes') durationSeconds *= 60;
            else if (durationUnit === 'hours') durationSeconds *= 3600;
            else if (durationUnit === 'days') durationSeconds *= 86400;

            let lockupDurationSeconds = lockup;
            if (lockupUnit === 'minutes') lockupDurationSeconds *= 60;
            else if (lockupUnit === 'hours') lockupDurationSeconds *= 3600;
            else if (lockupUnit === 'days') lockupDurationSeconds *= 86400;

            const poolId = `FARM-${stakedTokenTicker}-${rewardTokenTicker}-${generateUniqueId()}`;

            const confirmCreate = await showConfirmationModal(`Create new farming pool ${poolId} with ${formatTokenAmount(rewardAmount, state.tokens[rewardTokenTicker]?.decimals || 2)} ${rewardTokenTicker} rewards for ${duration} ${durationUnit} and ${lockup} ${lockupUnit} lockup?`);
            if (confirmCreate) {
                state.platformWallet.balances[rewardTokenTicker] -= rewardAmount;
                state.farmingPools[poolId] = {
                    id: poolId,
                    stakedToken: state.tokens[stakedTokenTicker],
                    rewardToken: state.tokens[rewardTokenTicker],
                    totalStakedAmount: 0,
                    rewardRatePerSecond: rewardAmount / durationSeconds, // Perfect emission
                    durationSeconds: durationSeconds,
                    lockupDurationSeconds: lockupDurationSeconds,
                    type: poolType,
                    availableRewards: rewardAmount, // Initial total rewards
                    startTime: Date.now(),
                    endTime: Date.now() + durationSeconds * 1000,
                    stakers: {}, // { userId: { stakedAmount, stakeTime, claimableRewards, unstakeAvailableTimestamp } }
                    creator_id: 'platform_owner',
                };
                showMessageBox(`Successfully created new farming pool: ${poolId}.`);
                addRecentActivity(`You created a new farming pool: ${poolId}.`);
                renderFarmingPage(); // Re-render to show new pool
            }
        });

        updateFarmingPoolsDisplay();
        if (selectedPoolId) {
            showFarmingPoolSubPage(selectedPoolId);
        }
    }

    function updateFarmingPoolsDisplay() {
        const platformList = document.getElementById('platformFarmingPoolsList');
        const stableList = document.getElementById('stableFarmingPoolsList');
        const volatileList = document.getElementById('volatileFarmingPoolsList');
        platformList.innerHTML = '';
        stableList.innerHTML = '';
        volatileList.innerHTML = '';

        Object.values(state.farmingPools).forEach(pool => {
            const totalStakedUsd = calculateTokenUSDValue(pool.stakedToken.ticker, pool.totalStakedAmount);
            const apr = calculateFarmingAPR(pool.id);
            const timeLeft = Math.max(0, Math.floor((pool.endTime - Date.now()) / 1000));
            const timeLeftFormatted = formatTime(timeLeft);

            const stakedSupplyPercent = (pool.stakedToken.is_stablecoin || pool.stakedToken.is_base_asset || !pool.stakedToken.total_supply || pool.stakedToken.total_supply === Infinity) ?
                '' : `<p class="text-gray-400">% Supply Staked: <span class="text-blue-300">${(pool.totalStakedAmount / pool.stakedToken.total_supply * 100).toFixed(2)}%</span></p>`;

            const poolCard = document.createElement('div');
            poolCard.className = `clickable-pool-card bg-gray-900 p-6 rounded-xl shadow-lg glow-border-subtle relative overflow-hidden`;
            poolCard.innerHTML = `
                <div class="moving-glow-effect absolute inset-0"></div>
                <h3 class="text-xl font-semibold text-white mb-2">${pool.id}</h3>
                <p class="text-gray-400">Staked: <span class="text-teal-300">${formatTokenAmount(pool.totalStakedAmount, pool.stakedToken.decimals)} ${pool.stakedToken.ticker}</span></p>
                <p class="text-gray-400">Stakers: <span class="text-blue-300">${Object.keys(pool.stakers).length}</span></p>
                ${stakedSupplyPercent}
                <p class="text-gray-400">APR: <span class="text-green-400">${apr.toFixed(2)}%</span></p>
                <p class="text-gray-400">Time Left: <span class="text-yellow-400">${timeLeftFormatted}</span></p>
            `;
            poolCard.addEventListener('click', () => showFarmingPoolSubPage(pool.id));

            if (pool.type === 'Platform') {
                platformList.appendChild(poolCard);
            } else if (pool.type === 'Stable') {
                stableList.appendChild(poolCard);
            } else {
                volatileList.appendChild(poolCard);
            }
        });
    }

    function showFarmingPoolSubPage(poolId) {
        const pool = state.farmingPools[poolId];
        if (!pool) {
            showMessageBox('Farming pool not found!', true);
            renderFarmingPage();
            return;
        }

        const apr = calculateFarmingAPR(pool.id);
        const timeLeft = Math.max(0, Math.floor((pool.endTime - Date.now()) / 1000));
        const timeLeftFormatted = formatTime(timeLeft);

        const stakedSupplyPercent = (pool.stakedToken.is_stablecoin || pool.stakedToken.is_base_asset || !pool.stakedToken.total_supply || pool.stakedToken.total_supply === Infinity) ?
            '' : `<p class="text-gray-400">% Supply Staked: <span class="text-blue-300">${(pool.totalStakedAmount / pool.stakedToken.total_supply * 100).toFixed(2)}%</span></p>`;

        const userStake = pool.stakers[state.users.platform_owner.id];
        const userStakedAmount = userStake ? formatTokenAmount(userStake.stakedAmount, pool.stakedToken.decimals) : '0.0';
        const userClaimableRewards = userStake ? formatTokenAmount(userStake.claimableRewards, pool.rewardToken.decimals) : '0.0';
        const userUnstakeTime = userStake && userStake.unstakeAvailableTimestamp ? new Date(userStake.unstakeAvailableTimestamp).toLocaleString() : 'N/A';

        mainContentDiv.innerHTML = `
            <div class="p-8 bg-gray-800 rounded-xl shadow-2xl glow-border">
                <button id="backToFarmingBtn" class="glow-button bg-gray-700 text-white px-4 py-2 rounded-lg mb-6">← Back to Farming</button>
                <h2 class="text-4xl font-bold font-poppins text-center mb-10 text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-500">${pool.id} Details</h2>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle mb-8">
                    <p class="text-gray-400 text-lg">Staked Token: <span class="text-white">${pool.stakedToken.name} (${pool.stakedToken.ticker})</span></p>
                    <p class="text-gray-400 text-lg">Reward Token: <span class="text-white">${pool.rewardToken.name} (${pool.rewardToken.ticker})</span></p>
                    <p class="text-gray-400 text-lg">Total Staked: <span class="text-teal-300">${formatTokenAmount(pool.totalStakedAmount, pool.stakedToken.decimals)} ${pool.stakedToken.ticker}</span></p>
                    <p class="text-gray-400 text-lg">Number of Stakers: <span class="text-blue-300">${Object.keys(pool.stakers).length}</span></p>
                    ${stakedSupplyPercent}
                    <p class="text-gray-400 text-lg">APR: <span class="text-green-400">${apr.toFixed(2)}%</span></p>
                    <p class="text-gray-400 text-lg">Time Left: <span class="text-yellow-400">${timeLeftFormatted}</span></p>
                    <p class="text-gray-400 text-lg">Lock-up Duration: <span class="text-white">${formatTime(pool.lockupDurationSeconds)}</span></p>
                    <p class="text-gray-400 text-lg">Rewards Supplied: <span class="text-purple-300">${formatTokenAmount(pool.availableRewards, pool.rewardToken.decimals)} ${pool.rewardToken.ticker}</span></p>
                </div>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle mb-8">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Your Stake</h3>
                    <p class="text-gray-400 text-lg">Your Staked Amount: <span class="text-white">${userStakedAmount} ${pool.stakedToken.ticker}</span></p>
                    <p class="text-gray-400 text-lg">Your Claimable Rewards: <span class="text-green-400">${userClaimableRewards} ${pool.rewardToken.ticker}</span></p>
                    <p class="text-gray-400 text-lg">Unstake Available: <span class="text-white">${userUnstakeTime}</span></p>

                    <div class="mt-6 space-y-4">
                        <div>
                            <label for="stakeAmount" class="block text-gray-400 text-sm mb-2">Amount to Stake</label>
                            <input type="number" id="stakeAmount" placeholder="0.0" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                            <p class="text-gray-500 text-sm mt-1">Your Balance: ${formatTokenAmount(state.users.platform_owner.balances[pool.stakedToken.ticker] || 0, pool.stakedToken.decimals)} ${pool.stakedToken.ticker}</p>
                        </div>
                        <button id="stakeBtn" class="glow-button w-full bg-gradient-to-r from-blue-500 to-purple-600 text-white px-6 py-3 rounded-lg font-semibold text-lg">Stake</button>
                        <button id="unstakeBtn" class="glow-button w-full bg-gradient-to-r from-red-500 to-orange-600 text-white px-6 py-3 rounded-lg font-semibold text-lg">Unstake</button>
                        <button id="claimRewardsBtn" class="glow-button w-full bg-gradient-to-r from-green-500 to-teal-500 text-white px-6 py-3 rounded-lg font-semibold text-lg">Claim Rewards</button>
                    </div>
                </div>
            </div>
        `;
        document.getElementById('backToFarmingBtn').addEventListener('click', () => renderFarmingPage());

        const stakeAmountInput = document.getElementById('stakeAmount');
        const stakeBtn = document.getElementById('stakeBtn');
        const unstakeBtn = document.getElementById('unstakeBtn');
        const claimRewardsBtn = document.getElementById('claimRewardsBtn');

        stakeBtn.addEventListener('click', async () => {
            const amount = parseFloat(stakeAmountInput.value);
            if (isNaN(amount) || amount <= 0) {
                showMessageBox('Please enter a valid amount to stake.', true);
                return;
            }
            const user = state.users.platform_owner;
            if (user.balances[pool.stakedToken.ticker] < amount) {
                showMessageBox(`Insufficient ${pool.stakedToken.ticker} balance.`, true);
                return;
            }

            const confirmStake = await showConfirmationModal(`Stake ${formatTokenAmount(amount, pool.stakedToken.decimals)} ${pool.stakedToken.ticker} in ${pool.id}?`);
            if (confirmStake) {
                const usdValue = calculateTokenUSDValue(pool.stakedToken.ticker, amount);
                if (!applyTransactionFee(user.id, usdValue, 'Stake', pool.id)) {
                    // applyTransactionFee already shows message
                    return;
                }

                user.balances[pool.stakedToken.ticker] -= amount;
                pool.totalStakedAmount += amount;

                if (!pool.stakers[user.id]) {
                    pool.stakers[user.id] = {
                        stakedAmount: 0,
                        stakeTime: Date.now(),
                        claimableRewards: 0,
                        unstakeAvailableTimestamp: pool.lockupDurationSeconds > 0 ? Date.now() + pool.lockupDurationSeconds * 1000 : 0,
                        lastClaimTime: Date.now(),
                    };
                }
                pool.stakers[user.id].stakedAmount += amount;
                showMessageBox(`Successfully staked ${formatTokenAmount(amount, pool.stakedToken.decimals)} ${pool.stakedToken.ticker} in ${pool.id}.`);
                addRecentActivity(`You staked ${formatTokenAmount(amount, pool.stakedToken.decimals)} ${pool.stakedToken.ticker} in ${pool.id}.`);
                showFarmingPoolSubPage(pool.id);
            }
        });

        unstakeBtn.addEventListener('click', async () => {
            const user = state.users.platform_owner;
            const userStake = pool.stakers[user.id];
            if (!userStake || userStake.stakedAmount <= 0) {
                showMessageBox('You have no tokens staked in this pool.', true);
                return;
            }
            if (pool.lockupDurationSeconds > 0 && Date.now() < userStake.unstakeAvailableTimestamp) {
                showMessageBox(`Your tokens are locked until ${new Date(userStake.unstakeAvailableTimestamp).toLocaleString()}.`, true);
                return;
            }

            const confirmUnstake = await showConfirmationModal(`Unstake all ${formatTokenAmount(userStake.stakedAmount, pool.stakedToken.decimals)} ${pool.stakedToken.ticker} from ${pool.id}?`);
            if (confirmUnstake) {
                const amount = userStake.stakedAmount;
                const usdValue = calculateTokenUSDValue(pool.stakedToken.ticker, amount);
                if (!applyTransactionFee(user.id, usdValue, 'Unstake', pool.id)) {
                    // applyTransactionFee already shows message
                    return;
                }

                user.balances[pool.stakedToken.ticker] = (user.balances[pool.stakedToken.ticker] || 0) + amount;
                pool.totalStakedAmount -= amount;
                userStake.stakedAmount = 0;
                userStake.claimableRewards = 0; // Claim rewards first before unstaking
                delete pool.stakers[user.id]; // Remove staker if amount is 0

                showMessageBox(`Successfully unstaked ${formatTokenAmount(amount, pool.stakedToken.decimals)} ${pool.stakedToken.ticker} from ${pool.id}.`);
                addRecentActivity(`You unstaked ${formatTokenAmount(amount, pool.stakedToken.decimals)} ${pool.stakedToken.ticker} from ${pool.id}.`);
                showFarmingPoolSubPage(pool.id);
            }
        });

        claimRewardsBtn.addEventListener('click', async () => {
            const user = state.users.platform_owner;
            const userStake = pool.stakers[user.id];
            if (!userStake || userStake.claimableRewards <= 0) {
                showMessageBox('No rewards to claim.', true);
                return;
            }

            const confirmClaim = await showConfirmationModal(`Claim ${formatTokenAmount(userStake.claimableRewards, pool.rewardToken.decimals)} ${pool.rewardToken.ticker} from ${pool.id}?`);
            if (confirmClaim) {
                const rewards = userStake.claimableRewards;
                const usdValue = calculateTokenUSDValue(pool.rewardToken.ticker, rewards);
                if (!applyTransactionFee(user.id, usdValue, 'ClaimFarmingRewards', pool.id)) {
                    // applyTransactionFee already shows message
                    return;
                }

                user.balances[pool.rewardToken.ticker] = (user.balances[pool.rewardToken.ticker] || 0) + rewards;
                state.platformWallet.revenueTracker.farmingRewards += usdValue; // Track for platform owner
                userStake.claimableRewards = 0;
                userStake.lastClaimTime = Date.now();
                showMessageBox(`Successfully claimed ${formatTokenAmount(rewards, pool.rewardToken.decimals)} ${pool.rewardToken.ticker} rewards from ${pool.id}.`);
                addRecentActivity(`You claimed ${formatTokenAmount(rewards, pool.rewardToken.decimals)} ${pool.rewardToken.ticker} rewards from ${pool.id}.`);
                showFarmingPoolSubPage(pool.id);
            }
        });
    }

    function formatTime(seconds) {
        if (seconds <= 0) return "0s";
        const d = Math.floor(seconds / (3600 * 24));
        const h = Math.floor((seconds % (3600 * 24)) / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        let parts = [];
        if (d > 0) parts.push(`${d}d`);
        if (h > 0) parts.push(`${h}h`);
        if (m > 0) parts.push(`${m}m`);
        if (s > 0 || parts.length === 0) parts.push(`${s}s`); // Ensure at least seconds are shown
        return parts.join(' ');
    }


    function renderLaunchTokenPage() {
        const tokenOptions = Object.values(state.tokens).map(t => `<option value="${t.ticker}">${t.ticker}</option>`).join('');

        mainContentDiv.innerHTML = `
            <div class="p-8 bg-gray-800 rounded-xl shadow-2xl glow-border">
                <h2 class="text-4xl font-bold font-poppins text-center mb-10 text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-500">Launch New Token</h2>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Token Parameters</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="tokenName" class="block text-gray-400 text-sm mb-2">Token Name</label>
                            <input type="text" id="tokenName" placeholder="e.g., MemeCoinX" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div>
                            <label for="tokenTicker" class="block text-gray-400 text-sm mb-2">Token Ticker</label>
                            <input type="text" id="tokenTicker" placeholder="e.g., MEMEX" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div class="md:col-span-2">
                            <label for="totalSupply" class="block text-gray-400 text-sm mb-2">Total Supply</label>
                            <input type="number" id="totalSupply" placeholder="e.g., 1000000000" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div>
                            <label for="liquidityPercent" class="block text-gray-400 text-sm mb-2">Liquidity % (Max ${state.platformSettings.maxLiquidityPercentLaunch}%)</label>
                            <input type="number" id="liquidityPercent" placeholder="e.g., 60" min="0" max="${state.platformSettings.maxLiquidityPercentLaunch}" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div>
                            <label for="stablecoinPair" class="block text-gray-400 text-sm mb-2">Stablecoin Pair</label>
                            <select id="stablecoinPair" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                                <option value="USDT">USDT</option>
                                <option value="USDC">USDC</option>
                            </select>
                        </div>
                        <div>
                            <label for="stablecoinAmount" class="block text-gray-400 text-sm mb-2">Stablecoin Amount (Min ${formatUSD(state.platformSettings.minLiquidityForLaunch)})</label>
                            <input type="number" id="stablecoinAmount" placeholder="e.g., 5000" min="${state.platformSettings.minLiquidityForLaunch}" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div>
                            <label for="burnPercent" class="block text-gray-400 text-sm mb-2">Burn % (Max ${state.platformSettings.maxBurnPercentLaunch}%)</label>
                            <input type="number" id="burnPercent" placeholder="e.g., 5" min="0" max="${state.platformSettings.maxBurnPercentLaunch}" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div>
                            <label for="platformPercent" class="block text-gray-400 text-sm mb-2">Platform % (Compulsory 5%)</label>
                            <input type="number" id="platformPercent" value="5" readonly class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div>
                            <label for="presalePercent" class="block text-gray-400 text-sm mb-2">Presale % (Max ${state.platformSettings.maxPresalePercentLaunch}%)</label>
                            <input type="number" id="presalePercent" placeholder="e.g., 15" min="0" max="${state.platformSettings.maxPresalePercentLaunch}" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div>
                            <label for="teamPercent" class="block text-gray-400 text-sm mb-2">Team % (Max ${state.platformSettings.maxTeamPercentLaunch}%)</label>
                            <input type="number" id="teamPercent" placeholder="e.g., 10" min="0" max="${state.platformSettings.maxTeamPercentLaunch}" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                    </div>
                    <p id="totalPercentSum" class="text-xl font-semibold mt-4 text-center text-yellow-400">Total Allocated: 0%</p>
                    <button id="launchTokenBtn" class="glow-button w-full bg-gradient-to-r from-blue-500 to-purple-600 text-white px-6 py-3 rounded-lg font-semibold text-lg mt-6">Launch Token</button>
                </div>
            </div>
        `;

        const inputs = ['liquidityPercent', 'burnPercent', 'platformPercent', 'presalePercent', 'teamPercent'];
        const totalPercentSumDisplay = document.getElementById('totalPercentSum');
        const launchTokenBtn = document.getElementById('launchTokenBtn');

        const updatePercentageSum = () => {
            let sum = 0;
            inputs.forEach(id => {
                const value = parseFloat(document.getElementById(id).value);
                if (!isNaN(value)) {
                    sum += value;
                }
            });
            totalPercentSumDisplay.textContent = `Total Allocated: ${sum}%`;
            if (sum === 100) {
                totalPercentSumDisplay.classList.remove('text-red-400', 'text-yellow-400');
                totalPercentSumDisplay.classList.add('text-green-400');
                launchTokenBtn.disabled = false;
                launchTokenBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else if (sum > 100) {
                totalPercentSumDisplay.classList.remove('text-green-400', 'text-yellow-400');
                totalPercentSumDisplay.classList.add('text-red-400');
                launchTokenBtn.disabled = true;
                launchTokenBtn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                totalPercentSumDisplay.classList.remove('text-green-400', 'text-red-400');
                totalPercentSumDisplay.classList.add('text-yellow-400');
                launchTokenBtn.disabled = true;
                launchTokenBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
        };

        inputs.forEach(id => {
            document.getElementById(id).addEventListener('input', updatePercentageSum);
        });
        updatePercentageSum(); // Initial calculation

        launchTokenBtn.addEventListener('click', async () => {
            const tokenName = document.getElementById('tokenName').value.trim();
            const tokenTicker = document.getElementById('tokenTicker').value.trim().toUpperCase();
            const totalSupply = parseFloat(document.getElementById('totalSupply').value);
            const liquidityPercent = parseFloat(document.getElementById('liquidityPercent').value);
            const stablecoinPair = document.getElementById('stablecoinPair').value;
            const stablecoinAmount = parseFloat(document.getElementById('stablecoinAmount').value);
            const burnPercent = parseFloat(document.getElementById('burnPercent').value);
            const platformPercent = parseFloat(document.getElementById('platformPercent').value);
            const presalePercent = parseFloat(document.getElementById('presalePercent').value);
            const teamPercent = parseFloat(document.getElementById('teamPercent').value);

            if (!tokenName || !tokenTicker || isNaN(totalSupply) || totalSupply <= 0 || isNaN(liquidityPercent) || isNaN(stablecoinAmount) || stablecoinAmount < state.platformSettings.minLiquidityForLaunch || isNaN(burnPercent) || isNaN(platformPercent) || isNaN(presalePercent) || isNaN(teamPercent)) {
                showMessageBox('Please fill all fields correctly and ensure minimum stablecoin amount.', true);
                return;
            }
            if (state.tokens[tokenTicker]) {
                showMessageBox(`Token with ticker ${tokenTicker} already exists.`, true);
                return;
            }
            if (liquidityPercent + burnPercent + platformPercent + presalePercent + teamPercent !== 100) {
                showMessageBox('Allocated percentages must sum to 100%.', true);
                return;
            }

            const confirmLaunch = await showConfirmationModal(`Launch new token ${tokenTicker} with total supply ${totalSupply.toLocaleString()}?`);
            if (confirmLaunch) {
                const initialBurnAmount = totalSupply * (burnPercent / 100);
                const circulatingSupply = totalSupply - initialBurnAmount;
                const liquidityTokenAmount = totalSupply * (liquidityPercent / 100);
                const presaleTokenAmount = totalSupply * (presalePercent / 100);
                const teamTokenAmount = totalSupply * (teamPercent / 100);
                const platformTokenAmount = totalSupply * (platformPercent / 100);

                const initialPriceUsd = stablecoinAmount / liquidityTokenAmount;
                const initialMarketCap = circulatingSupply * initialPriceUsd;

                const newProjectId = generateUniqueId();
                const newToken = {
                    ticker: tokenTicker,
                    name: tokenName,
                    total_supply: totalSupply,
                    circulating_supply: circulatingSupply,
                    decimals: 6, // Default decimals for new tokens
                    price_usd: initialPriceUsd,
                    market_cap_usd: initialMarketCap,
                    is_base_asset: false,
                    is_stablecoin: false,
                    creator_id: 'platform_owner',
                    launch_details: {
                        initial_liquidity_percent: liquidityPercent,
                        initial_burn_percent: burnPercent,
                        platform_allocation_percent: platformPercent,
                        presale_allocation_percent: presalePercent,
                        team_allocation_percent: teamPercent,
                        initial_price_usd: initialPriceUsd,
                        rug_pull_chance: 0.5, // Only applies to bot-launched, but stored
                        build_chance: 0.5, // Only applies to bot-launched, but stored
                        team_wallet_balance: teamTokenAmount, // Initial team allocation
                        status: 'Pending Approval', // Status for launched tokens
                        build_log: [], // Initialize build log
                    },
                };

                state.tokens[tokenTicker] = newToken;

                // Create presale project
                state.presaleProjects[newProjectId] = {
                    projectId: newProjectId,
                    tokenDetails: newToken,
                    creatorId: 'platform_owner',
                    status: 'Active', // Directly active for manual launch
                    hardCapUsdt: stablecoinAmount, // Hard cap is the stablecoin liquidity amount
                    softCapUsdt: stablecoinAmount * 0.5, // 50% soft cap
                    usdtRaised: 0,
                    tokensForSale: presaleTokenAmount,
                    tokensSold: 0,
                    buyersList: [],
                    progressPercent: 0,
                    initialDexLiquidityUsdt: stablecoinAmount,
                    initial_dex_liquidity_tokens: liquidityTokenAmount,
                };
                showMessageBox(`Token application ${tokenTicker} submitted and is now in Presale!`);
                addRecentActivity(`You launched a new token application: ${tokenTicker}. It is now in Presale.`);
                renderPresaleStagePage(); // Go to presale page
            }
        });
    }

    function renderPresaleStagePage(selectedProjectId = null) {
        mainContentDiv.innerHTML = `
            <div class="p-8 bg-gray-800 rounded-xl shadow-2xl glow-border">
                <h2 class="text-4xl font-bold font-poppins text-center mb-10 text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-500">Presale Stage</h2>

                <div class="mb-8">
                    <h3 class="text-3xl font-semibold font-poppins mb-6 text-white text-center">Token Applications for Review</h3>
                    <div id="pendingApplicationsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        <!-- Pending applications will be rendered here -->
                    </div>
                </div>

                <h3 class="text-3xl font-semibold font-poppins mb-6 text-white text-center">Active Presales</h3>
                <div id="activePresalesList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <!-- Active presales will be rendered here -->
                </div>
            </div>
        `;

        updatePresaleDisplays();
        if (selectedProjectId) {
            showPresaleSubPage(selectedProjectId);
        }
    }

    function updatePresaleDisplays() {
        const pendingList = document.getElementById('pendingApplicationsList');
        const activeList = document.getElementById('activePresalesList');
        pendingList.innerHTML = '';
        activeList.innerHTML = '';

        Object.values(state.presaleProjects).forEach(project => {
            if (project.status === 'Filled' || project.status === 'Listed on DEX' || project.status === 'Rejected') return; // Don't show completed/rejected

            const card = document.createElement('div');
            card.className = `bg-gray-900 p-6 rounded-xl shadow-lg glow-border-subtle clickable-pool-card relative overflow-hidden`;
            card.innerHTML = `
                <div class="moving-glow-effect absolute inset-0"></div>
                <h3 class="text-xl font-semibold text-white mb-2">${project.tokenDetails.name} (${project.tokenDetails.ticker})</h3>
                <p class="text-gray-400">Status: <span class="text-yellow-400">${project.status}</span></p>
                <p class="text-gray-400">Creator: <span class="text-white">${project.creatorId.startsWith('bot_') ? 'Bot ' + project.creatorId.split('_')[1] : 'You'}</span></p>
                <p class="text-gray-400">Hard Cap: <span class="text-teal-300">${formatUSD(project.hardCapUsdt)}</span></p>
                ${project.status === 'Active' ? `
                    <div class="w-full bg-gray-700 rounded-full h-2.5 mt-4">
                        <div class="bg-blue-600 h-2.5 rounded-full" style="width: ${project.progressPercent}%"></div>
                    </div>
                    <p class="text-sm text-gray-400 mt-2">${project.progressPercent.toFixed(2)}% Filled</p>
                ` : ''}
            `;
            card.addEventListener('click', () => showPresaleSubPage(project.projectId));

            if (project.status === 'Pending Approval') {
                pendingList.appendChild(card);
            } else if (project.status === 'Active') {
                activeList.appendChild(card);
            }
        });
    }

    function showPresaleSubPage(projectId) {
        const project = state.presaleProjects[projectId];
        if (!project) {
            showMessageBox('Presale project not found!', true);
            renderPresaleStagePage();
            return;
        }

        const isPlatformOwnerCreated = project.creatorId === state.users.platform_owner.id;
        const actionButtonsHtml = project.status === 'Pending Approval' ? `
            <button id="acceptPresaleBtn" class="glow-button bg-gradient-to-r from-green-500 to-teal-500 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:from-green-600 hover:to-teal-600 transition-all duration-300">Accept Application</button>
            <button id="rejectPresaleBtn" class="glow-button bg-gradient-to-r from-red-500 to-orange-600 text-white px-6 py-3 rounded-lg font-semibold text-lg hover:from-red-600 hover:to-orange-700 transition-all duration-300">Reject Application</button>
        ` : '';

        const buyInHtml = project.status === 'Active' ? `
            <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Buy into Presale</h3>
            <p class="text-gray-400 mb-2">Price: <span class="text-teal-300">${formatUSD(project.tokenDetails.price_usd)} per ${project.tokenDetails.ticker}</span></p>
            <p class="text-gray-400 mb-2">Tokens for Sale: <span class="text-white">${formatTokenAmount(project.tokensForSale - project.tokensSold, project.tokenDetails.decimals)} ${project.tokenDetails.ticker}</span></p>
            <p class="text-gray-400 mb-2">You will get: <span id="presaleTokensToGet" class="text-green-400">0.0 ${project.tokenDetails.ticker}</span></p>
            <input type="number" id="presaleBuyAmountUsdt" placeholder="USDT Amount" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400 mb-4">
            <button id="maxBuyBtn" class="glow-button bg-gradient-to-r from-yellow-500 to-orange-500 text-white px-6 py-3 rounded-lg font-semibold text-lg mb-4">Max Buy</button>
            <button id="buyPresaleBtn" class="glow-button w-full bg-gradient-to-r from-blue-500 to-purple-600 text-white px-6 py-3 rounded-lg font-semibold text-lg">Buy Now</button>
        ` : '';

        const launchNowButtonHtml = (project.status === 'Active' && isPlatformOwnerCreated) ? `
            <button id="launchNowBtn" class="glow-button bg-gradient-to-r from-red-600 to-pink-700 text-white px-6 py-3 rounded-lg font-semibold text-lg mt-6">Launch Token Now (Even if Unfilled)</button>
        ` : '';


        mainContentDiv.innerHTML = `
            <div class="p-8 bg-gray-800 rounded-xl shadow-2xl glow-border">
                <button id="backToPresaleBtn" class="glow-button bg-gray-700 text-white px-4 py-2 rounded-lg mb-6">← Back to Presales</button>
                <h2 class="text-4xl font-bold font-poppins text-center mb-10 text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-500">${project.tokenDetails.name} (${project.tokenDetails.ticker})</h2>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle mb-8">
                    <p class="text-gray-400 text-lg">Status: <span class="text-yellow-400">${project.status}</span></p>
                    <p class="text-gray-400 text-lg">Creator: <span class="text-white">${project.creatorId.startsWith('bot_') ? 'Bot ' + project.creatorId.split('_')[1] : 'You'}</span></p>
                    <p class="text-gray-400 text-lg">Total Supply: <span class="text-white">${project.tokenDetails.total_supply.toLocaleString()}</span></p>
                    <p class="text-gray-400 text-lg">Initial Price: <span class="text-teal-300">${formatUSD(project.tokenDetails.price_usd)}</span></p>
                    <p class="text-gray-400 text-lg">Hard Cap: <span class="text-teal-300">${formatUSD(project.hardCapUsdt)}</span></p>
                    <p class="text-gray-400 text-lg">USDT Raised: <span class="text-green-400">${formatUSD(project.usdtRaised)}</span></p>
                    <p class="text-gray-400 text-lg">Progress: <span class="text-blue-400">${project.progressPercent.toFixed(2)}%</span></p>
                    <div class="w-full bg-gray-700 rounded-full h-4 mt-2">
                        <div class="bg-blue-600 h-4 rounded-full" style="width: ${project.progressPercent}%"></div>
                    </div>
                    <p class="text-gray-400 text-lg mt-4">Tokens for Sale: <span class="text-white">${formatTokenAmount(project.tokensForSale, project.tokenDetails.decimals)}</span></p>
                    <p class="text-gray-400 text-lg">Tokens Sold: <span class="text-white">${formatTokenAmount(project.tokensSold, project.tokenDetails.decimals)}</span></p>
                    <p class="text-gray-400 text-lg">Liquidity %: <span class="text-white">${project.tokenDetails.launch_details.initial_liquidity_percent}%</span></p>
                    <p class="text-gray-400 text-lg">Burn %: <span class="text-white">${project.tokenDetails.launch_details.initial_burn_percent}%</span></p>
                    <p class="text-gray-400 text-lg">Platform %: <span class="text-white">${project.tokenDetails.launch_details.platform_allocation_percent}%</span></p>
                    <p class="text-gray-400 text-lg">Presale %: <span class="text-white">${project.tokenDetails.launch_details.presale_allocation_percent}%</span></p>
                    <p class="text-gray-400 text-lg">Team %: <span class="text-white">${project.tokenDetails.launch_details.team_allocation_percent}%</span></p>
                </div>

                <div class="flex justify-center space-x-4 mb-8">
                    ${actionButtonsHtml}
                </div>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle">
                    ${buyInHtml}
                    ${launchNowButtonHtml}
                </div>
            </div>
        `;
        document.getElementById('backToPresaleBtn').addEventListener('click', () => renderPresaleStagePage());

        if (project.status === 'Pending Approval') {
            document.getElementById('acceptPresaleBtn').addEventListener('click', async () => {
                const confirmAccept = await showConfirmationModal(`Accept ${project.tokenDetails.ticker} application?`);
                if (confirmAccept) {
                    project.status = 'Active';
                    showMessageBox(`Accepted ${project.tokenDetails.ticker}'s presale application.`, false);
                    addRecentActivity(`You accepted ${project.tokenDetails.ticker}'s presale application.`);
                    renderPresaleStagePage(projectId);
                }
            });
            document.getElementById('rejectPresaleBtn').addEventListener('click', async () => {
                const confirmReject = await showConfirmationModal(`Reject ${project.tokenDetails.ticker} application?`);
                if (confirmReject) {
                    project.status = 'Rejected';
                    showMessageBox(`Rejected ${project.tokenDetails.ticker}'s presale application.`, true);
                    addRecentActivity(`You rejected ${project.tokenDetails.ticker}'s presale application.`);
                    renderPresaleStagePage();
                }
            });
        } else if (project.status === 'Active') {
            const presaleBuyAmountUsdtInput = document.getElementById('presaleBuyAmountUsdt');
            const presaleTokensToGetSpan = document.getElementById('presaleTokensToGet');
            const buyPresaleBtn = document.getElementById('buyPresaleBtn');
            const maxBuyBtn = document.getElementById('maxBuyBtn');
            const launchNowBtn = document.getElementById('launchNowBtn');


            const updateTokensToGet = () => {
                const usdtAmount = parseFloat(presaleBuyAmountUsdtInput.value);
                if (isNaN(usdtAmount) || usdtAmount <= 0) {
                    presaleTokensToGetSpan.textContent = `0.0 ${project.tokenDetails.ticker}`;
                    return;
                }
                const tokens = usdtAmount / project.tokenDetails.price_usd;
                presaleTokensToGetSpan.textContent = `${formatTokenAmount(tokens, project.tokenDetails.decimals)} ${project.tokenDetails.ticker}`;
            };
            presaleBuyAmountUsdtInput.addEventListener('input', updateTokensToGet);

            if (maxBuyBtn) {
                maxBuyBtn.addEventListener('click', () => {
                    const remainingUsdtNeeded = project.hardCapUsdt - project.usdtRaised;
                    const userUsdtBalance = state.users.platform_owner.balances.USDT;
                    const maxPossibleBuy = Math.min(remainingUsdtNeeded, userUsdtBalance);
                    presaleBuyAmountUsdtInput.value = maxPossibleBuy.toFixed(2);
                    updateTokensToGet();
                });
            }


            buyPresaleBtn.addEventListener('click', async () => {
                const usdtAmount = parseFloat(presaleBuyAmountUsdtInput.value);
                if (isNaN(usdtAmount) || usdtAmount <= 0) {
                    showMessageBox('Please enter a valid USDT amount.', true);
                    return;
                }
                if (state.users.platform_owner.balances.USDT < usdtAmount) {
                    showMessageBox('Insufficient USDT balance.', true);
                    return;
                }
                const tokensToReceive = usdtAmount / project.tokenDetails.price_usd;
                if (project.tokensSold + tokensToReceive > project.tokensForSale) {
                    showMessageBox('Amount exceeds remaining tokens for sale.', true);
                    return;
                }

                const confirmBuy = await showConfirmationModal(`Buy ${formatTokenAmount(tokensToReceive, project.tokenDetails.decimals)} ${project.tokenDetails.ticker} for ${formatUSD(usdtAmount)} USDT?`);
                if (confirmBuy) {
                    const user = state.users.platform_owner;
                    if (!applyTransactionFee(user.id, usdtAmount, 'PresaleBuy', null)) {
                        // applyTransactionFee already shows message
                        return;
                    }

                    user.balances.USDT -= usdtAmount;
                    project.usdtRaised += usdtAmount;
                    project.tokensSold += tokensToReceive;
                    project.progressPercent = (project.usdtRaised / project.hardCapUsdt) * 100;

                    // Add buyer to list for airdrop
                    project.buyersList.push({
                        userId: user.id,
                        usdtContributed: usdtAmount,
                        tokensToReceive: tokensToReceive,
                        claimedAirdrop: false,
                    });

                    showMessageBox(`Successfully bought ${formatTokenAmount(tokensToReceive, project.tokenDetails.decimals)} ${project.tokenDetails.ticker} in presale.`, false);
                    addRecentActivity(`You bought ${formatTokenAmount(tokensToReceive, project.tokenDetails.decimals)} ${project.tokenDetails.ticker} in presale.`);
                    if (project.progressPercent >= 100) {
                        project.status = 'Filled';
                        showMessageBox(`Presale for ${project.tokenDetails.ticker} filled! Listing on DEX...`, false);
                        addRecentActivity(`Presale for ${project.tokenDetails.ticker} filled! Listing on DEX...`);
                        await listTokenOnDex(project.projectId);
                    }
                    showPresaleSubPage(projectId); // Re-render sub-page
                }
            });

            if (launchNowBtn) {
                launchNowBtn.addEventListener('click', async () => {
                    const confirmLaunchNow = await showConfirmationModal(`Launch ${project.tokenDetails.ticker} on DEX now, even if presale is not 100% filled?`);
                    if (confirmLaunchNow) {
                        project.status = 'Filled'; // Force status to filled to trigger listing logic
                        showMessageBox(`Forced launch of ${project.tokenDetails.ticker} on DEX!`, false);
                        addRecentActivity(`Forced launch of ${project.tokenDetails.ticker} on DEX!`);
                        await listTokenOnDex(project.projectId);
                    }
                });
            }
        }
    }

    async function listTokenOnDex(projectId) {
        const project = state.presaleProjects[projectId];
        if (!project || project.status !== 'Filled') return;

        const token = state.tokens[project.tokenDetails.ticker]; // Ensure we use the global token object
        const initialLiquidityTokenAmount = project.initial_dex_liquidity_tokens;
        const initialLiquidityUsdtAmount = project.initialDexLiquidityUsdt;

        // Handle creator's funds for initial liquidity and platform allocation
        let creatorWallet;
        if (project.creatorId.startsWith('bot_')) {
            creatorWallet = state.users[project.creatorId];
            // Check bot's balances for initial liquidity
            if (creatorWallet.balances.USDT < initialLiquidityUsdtAmount || creatorWallet.balances[token.ticker] < initialLiquidityTokenAmount) {
                showMessageBox(`Listing of ${token.ticker} failed: Creator (${creatorWallet.id}) insufficient funds for initial DEX liquidity.`, true);
                project.status = 'Failed Listing';
                addRecentActivity(`Listing of ${token.ticker} failed: Creator insufficient funds.`);
                return;
            }
            creatorWallet.balances.USDT -= initialLiquidityUsdtAmount;
            creatorWallet.balances[token.ticker] -= initialLiquidityTokenAmount;

            // Transfer platform allocation from bot's total supply to platform wallet
            const platformAllocationAmount = token.total_supply * (token.launch_details.platform_allocation_percent / 100);
            token.launch_details.platform_wallet_balance = platformAllocationAmount; // Store platform's allocation
            state.platformWallet.balances[token.ticker] = (state.platformWallet.balances[token.ticker] || 0) + platformAllocationAmount;
            token.circulating_supply -= platformAllocationAmount; // Reduce circulating supply for platform allocation
        } else { // Platform owner launched
            creatorWallet = state.users.platform_owner;
            if (creatorWallet.balances.USDT < initialLiquidityUsdtAmount || creatorWallet.balances[token.ticker] < initialLiquidityTokenAmount) {
                showMessageBox(`Listing of ${token.ticker} failed: You have insufficient funds for initial DEX liquidity.`, true);
                project.status = 'Failed Listing';
                addRecentActivity(`Listing of ${token.ticker} failed: You insufficient funds.`);
                return;
            }
            creatorWallet.balances.USDT -= initialLiquidityUsdtAmount;
            creatorWallet.balances[token.ticker] -= initialLiquidityTokenAmount;
            // Platform allocation already handled on launch page, directly to platform wallet
        }

        // Create the liquidity pool
        const poolId = `${token.ticker}-USDT`;
        state.liquidityPools[poolId] = {
            id: poolId,
            tokenA: token,
            tokenB: state.tokens.USDT,
            balanceA: initialLiquidityTokenAmount,
            balanceB: initialLiquidityUsdtAmount,
            k: initialLiquidityTokenAmount * initialLiquidityUsdtAmount,
            lpTokenSupply: Math.sqrt(initialLiquidityTokenAmount * initialLiquidityUsdtAmount),
            feesEarnedLP: 0,
            incentivesAdded: {},
            type: 'Volatile', // Newly launched tokens are volatile
            volumeUSD: 0,
        };
        token.price_usd = initialLiquidityUsdtAmount / initialLiquidityTokenAmount; // Ensure price is correctly set by LP
        token.market_cap_usd = token.circulating_supply * token.price_usd;

        // Update token status to Listed on DEX
        token.launch_details.status = 'Listed on DEX';
        project.status = 'Listed on DEX'; // Also update project status

        showMessageBox(`${token.ticker} has been listed on DEX!`, false);
        addRecentActivity(`${token.ticker} has been listed on DEX!`);

        // Airdrop tokens to presale buyers
        project.buyersList.forEach(buyer => {
            const buyerUser = state.users[buyer.userId];
            if (buyerUser && !buyer.claimedAirdrop) {
                buyerUser.balances[token.ticker] = (buyerUser.balances[token.ticker] || 0) + buyer.tokensToReceive;
                buyer.claimedAirdrop = true;
                addRecentActivity(`${buyer.userId} received ${formatTokenAmount(buyer.tokensToReceive, token.decimals)} ${token.ticker} airdrop.`);
            }
        });

        // Trigger bot build/rug pull logic if bot-launched
        if (project.creatorId.startsWith('bot_')) {
            const isRugPull = Math.random() < 0.5; // 50% chance
            if (isRugPull) {
                addRecentActivity(`${token.ticker} by ${creatorWallet.id} is RUG PULLING!`);
                // Dump team tokens
                const teamTokens = token.launch_details.team_wallet_balance;
                if (teamTokens > 0) {
                    const pool = state.liquidityPools[poolId];
                    if (pool) {
                        // Simulate dumping by swapping a large amount
                        const dumpAmount = Math.min(teamTokens, creatorWallet.balances[token.ticker]);
                        if (dumpAmount > 0) {
                            creatorWallet.balances[token.ticker] -= dumpAmount;
                            const { outputAmount: usdtReceived } = calculateSwapOutput(dumpAmount, pool.balanceA, pool.balanceB);
                            pool.balanceA += dumpAmount;
                            pool.balanceB -= usdtReceived;
                            creatorWallet.balances.USDT = (creatorWallet.balances.USDT || 0) + usdtReceived;
                            // Price will crash due to AMM
                            state.tokens[token.ticker].price_usd = pool.balanceB / pool.balanceA;
                            state.tokens[token.ticker].market_cap_usd = state.tokens[token.ticker].circulating_supply * state.tokens[token.ticker].price_usd;
                            addRecentActivity(`🚨 ${token.ticker} price crashed due to ${creatorWallet.id} rug pull!`);
                            token.launch_details.build_log.push({timestamp: Date.now(), message: `Rug Pull: Dumped ${formatTokenAmount(dumpAmount, token.decimals)} ${token.ticker}.`});
                        }
                    }
                }
            } else {
                addRecentActivity(`${token.ticker} by ${creatorWallet.id} is BUILDING the project!`);
                token.launch_details.build_log.push({timestamp: Date.now(), message: `Project is now in BUILD mode.`});
                // Bot will start building activities in simulation loop
            }
        }

        renderDexTradePage(); // Navigate to DEX Trade after listing
    }


    function renderGamePage() {
        mainContentDiv.innerHTML = `
            <div class="p-8 bg-gray-800 rounded-xl shadow-2xl glow-border">
                <h2 class="text-4xl font-bold font-poppins text-center mb-10 text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-500">Spin-to-Win Game</h2>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle text-center mb-8">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Play for Rewards!</h3>
                    <p class="text-lg text-gray-400 mb-4">Pay <span class="text-teal-300">${formatUSD(1)}</span> equivalent to play.</p>

                    <div class="flex items-center justify-center space-x-4 mb-6">
                        <label for="gamePayToken" class="text-gray-400">Pay with:</label>
                        <select id="gamePayToken" class="p-2 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                            ${Object.values(state.tokens).map(t => `<option value="${t.ticker}">${t.ticker}</option>`).join('')}
                        </select>
                        <p class="text-gray-500 text-sm">Balance: <span id="gamePayBalance">0.0</span></p>
                    </div>

                    <button id="playGameBtn" class="glow-button bg-gradient-to-r from-green-500 to-teal-500 text-white px-8 py-4 rounded-lg font-semibold text-xl hover:from-green-600 hover:to-teal-600 transition-all duration-300">SPIN</button>
                    <p id="gameMessage" class="mt-4 text-xl font-semibold"></p>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle">
                        <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Your Pending Rewards</h3>
                        <ul id="pendingGameRewardsList" class="space-y-3 max-h-48 overflow-y-auto">
                            <!-- Dynamically populated -->
                        </ul>
                        <button id="claimGameRewardsBtn" class="glow-button w-full bg-gradient-to-r from-purple-500 to-pink-600 text-white px-6 py-3 rounded-lg font-semibold text-lg mt-6">Claim All Rewards</button>
                    </div>
                    <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle">
                        <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Game Rewards Pool</h3>
                        <ul id="gameRewardsPoolList" class="space-y-3 max-h-48 overflow-y-auto">
                            <!-- Dynamically populated -->
                        </ul>
                    </div>
                </div>

                <div class="mt-8 bg-gray-900 p-6 rounded-xl glow-border-subtle">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Top 3 Earners (Game)</h3>
                    <ul id="topGameEarnersList" class="space-y-3">
                        <!-- Dynamically populated -->
                    </ul>
                </div>

                <div class="mt-8 bg-gray-900 p-6 rounded-xl glow-border-subtle">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Recent Game Activity</h3>
                    <ul id="recentGameActivityList" class="space-y-3 text-sm text-gray-300 max-h-48 overflow-y-auto">
                        <!-- Dynamically populated -->
                    </ul>
                </div>
            </div>
        `;
        attachGameListeners();
    }

    function attachGameListeners() {
        const gamePayTokenSelect = document.getElementById('gamePayToken');
        const gamePayBalanceSpan = document.getElementById('gamePayBalance');
        const playGameBtn = document.getElementById('playGameBtn');
        const gameMessage = document.getElementById('gameMessage');
        const pendingGameRewardsList = document.getElementById('pendingGameRewardsList');
        const claimGameRewardsBtn = document.getElementById('claimGameRewardsBtn');

        const updateGamePayBalance = () => {
            gamePayBalanceSpan.textContent = `${formatTokenAmount(state.users.platform_owner.balances[gamePayTokenSelect.value] || 0, state.tokens[gamePayTokenSelect.value]?.decimals || 2)} ${gamePayTokenSelect.value}`;
        };
        gamePayTokenSelect.addEventListener('change', updateGamePayBalance);
        updateGamePayBalance();

        playGameBtn.addEventListener('click', async () => {
            const payToken = gamePayTokenSelect.value;
            const payAmountUsd = 1;
            const user = state.users.platform_owner;
            const payAmountToken = payAmountUsd / state.tokens[payToken].price_usd;

            if (user.balances[payToken] < payAmountToken) {
                showMessageBox(`Insufficient ${payToken} balance to play.`, true);
                return;
            }

            const confirmPlay = await showConfirmationModal(`Pay ${formatTokenAmount(payAmountToken, state.tokens[payToken].decimals)} ${payToken} to play?`);
            if (!confirmPlay) return;

            // Deduct fee first
            if (!applyTransactionFee(user.id, payAmountUsd, 'GamePlay', null)) {
                // applyTransactionFee already shows message
                return;
            }

            user.balances[payToken] -= payAmountToken;
            state.gameRewardsPool.availableRewards[payToken] = (state.gameRewardsPool.availableRewards[payToken] || 0) + payAmountToken; // $1 goes back to pool

            const isWin = Math.random() < 0.2; // 20% win chance
            let rewardsWon = [];
            let outcomeMessage = '';

            if (isWin) {
                const availableRewardTokens = Object.keys(state.gameRewardsPool.availableRewards).filter(t => state.gameRewardsPool.availableRewards[t] > 0);
                if (availableRewardTokens.length === 0) {
                    outcomeMessage = 'You won! But the reward pool is empty. Try again later.';
                    addRecentActivity(`${user.id} played and won, but pool was empty.`);
                } else {
                    // Select a random reward based on probabilities and availability
                    let selectedReward = null;
                    let cumulativeProbability = 0;
                    const rand = Math.random();

                    for (const prob of state.gameRewardsPool.rewardProbabilities) {
                        if (availableRewardTokens.includes(prob.token) && state.gameRewardsPool.availableRewards[prob.token] > 0) {
                            cumulativeProbability += prob.probability;
                            if (rand < cumulativeProbability) {
                                selectedReward = prob;
                                break;
                            }
                        }
                    }

                    if (!selectedReward) { // Fallback if no weighted reward found or available
                        selectedReward = state.gameRewardsPool.rewardProbabilities.find(p => availableRewardTokens.includes(p.token) && state.gameRewardsPool.availableRewards[p.token] > 0);
                        if (!selectedReward) { // Still no reward, means all pools are empty
                            outcomeMessage = 'You won! But the reward pool is empty. Try again later.';
                            addRecentActivity(`${user.id} played and won, but pool was empty.`);
                        }
                    }

                    if (selectedReward) {
                        let rewardAmount;
                        if (selectedReward.isUsdValue) {
                            rewardAmount = (Math.random() * (selectedReward.maxAmount - selectedReward.minAmount) + selectedReward.minAmount) / state.tokens[selectedReward.token].price_usd;
                        } else {
                            rewardAmount = Math.random() * (selectedReward.maxAmount - selectedReward.minAmount) + selectedReward.minAmount;
                        }
                        rewardAmount = Math.min(rewardAmount, state.gameRewardsPool.availableRewards[selectedReward.token]); // Cap by available
                        rewardAmount = parseFloat(rewardAmount.toFixed(state.tokens[selectedReward.token]?.decimals || 4)); // Format to token decimals

                        if (rewardAmount > 0) {
                            rewardsWon.push({ token: selectedReward.token, amount: rewardAmount });
                            state.gameRewardsPool.availableRewards[selectedReward.token] -= rewardAmount;
                            user.gameRewardsPending.push({ gameId: generateUniqueId(), rewards: rewardsWon, claimable: true });
                            outcomeMessage = `You WON! Rewards: ${rewardsWon.map(r => `${formatTokenAmount(r.amount, state.tokens[r.token].decimals)} ${r.token}`).join(', ')}`;
                            addRecentActivity(`${user.id} played and WON ${rewardsWon.map(r => `${formatTokenAmount(r.amount, state.tokens[r.token].decimals)} ${r.token}`).join(', ')}.`);
                        } else {
                            outcomeMessage = 'You won! But no specific reward could be allocated.';
                            addRecentActivity(`${user.id} played and won, but no reward allocated.`);
                        }
                    }
                }
            } else {
                outcomeMessage = 'You LOST. Try again!';
                addRecentActivity(`${user.id} played and LOST.`);
            }

            gameMessage.textContent = outcomeMessage;
            showMessageBox(outcomeMessage, !isWin); // Show success/error message
            updateGamePageDisplays();
        });

        claimGameRewardsBtn.addEventListener('click', async () => {
            const user = state.users.platform_owner;
            if (user.gameRewardsPending.length === 0) {
                showMessageBox('No pending rewards to claim.', true);
                return;
            }

            const totalUsdToClaim = user.gameRewardsPending.reduce((sum, r) => sum + r.rewards.reduce((s, t) => s + calculateTokenUSDValue(t.token, t.amount), 0), 0);
            const confirmClaim = await showConfirmationModal(`Claim all pending game rewards (${formatUSD(totalUsdToClaim)})?`);
            if (!confirmClaim) return;

            if (!applyTransactionFee(user.id, totalUsdToClaim, 'ClaimGameRewards')) {
                // applyTransactionFee already shows message
                return;
            }

            user.gameRewardsPending.forEach(pendingReward => {
                pendingReward.rewards.forEach(reward => {
                    user.balances[reward.token] = (user.balances[reward.token] || 0) + reward.amount;
                });
                state.platformWallet.revenueTracker.gamingWins += pendingReward.rewards.reduce((s, t) => s + calculateTokenUSDValue(t.token, t.amount), 0);
            });
            user.gameRewardsPending = []; // Clear pending rewards

            showMessageBox(`Successfully claimed all pending game rewards (${formatUSD(totalUsdToClaim)}).`, false);
            addRecentActivity(`You claimed all pending game rewards.`);
            updateGamePageDisplays();
        });

        updateGamePageDisplays();
    }

    function updateGamePageDisplays() {
        const pendingGameRewardsList = document.getElementById('pendingGameRewardsList');
        const gameRewardsPoolList = document.getElementById('gameRewardsPoolList');
        const topGameEarnersList = document.getElementById('topGameEarnersList');
        const recentGameActivityList = document.getElementById('recentGameActivityList');

        // Pending Rewards
        pendingGameRewardsList.innerHTML = state.users.platform_owner.gameRewardsPending.map(r => `
            <li class="text-white">${r.rewards.map(rw => `${formatTokenAmount(rw.amount, state.tokens[rw.token]?.decimals || 2)} ${rw.token}`).join(', ')}</li>
        `).join('');
        document.getElementById('claimGameRewardsBtn').disabled = state.users.platform_owner.gameRewardsPending.length === 0;
        document.getElementById('claimGameRewardsBtn').classList.toggle('opacity-50', state.users.platform_owner.gameRewardsPending.length === 0);

        // Game Rewards Pool
        gameRewardsPoolList.innerHTML = Object.entries(state.gameRewardsPool.availableRewards).map(([token, amount]) => {
            if (amount <= 0) return '';
            return `<li class="text-gray-400">${formatTokenAmount(amount, state.tokens[token]?.decimals || 2)} ${token} (${formatUSD(calculateTokenUSDValue(token, amount))})</li>`;
        }).join('');

        // Top Game Earners (Placeholder - needs actual tracking of game wins per user)
        // For now, just a mock or re-use top earners from homepage
        topGameEarnersList.innerHTML = `
            <li class="flex justify-between items-center text-lg"><span>Bot 2</span> <span class="text-teal-300">${formatUSD(500)}</span></li>
            <li class="flex justify-between items-center text-lg"><span>You</span> <span class="text-teal-300">${formatUSD(300)}</span></li>
            <li class="flex justify-between items-center text-lg"><span>Bot 4</span> <span class="text-teal-300">${formatUSD(150)}</span></li>
        `;

        // Recent Game Activity
        recentGameActivityList.innerHTML = state.gameRewardsPool.last5Transactions.map(activity => `
            <li>[${new Date(activity.timestamp).toLocaleTimeString()}] ${activity.userId.startsWith('bot_') ? 'Bot ' + activity.userId.split('_')[1] : 'You'} ${activity.outcome === 'Won' ? 'WON' : 'LOST'}. ${activity.rewardsWon.length > 0 ? `Rewards: ${activity.rewardsWon.map(r => `${formatTokenAmount(r.amount, state.tokens[r.token]?.decimals || 2)} ${r.token}`).join(', ')}` : ''}</li>
        `).reverse().join('');
    }

    function renderGovernancePage() {
        mainContentDiv.innerHTML = `
            <div class="p-8 bg-gray-800 rounded-xl shadow-2xl glow-border">
                <h2 class="text-4xl font-bold font-poppins text-center mb-10 text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-500">Governance (Display Only)</h2>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle mb-8">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Understanding $vePDEX</h3>
                    <p class="text-gray-400 mb-4">
                        $vePDEX is an ERC-721 NFT that represents vote-escrowed $PDEX tokens. It grants holders governance power and a share of protocol revenue.
                    </p>
                    <p class="text-gray-400 mb-4">
                        The amount of $vePDEX (voting power) you receive depends on the amount of $PDEX locked and the duration of the lock.
                        Longer locks grant significantly more voting power.
                    </p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
                        <div class="bg-gray-800 p-4 rounded-lg glow-border-subtle">
                            <h4 class="text-xl font-semibold text-white mb-2">Singularity veNFT</h4>
                            <p class="text-gray-400">Minted by locking $PDEX for 1 week up to 4 years.</p>
                            <p class="text-gray-400">Voting power decays linearly over time as lock duration decreases.</p>
                            <p class="text-gray-400">Can add more $PDEX to extend lock. Features 'Auto-Max Lock' to prevent decay.</p>
                            <div class="flex justify-center mt-4">
                                <div class="w-16 h-16 bg-gradient-to-br from-blue-400 to-purple-500 rounded-full flex items-center justify-center text-white text-sm font-bold shadow-lg">NFT</div>
                            </div>
                        </div>
                        <div class="bg-gray-800 p-4 rounded-lg glow-border-subtle">
                            <h4 class="text-xl font-semibold text-white mb-2">Supermassive veNFT</h4>
                            <p class="text-gray-400">Minted by <strong>perma-locking</strong> (burning) $PDEX tokens.</p>
                            <p class="text-gray-400">Provides non-decaying, permanent voting power.</p>
                            <p class="text-gray-400">Offers a 10% boost on rebase rewards.</p>
                            <p class="text-gray-400">Team tokens are exclusively Supermassive veNFTs for long-term alignment.</p>
                            <div class="flex justify-center mt-4">
                                <div class="w-16 h-16 bg-gradient-to-br from-red-500 to-orange-600 rounded-full flex items-center justify-center text-white text-sm font-bold shadow-lg">NFT</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle mb-8">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">My vePDEX Locks (Conceptual)</h3>
                    <div class="space-y-4">
                        <div class="bg-gray-800 p-4 rounded-lg flex justify-between items-center">
                            <div>
                                <p class="text-lg font-semibold text-white">Singularity veNFT #123</p>
                                <p class="text-gray-400">Locked: 10,000 PDEX</p>
                                <p class="text-gray-400">Lock Remaining: 2y 3m</p>
                            </div>
                            <div class="text-right">
                                <p class="text-xl font-bold text-teal-400">vePDEX: 5,000</p>
                                <p class="text-sm text-gray-500">APR: 12.5%</p>
                            </div>
                        </div>
                        <div class="bg-gray-800 p-4 rounded-lg flex justify-between items-center">
                            <div>
                                <p class="text-lg font-semibold text-white">Supermassive veNFT #456</p>
                                <p class="text-gray-400">Locked: 50,000 PDEX (Burned)</p>
                                <p class="text-gray-400">Lock Remaining: Permanent</p>
                            </div>
                            <div class="text-right">
                                <p class="text-xl font-bold text-teal-400">vePDEX: 50,000</p>
                                <p class="text-sm text-gray-500">APR: 18.0% (Boosted)</p>
                            </div>
                        </div>
                    </div>
                    <p class="text-center text-gray-500 mt-4">
                        <small>This section is for display only. Actual locking and veNFT management is not yet functional.</small>
                    </p>
                </div>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Voting Mechanism (Conceptual)</h3>
                    <p class="text-gray-400 mb-4">
                        $vePDEX holders govern which liquidity pools receive $PDEX emissions by voting. In return, voters receive all trading fees and bribes from the pool for which they vote.
                    </p>
                    <p class="text-gray-400 mb-4">
                        Voting operates on a weekly cycle called an Epoch, resetting every 7 days. Rewards are distributed exclusively to $vePDEX holders who have voted for specific pools during that Epoch.
                    </p>
                    <p class="text-gray-400 mb-4">
                        Your votes are persistent: Once you vote from a lock, that lock continues to vote on the same pools with the same allocation percentages automatically in every epoch until you decide to change your allocations.
                    </p>
                    <p class="text-center text-gray-500 mt-4">
                        <small>This voting system is for display only. Actual voting and reward distribution is not yet functional.</small>
                    </p>
                </div>
            </div>
        `;
    }

    function renderAdminPage() {
        mainContentDiv.innerHTML = `
            <div class="p-8 bg-gray-800 rounded-xl shadow-2xl glow-border">
                <h2 class="text-4xl font-bold font-poppins text-center mb-10 text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-500">Admin Panel</h2>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle mb-8">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Platform Fees Control</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="transactionFeePercent" class="block text-gray-400 text-sm mb-2">Transaction Fee %</label>
                            <input type="number" id="transactionFeePercent" min="0" max="100" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div>
                            <label for="lpRewardsPercent" class="block text-gray-400 text-sm mb-2">LP Rewards % (of Tx Fee)</label>
                            <input type="number" id="lpRewardsPercent" min="0" max="100" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div>
                            <label for="platformWalletPercent" class="block text-gray-400 text-sm mb-2">Platform Wallet % (of Tx Fee)</label>
                            <input type="number" id="platformWalletPercent" min="0" max="100" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <div>
                            <label for="pdexBurnPercent" class="block text-gray-400 text-sm mb-2">PDEX Burn % (of Tx Fee)</label>
                            <input type="number" id="pdexBurnPercent" min="0" max="100" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                        <p id="feeDistributionSum" class="text-xl font-semibold text-center text-yellow-400">Distribution Sum: 0%</p>
                        <button id="updateFeesBtn" class="glow-button w-full bg-gradient-to-r from-blue-500 to-purple-600 text-white px-6 py-3 rounded-lg font-semibold text-lg">Update Fees</button>
                    </div>
                </div>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle mb-8">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Bot Activity Control</h3>
                    <div class="flex items-center space-x-4 mb-4">
                        <label for="botActivityToggle" class="block text-gray-400 text-lg">Enable All Bots</label>
                        <input type="checkbox" id="botActivityToggle" class="form-checkbox h-6 w-6 text-blue-600 rounded-md">
                    </div>
                    <div class="space-y-4">
                        <div>
                            <label for="botTradingAggressiveness" class="block text-gray-400 text-sm mb-2">Bot Trading Aggressiveness (%)</label>
                            <input type="range" id="botTradingAggressiveness" min="0" max="100" value="${state.platformSettings.botTradingAggressiveness * 100}" class="w-full">
                            <p class="text-gray-500 text-sm mt-1">Current: <span id="botTradingAggressivenessValue">${state.platformSettings.botTradingAggressiveness * 100}%</span> (Affects trade amount)</p>
                        </div>
                        <div>
                            <label for="botLpAddAggressiveness" class="block text-gray-400 text-sm mb-2">Bot LP Add Aggressiveness (%)</label>
                            <input type="range" id="botLpAddAggressiveness" min="0" max="100" value="${state.platformSettings.botLpAddAggressiveness * 100}" class="w-full">
                            <p class="text-gray-500 text-sm mt-1">Current: <span id="botLpAddAggressivenessValue">${state.platformSettings.botLpAddAggressiveness * 100}%</span> (Affects LP add amount)</p>
                        </div>
                        <div>
                            <label for="botFarmingAggressiveness" class="block text-gray-400 text-sm mb-2">Bot Farming Aggressiveness (%)</label>
                            <input type="range" id="botFarmingAggressiveness" min="0" max="100" value="${state.platformSettings.botFarmingAggressiveness * 100}" class="w-full">
                            <p class="text-gray-500 text-sm mt-1">Current: <span id="botFarmingAggressivenessValue">${state.platformSettings.botFarmingAggressiveness * 100}%</span> (Affects staking amount)</p>
                        </div>
                    </div>
                    <button id="resetBotActivityBtn" class="glow-button bg-gradient-to-r from-orange-500 to-red-600 text-white px-6 py-3 rounded-lg font-semibold text-lg mt-6">Reset Bot Activity (Placeholder)</button>
                </div>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Other Admin Powers</h3>
                    <button id="callRewardsBtn" class="glow-button bg-gradient-to-r from-green-500 to-teal-500 text-white px-6 py-3 rounded-lg font-semibold text-lg">Call Rewards (Placeholder)</button>
                    <button id="addGameRewardsBtn" class="glow-button bg-gradient-to-r from-yellow-500 to-orange-500 text-white px-6 py-3 rounded-lg font-semibold text-lg mt-4">Add Game Rewards</button>
                    <div id="addGameRewardsForm" class="hidden mt-4 space-y-4">
                        <div>
                            <label for="gameRewardToken" class="block text-gray-400 text-sm mb-2">Reward Token</label>
                            <select id="gameRewardToken" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                                ${Object.values(state.tokens).map(t => `<option value="${t.ticker}">${t.ticker}</option>`).join('')}
                            </select>
                        </div>
                        <div>
                            <label for="gameRewardAmount" class="block text-gray-400 text-sm mb-2">Amount</label>
                            <input type="number" id="gameRewardAmount" placeholder="0.0" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                            <p class="text-gray-500 text-sm mt-1">Platform Balance: <span id="gameRewardPlatformBalance"></span></p>
                        </div>
                        <button id="submitAddGameRewardsBtn" class="glow-button w-full bg-gradient-to-r from-blue-500 to-purple-600 text-white px-6 py-3 rounded-lg font-semibold text-lg">Confirm Add Game Rewards</button>
                    </div>
                </div>
            </div>
        `;
        attachAdminListeners();
    }

    function attachAdminListeners() {
        const transactionFeeInput = document.getElementById('transactionFeePercent');
        const lpRewardsInput = document.getElementById('lpRewardsPercent');
        const platformWalletInput = document.getElementById('platformWalletPercent');
        const pdexBurnInput = document.getElementById('pdexBurnPercent');
        const feeDistributionSumDisplay = document.getElementById('feeDistributionSum');
        const updateFeesBtn = document.getElementById('updateFeesBtn');
        const botActivityToggle = document.getElementById('botActivityToggle');

        const botTradingAggressivenessInput = document.getElementById('botTradingAggressiveness');
        const botTradingAggressivenessValueSpan = document.getElementById('botTradingAggressivenessValue');
        const botLpAddAggressivenessInput = document.getElementById('botLpAddAggressiveness');
        const botLpAddAggressivenessValueSpan = document.getElementById('botLpAddAggressivenessValue');
        const botFarmingAggressivenessInput = document.getElementById('botFarmingAggressiveness');
        const botFarmingAggressivenessValueSpan = document.getElementById('botFarmingAggressivenessValue');

        const addGameRewardsBtn = document.getElementById('addGameRewardsBtn');
        const addGameRewardsForm = document.getElementById('addGameRewardsForm');
        const gameRewardTokenSelect = document.getElementById('gameRewardToken');
        const gameRewardAmountInput = document.getElementById('gameRewardAmount');
        const submitAddGameRewardsBtn = document.getElementById('submitAddGameRewardsBtn');
        const gameRewardPlatformBalanceSpan = document.getElementById('gameRewardPlatformBalance');


        // Set initial values
        transactionFeeInput.value = state.platformSettings.transactionFeePercentage;
        lpRewardsInput.value = state.platformSettings.feeDistributionLPRewardsPercent;
        platformWalletInput.value = state.platformSettings.feeDistributionPlatformWalletPercent;
        pdexBurnInput.value = state.platformSettings.feeDistributionPdexBurnPercent;
        botActivityToggle.checked = state.platformSettings.botActivityEnabled;

        botTradingAggressivenessInput.value = state.platformSettings.botTradingAggressiveness * 100;
        botLpAddAggressivenessInput.value = state.platformSettings.botLpAddAggressiveness * 100;
        botFarmingAggressivenessInput.value = state.platformSettings.botFarmingAggressiveness * 100;

        const updateFeeSum = () => {
            const lp = parseFloat(lpRewardsInput.value);
            const platform = parseFloat(platformWalletInput.value);
            const burn = parseFloat(pdexBurnInput.value);

            if (isNaN(lp) || isNaN(platform) || isNaN(burn)) {
                feeDistributionSumDisplay.textContent = 'Invalid input';
                feeDistributionSumDisplay.className = 'text-xl font-semibold mt-4 text-center text-red-400';
                updateFeesBtn.disabled = true;
                updateFeesBtn.classList.add('opacity-50', 'cursor-not-allowed');
                return;
            }

            const sum = lp + platform + burn;
            feeDistributionSumDisplay.textContent = `Distribution Sum: ${sum}% (of Transaction Fee)`;
            if (sum === 100) {
                feeDistributionSumDisplay.classList.remove('text-red-400', 'text-yellow-400');
                feeDistributionSumDisplay.classList.add('text-green-400');
                updateFeesBtn.disabled = false;
                updateFeesBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                feeDistributionSumDisplay.classList.remove('text-green-400', 'text-yellow-400');
                feeDistributionSumDisplay.classList.add('text-red-400');
                updateFeesBtn.disabled = true;
                updateFeesBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
        };

        transactionFeeInput.addEventListener('input', updateFeeSum);
        lpRewardsInput.addEventListener('input', updateFeeSum);
        platformWalletInput.addEventListener('input', updateFeeSum);
        pdexBurnInput.addEventListener('input', updateFeeSum);
        updateFeeSum(); // Initial call

        updateFeesBtn.addEventListener('click', async () => {
            const confirmUpdate = await showConfirmationModal('Confirm update of platform fee settings?');
            if (confirmUpdate) {
                state.platformSettings.transactionFeePercentage = parseFloat(transactionFeeInput.value);
                state.platformSettings.feeDistributionLPRewardsPercent = parseFloat(lpRewardsInput.value);
                state.platformSettings.feeDistributionPlatformWalletPercent = parseFloat(platformWalletInput.value);
                state.platformSettings.feeDistributionPdexBurnPercent = parseFloat(pdexBurnInput.value);
                showMessageBox('Platform fee settings updated!', false);
                addRecentActivity('Platform fee settings updated.');
            }
        });

        botActivityToggle.addEventListener('change', async () => {
            const newState = botActivityToggle.checked;
            const confirmToggle = await showConfirmationModal(`Confirm ${newState ? 'enabling' : 'disabling'} all bot activity?`);
            if (confirmToggle) {
                state.platformSettings.botActivityEnabled = newState;
                showMessageBox(`Bot activity ${newState ? 'enabled' : 'disabled'}.`, false);
                addRecentActivity(`Bot activity ${newState ? 'enabled' : 'disabled'}.`);
            } else {
                botActivityToggle.checked = !newState; // Revert toggle if cancelled
            }
        });

        // Bot aggressiveness sliders
        botTradingAggressivenessInput.addEventListener('input', (e) => {
            state.platformSettings.botTradingAggressiveness = parseFloat(e.target.value) / 100;
            botTradingAggressivenessValueSpan.textContent = `${e.target.value}%`;
        });
        botLpAddAggressivenessInput.addEventListener('input', (e) => {
            state.platformSettings.botLpAddAggressiveness = parseFloat(e.target.value) / 100;
            botLpAddAggressivenessValueSpan.textContent = `${e.target.value}%`;
        });
        botFarmingAggressivenessInput.addEventListener('input', (e) => {
            state.platformSettings.botFarmingAggressiveness = parseFloat(e.target.value) / 100;
            botFarmingAggressivenessValueSpan.textContent = `${e.target.value}%`;
        });


        document.getElementById('resetBotActivityBtn').addEventListener('click', () => showMessageBox('Bot activity reset functionality (placeholder).', true));
        document.getElementById('callRewardsBtn').addEventListener('click', () => showMessageBox('Call rewards functionality (placeholder).', true));

        addGameRewardsBtn.addEventListener('click', () => {
            addGameRewardsForm.classList.toggle('hidden');
        });

        const updateGameRewardPlatformBalance = () => {
            gameRewardPlatformBalanceSpan.textContent = `${formatTokenAmount(state.platformWallet.balances[gameRewardTokenSelect.value] || 0, state.tokens[gameRewardTokenSelect.value]?.decimals || 2)} ${gameRewardTokenSelect.value}`;
        };
        gameRewardTokenSelect.addEventListener('change', updateGameRewardPlatformBalance);
        updateGameRewardPlatformBalance();

        submitAddGameRewardsBtn.addEventListener('click', async () => {
            const rewardToken = gameRewardTokenSelect.value;
            const rewardAmount = parseFloat(gameRewardAmountInput.value);
            if (isNaN(rewardAmount) || rewardAmount <= 0) {
                showMessageBox('Please enter a valid reward amount.', true);
                return;
            }
            if (state.platformWallet.balances[rewardToken] < rewardAmount) {
                showMessageBox(`Insufficient ${rewardToken} in Platform Wallet.`, true);
                return;
            }

            const confirmAdd = await showConfirmationModal(`Add ${formatTokenAmount(rewardAmount, state.tokens[rewardToken]?.decimals || 2)} ${rewardToken} to Game Rewards Pool?`);
            if (confirmAdd) {
                state.platformWallet.balances[rewardToken] -= rewardAmount;
                state.gameRewardsPool.availableRewards[rewardToken] = (state.gameRewardsPool.availableRewards[rewardToken] || 0) + rewardAmount;
                showMessageBox(`Successfully added ${formatTokenAmount(rewardAmount, state.tokens[rewardToken]?.decimals || 2)} ${rewardToken} to Game Rewards Pool.`, false);
                addRecentActivity(`You added ${formatTokenAmount(rewardAmount, state.tokens[rewardToken]?.decimals || 2)} ${rewardToken} to Game Rewards Pool.`);
                addGameRewardsForm.classList.add('hidden'); // Hide form after submission
            }
        });
    }

    function renderPlatformWalletPage() {
        const user = state.platformWallet;
        user.totalUsdValue = calculateUserTotalUsdValue(user.id);

        let balancesHtml = '';
        for (const ticker in user.balances) {
            const amount = user.balances[ticker];
            const usdValue = calculateTokenUSDValue(ticker, amount);
            if (amount > 0 || usdValue > 0) { // Only show non-zero balances
                balancesHtml += `
                    <li class="flex justify-between items-center text-lg">
                        <span>${ticker}</span>
                        <span>${formatTokenAmount(amount, state.tokens[ticker]?.decimals || 4)}</span>
                        <span class="text-gray-400">${formatUSD(usdValue)}</span>
                    </li>
                `;
            }
        }

        mainContentDiv.innerHTML = `
            <div class="p-8 bg-gray-800 rounded-xl shadow-2xl glow-border">
                <h2 class="text-4xl font-bold font-poppins text-center mb-10 text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-500">Your Platform Wallet</h2>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle mb-8">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Current Balances</h3>
                    <p class="text-gray-400 text-lg mb-4">Total USD Value: <span class="text-teal-300">${formatUSD(user.totalUsdValue)}</span></p>
                    <ul class="space-y-3">
                        ${balancesHtml || '<li class="text-gray-400">No tokens in wallet.</li>'}
                    </ul>
                </div>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle mb-8">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Your Liquidity Positions (Placeholder)</h3>
                    <ul class="space-y-3">
                        ${user.liquidityPositions.length > 0 ? user.liquidityPositions.map(pos => `
                            <li class="flex justify-between items-center text-lg">
                                <span>LP: ${pos.poolId}</span>
                                <span>${formatTokenAmount(pos.lpTokenAmount)} LP</span>
                                <span class="text-gray-400">${formatUSD(calculateTokenUSDValue(pos.lpTokenAmount, 1))}</span>
                            </li>
                        `).join('') : '<li class="text-gray-400">No active LP positions.</li>'}
                    </ul>
                </div>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Revenue Tracker</h3>
                    <p class="text-gray-400 text-lg">LP Rewards Claimed: <span class="text-green-400">${formatUSD(user.revenueTracker.lpRewards)}</span></p>
                    <p class="text-gray-400 text-lg">Farming Rewards Claimed: <span class="text-green-400">${formatUSD(user.revenueTracker.farmingRewards)}</span></p>
                    <p class="text-gray-400 text-lg">Gaming Wins: <span class="text-green-400">${formatUSD(user.revenueTracker.gamingWins)}</span></p>
                    <p class="text-gray-400 text-lg">Platform Fees Collected: <span class="text-green-400">${formatUSD(user.revenueTracker.platformFees)}</span></p>
                </div>
            </div>
        `;
    }

    function renderBlackMarketPage() {
        const baseTokens = ['USDT', 'USDC', 'BTC', 'ETH', 'AVAX', 'SOL'];
        mainContentDiv.innerHTML = `
            <div class="p-8 bg-gray-800 rounded-xl shadow-2xl glow-border">
                <h2 class="text-4xl font-bold font-poppins text-center mb-10 text-transparent bg-clip-text bg-gradient-to-r from-blue-300 to-purple-500">Black Market</h2>

                <div class="bg-gray-900 p-6 rounded-xl glow-border-subtle">
                    <h3 class="text-2xl font-semibold font-poppins mb-4 text-white">Acquire Base Assets</h3>
                    <p class="text-gray-400 mb-4">Instantly acquire base assets for platform operations. (Simulated unlimited supply)</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label for="blackMarketToken" class="block text-gray-400 text-sm mb-2">Token to Acquire</label>
                            <select id="blackMarketToken" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                                ${baseTokens.map(t => `<option value="${t}">${t}</option>`).join('')}
                            </select>
                        </div>
                        <div>
                            <label for="blackMarketAmount" class="block text-gray-400 text-sm mb-2">Amount</label>
                            <input type="number" id="blackMarketAmount" placeholder="0.0" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:border-blue-400">
                        </div>
                    </div>
                    <button id="acquireTokenBtn" class="glow-button w-full bg-gradient-to-r from-purple-500 to-pink-600 text-white px-6 py-3 rounded-lg font-semibold text-lg mt-6">Acquire Token</button>
                </div>
            </div>
        `;
        document.getElementById('acquireTokenBtn').addEventListener('click', async () => {
            const token = document.getElementById('blackMarketToken').value;
            const amount = parseFloat(document.getElementById('blackMarketAmount').value);
            if (isNaN(amount) || amount <= 0) {
                showMessageBox('Please enter a valid amount.', true);
                return;
            }
            const confirmAcquire = await showConfirmationModal(`Acquire ${formatTokenAmount(amount, state.tokens[token]?.decimals || 2)} ${token} for Platform Wallet?`);
            if (confirmAcquire) {
                state.platformWallet.balances[token] = (state.platformWallet.balances[token] || 0) + amount;
                showMessageBox(`Successfully acquired ${formatTokenAmount(amount, state.tokens[token]?.decimals || 2)} ${token} from Black Market.`, false);
                addRecentActivity(`You acquired ${formatTokenAmount(amount, state.tokens[token]?.decimals || 2)} ${token} from Black Market.`);
            }
        });
    }


    // --- Navigation ---
    const sidebar = document.getElementById('sidebar');
    const hamburgerMenu = document.getElementById('hamburgerMenu');
    const closeSidebar = document.getElementById('closeSidebar');

    hamburgerMenu.addEventListener('click', () => {
      sidebar.classList.remove('translate-x-full');
    });

    closeSidebar.addEventListener('click', () => {
      sidebar.classList.add('translate-x-full');
    });

    document.getElementById('navHome').addEventListener('click', (e) => { e.preventDefault(); mainContentDiv.dataset.currentPage = 'home'; renderHomePage(); sidebar.classList.add('translate-x-full'); });
    document.getElementById('navDexTrade').addEventListener('click', (e) => { e.preventDefault(); mainContentDiv.dataset.currentPage = 'dexTrade'; renderDexTradePage(); sidebar.classList.add('translate-x-full'); });
    document.getElementById('navLiquidity').addEventListener('click', (e) => { e.preventDefault(); mainContentDiv.dataset.currentPage = 'liquidity'; renderLiquidityPage(); sidebar.classList.add('translate-x-full'); });
    document.getElementById('navFarming').addEventListener('click', (e) => { e.preventDefault(); mainContentDiv.dataset.currentPage = 'farming'; renderFarmingPage(); sidebar.classList.add('translate-x-full'); });
    document.getElementById('navLaunchToken').addEventListener('click', (e) => { e.preventDefault(); mainContentDiv.dataset.currentPage = 'launchToken'; renderLaunchTokenPage(); sidebar.classList.add('translate-x-full'); });
    document.getElementById('navPresaleStage').addEventListener('click', (e) => { e.preventDefault(); mainContentDiv.dataset.currentPage = 'presaleStage'; renderPresaleStagePage(); sidebar.classList.add('translate-x-full'); });
    document.getElementById('navGame').addEventListener('click', (e) => { e.preventDefault(); mainContentDiv.dataset.currentPage = 'game'; renderGamePage(); sidebar.classList.add('translate-x-full'); });
    document.getElementById('navGovernance').addEventListener('click', (e) => { e.preventDefault(); mainContentDiv.dataset.currentPage = 'governance'; renderGovernancePage(); sidebar.classList.add('translate-x-full'); });
    document.getElementById('navAdmin').addEventListener('click', (e) => { e.preventDefault(); mainContentDiv.dataset.currentPage = 'admin'; renderAdminPage(); sidebar.classList.add('translate-x-full'); });
    document.getElementById('navPlatformWallet').addEventListener('click', (e) => { e.preventDefault(); mainContentDiv.dataset.currentPage = 'platformWallet'; renderPlatformWalletPage(); sidebar.classList.add('translate-x-full'); });
    document.getElementById('navBlackMarket').addEventListener('click', (e) => { e.preventDefault(); mainContentDiv.dataset.currentPage = 'blackMarket'; renderBlackMarketPage(); sidebar.classList.add('translate-x-full'); });


    // --- Simulation Loop ---
    let simulationInterval;
    const SIMULATION_TICK_INTERVAL = 1000; // 1 second per tick

    function simulationLoop() {
        // Update simulation time
        state.simulationTime++;

        // Update token prices (simple volatility for base assets)
        ['BTC', 'ETH', 'AVAX', 'SOL'].forEach(ticker => {
            const token = state.tokens[ticker];
            if (token && token.is_base_asset) {
                const volatilityFactor = (Math.random() - 0.5) * 0.02; // +/- 1% change
                token.price_usd *= (1 + volatilityFactor);
                token.market_cap_usd = token.circulating_supply * token.price_usd;
            }
        });

        // Update prices for launched tokens based on their pools
        for (const poolId in state.liquidityPools) {
            const pool = state.liquidityPools[poolId];
            if (pool.tokenA.ticker !== 'USDT' && pool.tokenB.ticker === 'USDT') {
                pool.tokenA.price_usd = pool.balanceB / pool.balanceA;
                pool.tokenA.market_cap_usd = pool.tokenA.circulating_supply * pool.tokenA.price_usd;
            } else if (pool.tokenB.ticker !== 'USDT' && pool.tokenA.ticker === 'USDT') {
                 pool.tokenB.price_usd = pool.balanceA / pool.balanceB;
                 pool.tokenB.market_cap_usd = pool.tokenB.circulating_supply * pool.tokenB.price_usd;
            }
        }


        // Bot Activities (if enabled)
        if (state.platformSettings.botActivityEnabled) {
            Object.values(state.users).filter(u => u.isBot).forEach(bot => {
                // Bot Trading
                if (Date.now() - bot.lastBotTradeTime > (Math.random() * (state.platformSettings.botTradingFrequencyMax - state.platformSettings.botTradingFrequencyMin) + state.platformSettings.botTradingFrequencyMin)) {
                    performBotTrade(bot.id);
                    bot.lastBotTradeTime = Date.now();
                }

                // Bot LP Activity
                if (Date.now() - bot.lastBotLpTime > (Math.random() * (state.platformSettings.botLpActivityFrequencyMax - state.platformSettings.botLpActivityFrequencyMin) + state.platformSettings.botLpActivityFrequencyMin)) {
                    performBotLpActivity(bot.id);
                    bot.lastBotLpTime = Date.now();
                }

                // Bot Farming Activity (staking)
                if (Date.now() - bot.lastBotFarmingTime > (Math.random() * (state.platformSettings.botFarmingFrequencyMax - state.platformSettings.botFarmingFrequencyMin) + state.platformSettings.botFarmingFrequencyMin)) {
                    performBotFarmingActivity(bot.id);
                    bot.lastBotFarmingTime = Date.now();
                }

                // Bot Presale Contribution
                if (Date.now() - bot.lastBotPresaleBuyTime > (Math.random() * (state.platformSettings.botPresaleBuyFrequencyMax - state.platformSettings.botPresaleBuyFrequencyMin) + state.platformSettings.botPresaleBuyFrequencyMin)) {
                    performBotPresaleContribution(bot.id);
                    bot.lastBotPresaleBuyTime = Date.now();
                }


                // Bot Token Application (5 applications every 10 minutes)
                if (Date.now() - state.lastBotApplicationTime > (10 * 60 * 1000) / 5 && Math.random() < 0.2) { // Roughly 1 app every 2 minutes
                    createBotTokenApplication(bot.id);
                    state.lastBotApplicationTime = Date.now();
                }

                // Bot Building Activities (for launched tokens they created)
                if (bot.lastBotBuildTime && Date.now() - bot.lastBotBuildTime > (6 * 3600 * 1000)) { // Every 6 hours
                    performBotBuildingActivity(bot.id);
                    bot.lastBotBuildTime = Date.now();
                }

                // Bot Game Play
                if (Math.random() < 0.05) { // 5% chance per tick to play
                    performBotGamePlay(bot.id);
                }
            });
        }

        // Farming Pool Reward Accrual & Expiry
        for (const poolId in state.farmingPools) {
            const pool = state.farmingPools[poolId];
            const now = Date.now();

            // Accrue rewards
            for (const userId in pool.stakers) {
                const staker = pool.stakers[userId];
                if (staker.stakedAmount > 0 && pool.totalStakedAmount > 0) { // Ensure totalStakedAmount is not zero to avoid division by zero
                    const timeElapsed = (now - staker.lastClaimTime) / 1000; // Seconds since last claim/stake
                    const poolShare = staker.stakedAmount / pool.totalStakedAmount;
                    const rewardsAccrued = poolShare * pool.rewardRatePerSecond * timeElapsed;
                    staker.claimableRewards += rewardsAccrued;
                    staker.lastClaimTime = now; // Update last claim time for continuous accrual
                }
            }

            // Check for pool expiry
            if (now >= pool.endTime) {
                // Distribute remaining rewards and return staked tokens
                for (const userId in pool.stakers) {
                    const staker = pool.stakers[userId];
                    if (staker.stakedAmount > 0) {
                        const user = state.users[userId];
                        // Claim any remaining rewards
                        if (staker.claimableRewards > 0) {
                            user.balances[pool.rewardToken.ticker] = (user.balances[pool.rewardToken.ticker] || 0) + staker.claimableRewards;
                            if (user.id === state.platformWallet.id) {
                                state.platformWallet.revenueTracker.farmingRewards += calculateTokenUSDValue(pool.rewardToken.ticker, staker.claimableRewards);
                            }
                            addRecentActivity(`${user.id} claimed ${formatTokenAmount(staker.claimableRewards, pool.rewardToken.decimals)} ${pool.rewardToken.ticker} from expired pool ${pool.id}.`);
                        }
                        // Return staked tokens
                        user.balances[pool.stakedToken.ticker] = (user.balances[pool.stakedToken.ticker] || 0) + staker.stakedAmount;
                        addRecentActivity(`${user.id}'s ${formatTokenAmount(staker.stakedAmount, pool.stakedToken.decimals)} ${pool.stakedToken.ticker} returned from expired pool ${pool.id}.`);
                    }
                }
                addRecentActivity(`Farming pool ${pool.id} expired and deleted.`);
                delete state.farmingPools[poolId]; // Delete the pool
            }
        }

        // Update all displayed pages if they are currently rendered
        updateAllDisplays();
    }

    function updateAllDisplays() {
        // This is a simplified way to update all pages. In a real app, you'd only update the active page.
        // For this simulation, we'll re-render relevant sections.
        const currentPageId = mainContentDiv.dataset.currentPage;
        if (currentPageId === 'home') updateHomePageStats();
        if (currentPageId === 'dexTrade') attachDexTradeListeners(); // Re-attach to update values
        if (currentPageId === 'liquidity') updateLiquidityPoolsDisplay();
        if (currentPageId === 'farming') updateFarmingPoolsDisplay();
        if (currentPageId === 'presaleStage') updatePresaleDisplays();
        if (currentPageId === 'game') updateGamePageDisplays();
        if (currentPageId === 'platformWallet') renderPlatformWalletPage(); // Re-render to update balances
    }

    // --- Bot AI Functions ---

    function performBotTrade(botId) {
        const bot = state.users[botId];
        const poolIds = Object.keys(state.liquidityPools);
        if (poolIds.length === 0) return;

        const randomPoolId = poolIds[Math.floor(Math.random() * poolIds.length)];
        const pool = state.liquidityPools[randomPoolId];

        // Decide which token to sell (randomly choose one the bot has)
        const botHasTokenA = bot.balances[pool.tokenA.ticker] > 0;
        const botHasTokenB = bot.balances[pool.tokenB.ticker] > 0;

        let fromToken, toToken, fromAmount;

        if (botHasTokenA && botHasTokenB) {
            if (Math.random() < 0.5) { // Sell A, buy B
                fromToken = pool.tokenA.ticker;
                toToken = pool.tokenB.ticker;
                fromAmount = Math.random() * (bot.balances[fromToken] * state.platformSettings.botTradingAggressiveness); // Sell up to aggressiveness % of holding
            } else { // Sell B, buy A
                fromToken = pool.tokenB.ticker;
                toToken = pool.tokenA.ticker;
                fromAmount = Math.random() * (bot.balances[fromToken] * state.platformSettings.botTradingAggressiveness);
            }
        } else if (botHasTokenA) { // Only has A, must sell A
            fromToken = pool.tokenA.ticker;
            toToken = pool.tokenB.ticker;
            fromAmount = Math.random() * (bot.balances[fromToken] * state.platformSettings.botTradingAggressiveness);
        } else if (botHasTokenB) { // Only has B, must sell B
            fromToken = pool.tokenB.ticker;
            toToken = pool.tokenA.ticker;
            fromAmount = Math.random() * (bot.balances[fromToken] * state.platformSettings.botTradingAggressiveness);
        } else {
            return; // Bot has neither token in this pool
        }

        if (fromAmount <= 0 || bot.balances[fromToken] < fromAmount) return;

        let inputReserve, outputReserve;
        if (pool.tokenA.ticker === fromToken) {
            inputReserve = pool.balanceA;
            outputReserve = pool.balanceB;
        } else {
            inputReserve = pool.balanceB;
            outputReserve = pool.balanceA;
        }

        const { outputAmount } = calculateSwapOutput(fromAmount, inputReserve, outputReserve);
        if (outputAmount <= 0) return;

        const swapUsdValue = calculateTokenUSDValue(fromToken, fromAmount);
        if (!applyTransactionFee(bot.id, swapUsdValue, 'Swap', pool.id)) {
            return; // Bot failed to pay fee
        }

        bot.balances[fromToken] -= fromAmount;
        bot.balances[toToken] = (bot.balances[toToken] || 0) + outputAmount;

        if (pool.tokenA.ticker === fromToken) {
            pool.balanceA += fromAmount;
            pool.balanceB -= outputAmount;
        } else {
            pool.balanceB += fromAmount;
            pool.balanceA -= outputAmount;
        }

        // Update token prices based on new pool ratio
        state.tokens[pool.tokenA.ticker].price_usd = pool.balanceB / pool.balanceA;
        state.tokens[pool.tokenB.ticker].price_usd = pool.balanceA / pool.balanceB;
        state.tokens[pool.tokenA.ticker].market_cap_usd = state.tokens[pool.tokenA.ticker].circulating_supply * state.tokens[pool.tokenA.ticker].price_usd;
        state.tokens[pool.tokenB.ticker].market_cap_usd = state.tokens[pool.tokenB.ticker].circulating_supply * state.tokens[pool.tokenB.ticker].price_usd;

        // Creator fee for bot-launched tokens (if the toToken is a creator's token)
        const creatorToken = state.tokens[toToken];
        if (creatorToken.creator_id && creatorToken.creator_id.startsWith('bot_') && creatorToken.creator_id !== bot.id) { // Not the bot itself
            const creatorBot = state.users[creatorToken.creator_id];
            const creatorFeeAmount = outputAmount * 0.01; // 1% of received token
            creatorBot.balances[toToken] = (creatorBot.balances[toToken] || 0) + creatorFeeAmount;
            addRecentActivity(`${creatorBot.id} earned ${formatTokenAmount(creatorFeeAmount, creatorToken.decimals)} ${toToken} creator fee from bot swap.`);
        }

        addRecentActivity(`Bot ${bot.id.split('_')[1]} swapped ${formatTokenAmount(fromAmount, state.tokens[fromToken].decimals)} ${fromToken} for ${formatTokenAmount(outputAmount, state.tokens[toToken].decimals)} ${toToken}.`);
    }

    function performBotLpActivity(botId) {
        const bot = state.users[botId];
        const poolIds = Object.keys(state.liquidityPools);
        if (poolIds.length === 0) return;

        const randomPoolId = poolIds[Math.floor(Math.random() * poolIds.length)];
        const pool = state.liquidityPools[randomPoolId];

        const actionType = Math.random() < 0.7 ? 'add' : 'remove'; // 70% add, 30% remove

        if (actionType === 'add') {
            const amountA = (bot.balances[pool.tokenA.ticker] || 0) * (Math.random() * state.platformSettings.botLpAddAggressiveness); // Add up to aggressiveness % of holding
            const amountB = (bot.balances[pool.tokenB.ticker] || 0) * (Math.random() * state.platformSettings.botLpAddAggressiveness);

            if (amountA <= 0 || amountB <= 0 || bot.balances[pool.tokenA.ticker] < amountA || bot.balances[pool.tokenB.ticker] < amountB) return;

            const usdValue = calculateTokenUSDValue(pool.tokenA.ticker, amountA) + calculateTokenUSDValue(pool.tokenB.ticker, amountB);
            if (!applyTransactionFee(bot.id, usdValue, 'AddLiquidity', pool.id)) return;

            bot.balances[pool.tokenA.ticker] -= amountA;
            bot.balances[pool.tokenB.ticker] -= amountB;
            pool.balanceA += amountA;
            pool.balanceB += amountB;
            pool.k = pool.balanceA * pool.balanceB;
            pool.lpTokenSupply += Math.sqrt(amountA * amountB); // Simplified LP token minting

            // Update token prices based on new pool ratio
            state.tokens[pool.tokenA.ticker].price_usd = pool.balanceB / pool.balanceA;
            state.tokens[pool.tokenB.ticker].price_usd = pool.balanceA / pool.balanceB;
            state.tokens[pool.tokenA.ticker].market_cap_usd = state.tokens[pool.tokenA.ticker].circulating_supply * state.tokens[pool.tokenA.ticker].price_usd;
            state.tokens[pool.tokenB.ticker].market_cap_usd = state.tokens[pool.tokenB.ticker].circulating_supply * state.tokens[pool.tokenB.ticker].price_usd;

            addRecentActivity(`Bot ${bot.id.split('_')[1]} added liquidity to ${pool.id}.`);

        } else { // remove
            const lpAmountToRemove = pool.lpTokenSupply * (Math.random() * 0.01); // Remove up to 1% of pool LP for demo
            if (lpAmountToRemove <= 0) return;

            const tokenARemoved = pool.balanceA * (lpAmountToRemove / pool.lpTokenSupply);
            const tokenBRemoved = pool.balanceB * (lpAmountToRemove / pool.lpTokenSupply);

            const usdValue = calculateTokenUSDValue(pool.tokenA.ticker, tokenARemoved) + calculateTokenUSDValue(pool.tokenB.ticker, tokenBRemoved);
            if (!applyTransactionFee(bot.id, usdValue, 'RemoveLiquidity', pool.id)) return;

            pool.balanceA -= tokenARemoved;
            pool.balanceB -= tokenBRemoved;
            pool.lpTokenSupply -= lpAmountToRemove;
            bot.balances[pool.tokenA.ticker] = (bot.balances[pool.tokenA.ticker] || 0) + tokenARemoved;
            bot.balances[pool.tokenB.ticker] = (bot.balances[pool.tokenB.ticker] || 0) + tokenBRemoved;

            // Update token prices based on new pool ratio
            state.tokens[pool.tokenA.ticker].price_usd = pool.balanceB / pool.balanceA;
            state.tokens[pool.tokenB.ticker].price_usd = pool.balanceA / pool.balanceB;
            state.tokens[pool.tokenA.ticker].market_cap_usd = state.tokens[pool.tokenA.ticker].circulating_supply * state.tokens[pool.tokenA.ticker].price_usd;
            state.tokens[pool.tokenB.ticker].market_cap_usd = state.tokens[pool.tokenB.ticker].circulating_supply * state.tokens[pool.tokenB.ticker].price_usd;

            addRecentActivity(`Bot ${bot.id.split('_')[1]} removed liquidity from ${pool.id}.`);
        }
    }

    function performBotFarmingActivity(botId) {
        const bot = state.users[botId];
        const activeFarmingPools = Object.values(state.farmingPools).filter(p => Date.now() < p.endTime);
        if (activeFarmingPools.length === 0) return;

        const randomPool = activeFarmingPools[Math.floor(Math.random() * activeFarmingPools.length)];
        const pool = randomPool;

        const actionType = Math.random() < 0.8 ? 'stake' : 'claim'; // 80% stake, 20% claim

        if (actionType === 'stake') {
            const amountToStake = (bot.balances[pool.stakedToken.ticker] || 0) * (Math.random() * state.platformSettings.botFarmingAggressiveness); // Stake up to aggressiveness %
            if (amountToStake <= 0 || bot.balances[pool.stakedToken.ticker] < amountToStake) return;

            const usdValue = calculateTokenUSDValue(pool.stakedToken.ticker, amountToStake);
            if (!applyTransactionFee(bot.id, usdValue, 'StakeFarming', pool.id)) return;

            bot.balances[pool.stakedToken.ticker] -= amountToStake;
            pool.totalStakedAmount += amountToStake;

            if (!pool.stakers[bot.id]) {
                pool.stakers[bot.id] = {
                    stakedAmount: 0,
                    stakeTime: Date.now(),
                    claimableRewards: 0,
                    unstakeAvailableTimestamp: pool.lockupDurationSeconds > 0 ? Date.now() + pool.lockupDurationSeconds * 1000 : 0,
                    lastClaimTime: Date.now(),
                };
            }
            pool.stakers[bot.id].stakedAmount += amountToStake;
            addRecentActivity(`Bot ${bot.id.split('_')[1]} staked ${formatTokenAmount(amountToStake, pool.stakedToken.decimals)} ${pool.stakedToken.ticker} in ${pool.id}.`);

        } else { // claim
            const userStake = pool.stakers[bot.id];
            if (!userStake || userStake.claimableRewards <= 0) return;

            const rewards = userStake.claimableRewards;
            const usdValue = calculateTokenUSDValue(pool.rewardToken.ticker, rewards);
            if (!applyTransactionFee(bot.id, usdValue, 'ClaimFarmingRewards', pool.id)) return;

            bot.balances[pool.rewardToken.ticker] = (bot.balances[pool.rewardToken.ticker] || 0) + rewards;
            userStake.claimableRewards = 0;
            userStake.lastClaimTime = Date.now();
            addRecentActivity(`Bot ${bot.id.split('_')[1]} claimed ${formatTokenAmount(rewards, pool.rewardToken.decimals)} ${pool.rewardToken.ticker} from ${pool.id}.`);
        }
    }

    async function performBotPresaleContribution(botId) {
        const bot = state.users[botId];
        const activePresales = Object.values(state.presaleProjects).filter(p => p.status === 'Active' && p.tokensSold < p.tokensForSale);

        if (activePresales.length === 0) return;

        const project = activePresales[Math.floor(Math.random() * activePresales.length)];

        // Bots try to fill the presale quickly (within 1 minute)
        const remainingUsdtNeeded = project.hardCapUsdt - project.usdtRaised;
        const botUsdtBalance = bot.balances.USDT;

        // Bot buys a random chunk of the remaining presale, up to its aggressiveness
        const maxBuyUsdt = Math.min(remainingUsdtNeeded, botUsdtBalance * state.platformSettings.botTradingAggressiveness);
        const usdtAmount = Math.random() * maxBuyUsdt;

        if (usdtAmount <= 0) return;

        const tokensToReceive = usdtAmount / project.tokenDetails.price_usd;
        if (project.tokensSold + tokensToReceive > project.tokensForSale) {
            // Adjust amount to exactly fill if it's too much
            const actualUsdtAmount = (project.tokensForSale - project.tokensSold) * project.tokenDetails.price_usd;
            if (actualUsdtAmount <= 0) return;
            // Ensure bot has enough USDT for this exact amount
            if (bot.balances.USDT < actualUsdtAmount) return;
            
            const confirmBuy = true; // Bots don't need confirmation modal
            if (confirmBuy) {
                if (!applyTransactionFee(bot.id, actualUsdtAmount, 'PresaleBuy', null)) return;

                bot.balances.USDT -= actualUsdtAmount;
                project.usdtRaised += actualUsdtAmount;
                project.tokensSold += (actualUsdtAmount / project.tokenDetails.price_usd);
                project.progressPercent = (project.usdtRaised / project.hardCapUsdt) * 100;

                project.buyersList.push({
                    userId: bot.id,
                    usdtContributed: actualUsdtAmount,
                    tokensToReceive: (actualUsdtAmount / project.tokenDetails.price_usd),
                    claimedAirdrop: false,
                });
                addRecentActivity(`Bot ${bot.id.split('_')[1]} bought ${formatTokenAmount((actualUsdtAmount / project.tokenDetails.price_usd), project.tokenDetails.decimals)} ${project.tokenDetails.ticker} in presale.`);

                if (project.progressPercent >= 100) {
                    project.status = 'Filled';
                    addRecentActivity(`Presale for ${project.tokenDetails.ticker} filled! Listing on DEX...`);
                    await listTokenOnDex(project.projectId);
                }
            }

        } else { // Regular buy
            const confirmBuy = true; // Bots don't need confirmation modal
            if (confirmBuy) {
                if (!applyTransactionFee(bot.id, usdtAmount, 'PresaleBuy', null)) return;

                bot.balances.USDT -= usdtAmount;
                project.usdtRaised += usdtAmount;
                project.tokensSold += tokensToReceive;
                project.progressPercent = (project.usdtRaised / project.hardCapUsdt) * 100;

                project.buyersList.push({
                    userId: bot.id,
                    usdtContributed: usdtAmount,
                    tokensToReceive: tokensToReceive,
                    claimedAirdrop: false,
                });
                addRecentActivity(`Bot ${bot.id.split('_')[1]} bought ${formatTokenAmount(tokensToReceive, project.tokenDetails.decimals)} ${project.tokenDetails.ticker} in presale.`);

                if (project.progressPercent >= 100) {
                    project.status = 'Filled';
                    addRecentActivity(`Presale for ${project.tokenDetails.ticker} filled! Listing on DEX...`);
                    await listTokenOnDex(project.projectId);
                }
            }
        }
    }


    function createBotTokenApplication(botId) {
        const bot = state.users[botId];
        const tokenName = `BotCoin${Math.floor(Math.random() * 1000)}`;
        const tokenTicker = `BC${Math.floor(Math.random() * 10000).toString().padStart(4, '0')}`;
        const totalSupply = Math.floor(Math.random() * 9 + 1) * 100000000; // 100M to 1B
        const stablecoinPair = Math.random() < 0.5 ? 'USDT' : 'USDC';
        const stablecoinAmount = 5000 + Math.random() * 20000; // $5k to $25k

        // Randomly generate percentages that sum to 100
        let percentages = {};
        let remaining = 100;

        const maxL = state.platformSettings.maxLiquidityPercentLaunch;
        const maxB = state.platformSettings.maxBurnPercentLaunch;
        const maxP = state.platformSettings.maxPresalePercentLaunch;
        const maxT = state.platformSettings.maxTeamPercentLaunch;

        percentages.platformPercent = 5; // Fixed 5%
        remaining -= 5;

        // Allocate randomly within limits, ensuring sum is 100
        // This is a simplified allocation to ensure it sums to 100%
        percentages.liquidityPercent = Math.min(maxL, Math.floor(Math.random() * (remaining * 0.6)));
        remaining -= percentages.liquidityPercent;

        percentages.burnPercent = Math.min(maxB, Math.floor(Math.random() * (remaining * 0.3)));
        remaining -= percentages.burnPercent;

        percentages.presalePercent = Math.min(maxP, Math.floor(Math.random() * (remaining * 0.5)));
        remaining -= percentages.presalePercent;

        percentages.teamPercent = remaining; // Assign remaining to team

        // Ensure no negative or over-max values after rounding/randomness
        for (const key in percentages) {
            if (percentages[key] < 0) percentages[key] = 0;
            if (key === 'liquidityPercent') percentages[key] = Math.min(percentages[key], maxL);
            if (key === 'burnPercent') percentages[key] = Math.min(percentages[key], maxB);
            if (key === 'presalePercent') percentages[key] = Math.min(percentages[key], maxP);
            if (key === 'teamPercent') percentages[key] = Math.min(percentages[key], maxT);
        }

        // Re-normalize if sum is not 100 due to min/max clamping
        let currentSum = percentages.liquidityPercent + percentages.burnPercent + percentages.platformPercent + percentages.presalePercent + percentages.teamPercent;
        if (currentSum !== 100) {
            const factor = 100 / currentSum;
            for (const key in percentages) {
                percentages[key] = Math.round(percentages[key] * factor);
            }
        }
        // Final check to ensure it sums to 100 after rounding
        let finalSum = percentages.liquidityPercent + percentages.burnPercent + percentages.platformPercent + percentages.presalePercent + percentages.teamPercent;
        if (finalSum !== 100) {
            percentages.teamPercent += (100 - finalSum); // Adjust team percent to make it exactly 100
        }


        const initialBurnAmount = totalSupply * (percentages.burnPercent / 100);
        const circulatingSupply = totalSupply - initialBurnAmount;
        const liquidityTokenAmount = totalSupply * (percentages.liquidityPercent / 100);
        const presaleTokenAmount = totalSupply * (percentages.presalePercent / 100);
        const teamTokenAmount = totalSupply * (percentages.teamPercent / 100);
        const platformTokenAmount = totalSupply * (percentages.platformPercent / 100);

        const initialPriceUsd = stablecoinAmount / liquidityTokenAmount;
        const initialMarketCap = circulatingSupply * initialPriceUsd;

        const newProjectId = generateUniqueId();
        const newToken = {
            ticker: tokenTicker,
            name: tokenName,
            total_supply: totalSupply,
            circulating_supply: circulatingSupply,
            decimals: 6,
            price_usd: initialPriceUsd,
            market_cap_usd: initialMarketCap,
            is_base_asset: false,
            is_stablecoin: false,
            creator_id: botId,
            launch_details: {
                initial_liquidity_percent: percentages.liquidityPercent,
                initial_burn_percent: percentages.burnPercent,
                platform_allocation_percent: percentages.platformPercent,
                presale_allocation_percent: percentages.presalePercent,
                team_allocation_percent: percentages.teamPercent,
                initial_price_usd: initialPriceUsd,
                rug_pull_chance: 0.5,
                build_chance: 0.5,
                team_wallet_balance: teamTokenAmount, // Initial team allocation
                status: 'Pending Approval', // Status for launched tokens
                build_log: [], // Initialize build log
            },
        };

        state.tokens[tokenTicker] = newToken;

        // Create presale project
        state.presaleProjects[newProjectId] = {
            projectId: newProjectId,
            tokenDetails: newToken,
            creatorId: botId,
            status: 'Pending Approval', // Bots always start as pending
            hardCapUsdt: stablecoinAmount,
            softCapUsdt: stablecoinAmount * 0.5,
            usdtRaised: 0,
            tokensForSale: presaleTokenAmount,
            tokensSold: 0,
            buyersList: [],
            progressPercent: 0,
            initialDexLiquidityUsdt: stablecoinAmount,
            initial_dex_liquidity_tokens: liquidityTokenAmount,
        };
        addRecentActivity(`Bot ${botId.split('_')[1]} submitted a new token application: ${tokenTicker}.`);
    }

    async function performBotBuildingActivity(botId) {
        const bot = state.users[botId];
        // Find tokens launched by this bot that are 'Listed on DEX' and are in 'BUILD' mode
        const botLaunchedTokens = Object.values(state.tokens).filter(t => t.creator_id === botId && t.launch_details?.status === 'Listed on DEX' && t.launch_details?.build_log.some(log => log.message.includes('BUILD mode')));

        for (const token of botLaunchedTokens) {
            // 1. Add More Liquidity (random amount up to 50% of holdings)
            if (Math.random() < 0.3) { // 30% chance to add more liquidity
                const poolId = `${token.ticker}-USDT`;
                const pool = state.liquidityPools[poolId];
                if (pool && bot.balances[token.ticker] > 0 && bot.balances.USDT > 0) {
                    const amountToAddToken = Math.random() * (bot.balances[token.ticker] * 0.5); // Up to 50% of bot's token holdings
                    const amountToAddUsdt = amountToAddToken * token.price_usd;

                    if (amountToAddToken > 0 && amountToAddUsdt > 0 && bot.balances.USDT >= amountToAddUsdt) {
                        const usdValue = calculateTokenUSDValue(token.ticker, amountToAddToken) + calculateTokenUSDValue('USDT', amountToAddUsdt);
                        if (!applyTransactionFee(bot.id, usdValue, 'AddLiquidity', pool.id)) return;

                        bot.balances[token.ticker] -= amountToAddToken;
                        bot.balances.USDT -= amountToAddUsdt;
                        pool.balanceA += amountToAddToken;
                        pool.balanceB += amountToAddUsdt; // Corrected to amountToAddUsdt
                        pool.k = pool.balanceA * pool.balanceB;
                        pool.lpTokenSupply += Math.sqrt(amountToAddToken * amountToAddUsdt); // Simplified LP token minting

                        // Update token prices based on new pool ratio
                        state.tokens[pool.tokenA.ticker].price_usd = pool.balanceB / pool.balanceA;
                        state.tokens[pool.tokenB.ticker].price_usd = pool.balanceA / pool.balanceB;
                        state.tokens[pool.tokenA.ticker].market_cap_usd = state.tokens[pool.tokenA.ticker].circulating_supply * state.tokens[pool.tokenA.ticker].price_usd;
                        state.tokens[pool.tokenB.ticker].market_cap_usd = state.tokens[pool.tokenB.ticker].circulating_supply * state.tokens[pool.tokenB.ticker].price_usd;

                        token.launch_details.build_log.push({timestamp: Date.now(), message: `Added ${formatTokenAmount(amountToAddToken, token.decimals)} ${token.ticker} liquidity.`});
                        addRecentActivity(`Bot ${bot.id.split('_')[1]} added more liquidity to ${token.ticker}-USDT.`);
                    }
                }
            }

            // 2. Create & Fund Farming Pools
            if (Math.random() < 0.2 && !Object.values(state.farmingPools).some(p => p.creator_id === bot.id && p.stakedToken.ticker === token.ticker)) { // 20% chance, and only if no active pool for this token by this bot
                if (bot.balances[token.ticker] > 0 && bot.balances.PDEX > 0) { // Bot needs its own token and PDEX for rewards (example)
                    const rewardAmount = bot.balances[token.ticker] * 0.1; // 10% of holdings as reward
                    const durationHours = Math.floor(Math.random() * (24 - 6 + 1)) + 6; // 6 to 24 hours
                    const lockupHours = Math.random() < 0.5 ? 0 : Math.floor(Math.random() * (durationHours / 2)); // Up to half duration

                    if (rewardAmount > 0) {
                        const poolId = `FARM-${token.ticker}-PDEX-${generateUniqueId()}`;
                        const durationSeconds = durationHours * 3600;
                        const lockupDurationSeconds = lockupHours * 3600;

                        bot.balances[token.ticker] -= rewardAmount; // Deduct reward token from bot
                        state.farmingPools[poolId] = {
                            id: poolId,
                            stakedToken: token,
                            rewardToken: state.tokens.PDEX, // Bots reward with PDEX for this example
                            totalStakedAmount: 0,
                            rewardRatePerSecond: rewardAmount / durationSeconds,
                            durationSeconds: durationSeconds,
                            lockupDurationSeconds: lockupDurationSeconds,
                            type: 'Volatile', // Bot-launched tokens are volatile
                            availableRewards: rewardAmount,
                            startTime: Date.now(),
                            endTime: Date.now() + durationSeconds * 1000,
                            stakers: {},
                            creator_id: bot.id,
                        };
                        token.launch_details.build_log.push({timestamp: Date.now(), message: `Created farming pool ${poolId} with ${formatTokenAmount(rewardAmount, token.decimals)} ${token.ticker} rewards.`});
                        addRecentActivity(`Bot ${bot.id.split('_')[1]} created a farming pool for ${token.ticker}.`);
                    }
                }
            }

            // 3. Fund Gaming Pool
            if (Math.random() < 0.1 && bot.balances[token.ticker] > 0) { // 10% chance
                const amountToFund = bot.balances[token.ticker] * 0.001; // 0.1% of holdings
                if (amountToFund > 0) {
                    bot.balances[token.ticker] -= amountToFund;
                    state.gameRewardsPool.availableRewards[token.ticker] = (state.gameRewardsPool.availableRewards[token.ticker] || 0) + amountToFund;
                    token.launch_details.build_log.push({timestamp: Date.now(), message: `Funded game pool with ${formatTokenAmount(amountToFund, token.decimals)} ${token.ticker}.`});
                    addRecentActivity(`Bot ${bot.id.split('_')[1]} funded game pool with ${formatTokenAmount(amountToFund, token.decimals)} ${token.ticker}.`);
                }
            }

            // 4. Market Making (Buy Back)
            if (Math.random() < 0.4) { // 40% chance to market make
                const poolId = `${token.ticker}-USDT`;
                const pool = state.liquidityPools[poolId];
                if (pool && bot.balances.USDT > 0) {
                    const buyAmountUsdt = Math.random() * (bot.balances.USDT * state.platformSettings.botTradingAggressiveness); // Buy up to aggressiveness % of bot's USDT
                    if (buyAmountUsdt > 0) {
                        const { outputAmount: tokenReceived } = calculateSwapOutput(buyAmountUsdt, pool.balanceB, pool.balanceA); // USDT to Token
                        if (tokenReceived <= 0) return;

                        const swapUsdValue = buyAmountUsdt;
                        if (!applyTransactionFee(bot.id, swapUsdValue, 'MarketMakeBuy', pool.id)) return;

                        bot.balances.USDT -= buyAmountUsdt;
                        bot.balances[token.ticker] = (bot.balances[token.ticker] || 0) + tokenReceived;
                        pool.balanceB += buyAmountUsdt;
                        pool.balanceA -= tokenReceived;

                        // Update token prices based on new pool ratio
                        state.tokens[pool.tokenA.ticker].price_usd = pool.balanceB / pool.balanceA;
                        state.tokens[pool.tokenB.ticker].price_usd = pool.balanceA / pool.balanceB;
                        state.tokens[pool.tokenA.ticker].market_cap_usd = state.tokens[pool.tokenA.ticker].circulating_supply * state.tokens[pool.tokenA.ticker].price_usd;
                        state.tokens[pool.tokenB.ticker].market_cap_usd = state.tokens[pool.tokenB.ticker].circulating_supply * state.tokens[pool.tokenB.ticker].price_usd;

                        token.launch_details.build_log.push({timestamp: Date.now(), message: `Bought back ${formatTokenAmount(tokenReceived, token.decimals)} ${token.ticker}.`});
                        addRecentActivity(`Bot ${bot.id.split('_')[1]} bought ${formatTokenAmount(tokenReceived, token.decimals)} ${token.ticker} (market make).`);
                    }
                }
            }
            // 5. Airdrop to Top Holders (simplified)
            if (Math.random() < 0.05 && bot.balances[token.ticker] > 0) { // 5% chance
                const airdropAmount = bot.balances[token.ticker] * 0.005; // 0.5% of holdings for airdrop
                if (airdropAmount > 0) {
                    const topHolders = Object.values(state.users)
                        .filter(u => u.balances[token.ticker] > 0 && u.id !== bot.id)
                        .sort((a, b) => b.balances[token.ticker] - a.balances[token.ticker])
                        .slice(0, 3);
                    
                    if (topHolders.length > 0) {
                        const amountPerHolder = airdropAmount / topHolders.length;
                        bot.balances[token.ticker] -= airdropAmount; // Deduct from bot
                        topHolders.forEach(holder => {
                            holder.balances[token.ticker] = (holder.balances[token.ticker] || 0) + amountPerHolder;
                        });
                        token.launch_details.build_log.push({timestamp: Date.now(), message: `Airdropped ${formatTokenAmount(airdropAmount, token.decimals)} ${token.ticker} to top holders.`});
                        addRecentActivity(`Bot ${bot.id.split('_')[1]} airdropped ${formatTokenAmount(airdropAmount, token.decimals)} ${token.ticker} to top holders.`);
                    }
                }
            }
        }
    }

    function performBotGamePlay(botId) {
        const bot = state.users[botId];
        const payToken = 'USDT'; // Bots always pay with USDT for simplicity
        const payAmountUsd = 1;
        const payAmountToken = payAmountUsd / state.tokens[payToken].price_usd;

        if (bot.balances[payToken] < payAmountToken) return;

        // Deduct fee first
        if (!applyTransactionFee(bot.id, payAmountUsd, 'GamePlay', null)) return;

        bot.balances[payToken] -= payAmountToken;
        state.gameRewardsPool.availableRewards[payToken] = (state.gameRewardsPool.availableRewards[payToken] || 0) + payAmountToken; // $1 goes back to pool

        const isWin = Math.random() < 0.2; // 20% win chance
        let rewardsWon = [];
        let outcomeMessage = '';

        if (isWin) {
            const availableRewardTokens = Object.keys(state.gameRewardsPool.availableRewards).filter(t => state.gameRewardsPool.availableRewards[t] > 0);
            if (availableRewardTokens.length === 0) {
                outcomeMessage = 'won, but pool was empty.';
            } else {
                let selectedReward = null;
                let cumulativeProbability = 0;
                const rand = Math.random();

                for (const prob of state.gameRewardsPool.rewardProbabilities) {
                    if (availableRewardTokens.includes(prob.token) && state.gameRewardsPool.availableRewards[prob.token] > 0) {
                        cumulativeProbability += prob.probability;
                        if (rand < cumulativeProbability) {
                            selectedReward = prob;
                            break;
                        }
                    }
                }

                if (!selectedReward) { // Fallback
                    selectedReward = state.gameRewardsPool.rewardProbabilities.find(p => availableRewardTokens.includes(p.token) && state.gameRewardsPool.availableRewards[p.token] > 0);
                }

                if (selectedReward) {
                    let rewardAmount;
                    if (selectedReward.isUsdValue) {
                        rewardAmount = (Math.random() * (selectedReward.maxAmount - selectedReward.minAmount) + selectedReward.minAmount) / state.tokens[selectedReward.token].price_usd;
                    } else {
                        rewardAmount = Math.random() * (selectedReward.maxAmount - selectedReward.minAmount) + selectedReward.minAmount;
                    }
                    rewardAmount = Math.min(rewardAmount, state.gameRewardsPool.availableRewards[selectedReward.token]); // Cap by available
                    rewardAmount = parseFloat(rewardAmount.toFixed(state.tokens[selectedReward.token]?.decimals || 4));

                    if (rewardAmount > 0) {
                        rewardsWon.push({ token: selectedReward.token, amount: rewardAmount });
                        state.gameRewardsPool.availableRewards[selectedReward.token] -= rewardAmount;
                        bot.gameRewardsPending.push({ gameId: generateUniqueId(), rewards: rewardsWon, claimable: true });
                        outcomeMessage = `won ${rewardsWon.map(r => `${formatTokenAmount(r.amount, state.tokens[r.token].decimals)} ${r.token}`).join(', ')}.`;
                    } else {
                        outcomeMessage = 'won, but no reward allocated.';
                    }
                }
            }
        } else {
            outcomeMessage = 'LOST.';
        }
        state.gameRewardsPool.last5Transactions.push({
            timestamp: Date.now(),
            userId: bot.id,
            action: 'Played',
            paidToken: payToken,
            paidAmountUsd: payAmountUsd,
            outcome: isWin ? 'Won' : 'Lost',
            rewardsWon: rewardsWon,
        });
        if (state.gameRewardsPool.last5Transactions.length > 5) {
            state.gameRewardsPool.last5Transactions.shift();
        }
        addRecentActivity(`Bot ${bot.id.split('_')[1]} played game and ${outcomeMessage}`);

        // Bot claims rewards immediately if won
        if (isWin && bot.gameRewardsPending.length > 0) {
            const totalUsdToClaim = bot.gameRewardsPending.reduce((sum, r) => sum + r.rewards.reduce((s, t) => s + calculateTokenUSDValue(t.token, t.amount), 0), 0);
            if (!applyTransactionFee(bot.id, totalUsdToClaim, 'ClaimGameRewards')) {
                // Bot failed to claim due to fee, rewards remain pending
                return;
            }
            bot.gameRewardsPending.forEach(pendingReward => {
                pendingReward.rewards.forEach(reward => {
                    bot.balances[reward.token] = (bot.balances[reward.token] || 0) + reward.amount;
                });
            });
            bot.gameRewardsPending = [];
        }
    }


    // --- Initialization & Start ---
    function initializeApp() {
      initializeTokens();
      initializeLiquidityPools();
      initializeUsersAndBots();
      state.appStats.recentActivity = []; // Initialize recent activity log
      renderHomePage(); // Render the initial page
      mainContentDiv.dataset.currentPage = 'home'; // Set initial page for updates
      simulationInterval = setInterval(simulationLoop, SIMULATION_TICK_INTERVAL); // Start simulation loop
    }

    // Call initializeApp when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', initializeApp);

  </script>
</body>
</html>
